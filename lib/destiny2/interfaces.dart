/**
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.3.2
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by the bungie-api-ts code generator program.
 * https://github.com/DestinyItemManager/bugie-api-ts
 * Do not edit these files manually.
 */

import '../common.dart';
import '../user/interfaces.dart';

class SingleComponentResponse<T> {
  T data;
  ComponentPrivacySetting privacy;
}

class DictionaryComponentResponse<T> {
  Map<String,T> data;
  ComponentPrivacySetting privacy;
}

/**
 * Information about a current character's status with a Progression. A progression
 * is a value that can increase with activity and has levels. Think Character Level
 * and Reputation Levels. Combine this "live" data with the related
 * DestinyProgressionDefinition for a full picture of the Progression.
 */
class DestinyProgression {
  /**
   * The hash identifier of the Progression in question. Use it to look up the
   * DestinyProgressionDefinition in static data.
   *
   * Mapped to DestinyProgressionDefinition in the manifest.
   */
  int progressionHash;
  /** The amount of progress earned today for this progression. */
  int dailyProgress;
  /** If this progression has a daily limit, this is that limit. */
  int dailyLimit;
  /** The amount of progress earned toward this progression in the current week. */
  int weeklyProgress;
  /** If this progression has a weekly limit, this is that limit. */
  int weeklyLimit;
  /**
   * This is the total amount of progress obtained overall for this progression (for
   * instance, the total amount of Character Level experience earned)
   */
  int currentProgress;
  /** This is the level of the progression (for instance, the Character Level). */
  int level;
  /**
   * This is the maximum possible level you can achieve for this progression (for
   * example, the maximum character level obtainable)
   */
  int levelCap;
  /**
   * Progressions define their levels in "steps". Since the last step may be
   * repeatable, the user may be at a higher level than the actual Step achieved in
   * the progression. Not necessarily useful, but potentially interesting for those
   * cruising the API. Relate this to the "steps" property of the DestinyProgression
   * to see which step the user is on, if you care about that. (Note that this is
   * Content Version dependent since it refers to indexes.)
   */
  int stepIndex;
  /**
   * The amount of progression (i.e. "Experience") needed to reach the next level of
   * this Progression. Jeez, progression is such an overloaded word.
   */
  int progressToNextLevel;
  /**
   * The total amount of progression (i.e. "Experience") needed in order to reach the
   * next level.
   */
  int nextLevelAt;
}

/**
 * A "Progression" in Destiny is best explained by an example.
 *
 * A Character's "Level" is a progression: it has Experience that can be earned,
 * levels that can be gained, and is evaluated and displayed at various points in
 * the game. A Character's "Faction Reputation" is also a progression for much the
 * same reason.
 *
 * Progression is used by a variety of systems, and the definition of a Progression
 * will generally only be useful if combining with live data (such as a character's
 * DestinyCharacterProgressionComponent.progressions property, which holds that
 * character's live Progression states).
 *
 * Fundamentally, a Progression measures your "Level" by evaluating the thresholds
 * in its Steps (one step per level, except for the last step which can be repeated
 * indefinitely for "Levels" that have no ceiling) against the total earned "
 * progression points"/experience. (for simplicity purposes, we will henceforth
 * refer to earned progression points as experience, though it need not be a
 * mechanic that in any way resembles Experience in a traditional sense).
 *
 * Earned experience is calculated in a variety of ways, determined by the
 * Progression's scope. These go from looking up a stored value to performing
 * exceedingly obtuse calculations. This is why we provide live data in
 * DestinyCharacterProgressionComponent.progressions, so you don't have to worry
 * about those.
 */
class DestinyProgressionDefinition {
  DestinyProgressionDisplayPropertiesDefinition displayProperties;
  /**
   * The "Scope" of the progression indicates the source of the progression's live
   * data.
   *
   * See the DestinyProgressionScope enum for more info: but essentially, a
   * Progression can either be backed by a stored value, or it can be a calculated
   * derivative of other values.
   */
  int scope;
  /** If this is True, then the progression doesn't have a maximum level. */
  bool repeatLastStep;
  /**
   * If there's a description of how to earn this progression in the local config,
   * this will be that localized description.
   */
  String source;
  /**
   * Progressions are divided into Steps, which roughly equate to "Levels" in the
   * traditional sense of a Progression. Notably, the last step can be repeated
   * indefinitely if repeatLastStep is true, meaning that the calculation for your
   * level is not as simple as comparing your current progress to the max progress of
   * the steps.
   *
   * These and more calculations are done for you if you grab live character
   * progression data, such as in the DestinyCharacterProgressionComponent.
   */
  List<DestinyProgressionStepDefinition> steps;
  /**
   * If true, the Progression is something worth showing to users.
   *
   * If false, BNet isn't going to show it. But that doesn't mean you can't. We're
   * all friends here.
   */
  bool visible;
  /**
   * If the value exists, this is the hash identifier for the Faction that owns this
   * Progression.
   *
   * This is purely for convenience, if you're looking at a progression and want to
   * know if and who it's related to in terms of Faction Reputation.
   *
   * Mapped to DestinyFactionDefinition in the manifest.
   */
  int factionHash;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinyProgressionDisplayPropertiesDefinition {
  /**
   * When progressions show your "experience" gained, that bar has units (i.e. "
   * Experience", "Bad Dudes Snuffed Out", whatever). This is the localized string
   * for that unit of measurement.
   */
  String displayUnitsName;
  String description;
  String name;
  /**
   * Note that "icon" is sometimes misleading, and should be interpreted in the
   * context of the entity. For instance, in Destiny 1 the
   * DestinyRecordBookDefinition's icon was a big picture of a book.
   *
   * But usually, it will be a small square image that you can use as... well, an
   * icon.
   */
  String icon;
  bool hasIcon;
}

class DestinyProgressionScope {
   static const int Account = 0;
   static const int Character = 1;
   static const int Clan = 2;
   static const int Item = 3;
   static const int ImplicitFromEquipment = 4;
   static const int Mapped = 5;
   static const int MappedAggregate = 6;
   static const int MappedStat = 7;
   static const int MappedUnlockValue = 8;
}

/**
 * This defines a single Step in a progression (which roughly equates to a level.
 * See DestinyProgressionDefinition for caveats).
 */
class DestinyProgressionStepDefinition {
  /**
   * Very rarely, Progressions will have localized text describing the Level of the
   * progression. This will be that localized text, if it exists. Otherwise, the
   * standard appears to be to simply show the level numerically.
   */
  String stepName;
  /**
   * This appears to be, when you "level up", whether a visual effect will display
   * and on what entity. See DestinyProgressionStepDisplayEffect for slightly more
   * info.
   */
  int displayEffectType;
  /**
   * The total amount of progression points/"experience" you will need to initially
   * reach this step. If this is the last step and the progression is repeating
   * indefinitely (DestinyProgressionDefinition.repeatLastStep), this will also be
   * the progress needed to level it up further by repeating this step again.
   */
  int progressTotal;
  /** A listing of items rewarded as a result of reaching this level. */
  List<DestinyItemQuantity> rewardItems;
  /**
   * If this progression step has a specific icon related to it, this is the icon to
   * show.
   */
  String icon;
}

class DestinyProgressionStepDisplayEffect {
   static const int None = 0;
   static const int Character = 1;
   static const int Item = 2;
}

/**
 * Used in a number of Destiny contracts to return data about an item stack and its
 * quantity. Can optionally return an itemInstanceId if the item is instanced - in
 * which case, the quantity returned will be 1. If it's not... uh, let me know okay?
 * Thanks.
 */
class DestinyItemQuantity {
  /**
   * The hash identifier for the item in question. Use it to look up the item's
   * DestinyInventoryItemDefinition.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int itemHash;
  /**
   * If this quantity is referring to a specific instance of an item, this will have
   * the item's instance ID. Normally, this will be null.
   */
  String itemInstanceId;
  /**
   * The amount of the item needed/available depending on the context of where
   * DestinyItemQuantity is being used.
   */
  int quantity;
}

/**
 * So much of what you see in Destiny is actually an Item used in a new and
 * creative way. This is the definition for Items in Destiny, which started off as
 * just entities that could exist in your Inventory but ended up being the backing
 * data for so much more: quests, reward previews, slots, and subclasses.
 *
 * In practice, you will want to associate this data with "live" item data from a
 * Bungie.Net Platform call: these definitions describe the item in generic, non-
 * instanced terms: but an actual instance of an item can vary widely from these
 * generic definitions.
 */
class DestinyInventoryItemDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * If this item has a collectible related to it, this is the hash identifier of
   * that collectible entry.
   *
   * Mapped to DestinyCollectibleDefinition in the manifest.
   */
  int collectibleHash;
  /**
   * A secondary icon associated with the item. Currently this is used in very
   * context specific applications, such as Emblem Nameplates.
   */
  String secondaryIcon;
  /**
   * Pulled from the secondary icon, this is the "secondary background" of the
   * secondary icon. Confusing? Sure, that's why I call it "overlay" here: because as
   * far as it's been used thus far, it has been for an optional overlay image. We'll
   * see if that holds up, but at least for now it explains what this image is a bit
   * better.
   */
  String secondaryOverlay;
  /**
   * Pulled from the Secondary Icon, this is the "special" background for the item.
   * For Emblems, this is the background image used on the Details view: but it need
   * not be limited to that for other types of items.
   */
  String secondarySpecial;
  /**
   * Sometimes, an item will have a background color. Most notably this occurs with
   * Emblems, who use the Background Color for small character nameplates such as the
   * "friends" view you see in-game. There are almost certainly other items that have
   * background color as well, though I have not bothered to investigate what items
   * have it nor what purposes they serve: use it as you will.
   */
  int backgroundColor;
  /**
   * If we were able to acquire an in-game screenshot for the item, the path to that
   * screenshot will be returned here. Note that not all items have screenshots:
   * particularly not any non-equippable items.
   */
  String screenshot;
  /**
   * The localized title/name of the item's type. This can be whatever the designers
   * want, and has no guarantee of consistency between items.
   */
  String itemTypeDisplayName;
  /**
   * A string identifier that the game's UI uses to determine how the item should be
   * rendered in inventory screens and the like. This could really be anything - at
   * the moment, we don't have the time to really breakdown and maintain all the
   * possible strings this could be, partly because new ones could be added ad hoc.
   * But if you want to use it to dictate your own UI, or look for items with a
   * certain display style, go for it!
   */
  String uiItemDisplayStyle;
  /**
   * It became a common enough pattern in our UI to show Item Type and Tier combined
   * into a single localized string that I'm just going to go ahead and start pre-
   * creating these for items.
   */
  String itemTypeAndTierDisplayName;
  /**
   * In theory, it is a localized string telling you about how you can find the item.
   * I really wish this was more consistent. Many times, it has nothing. Sometimes,
   * it's instead a more narrative-forward description of the item. Which is cool,
   * and I wish all properties had that data, but it should really be its own
   * property.
   */
  String displaySource;
  /**
   * An identifier that the game UI uses to determine what type of tooltip to show
   * for the item. These have no corresponding definitions that BNet can link to: so
   * it'll be up to you to interpret and display your UI differently according to
   * these styles (or ignore it).
   */
  String tooltipStyle;
  /**
   * If the item can be "used", this block will be non-null, and will have data
   * related to the action performed when using the item. (Guess what? 99% of the
   * time, this action is "dismantle". Shocker)
   */
  int action;
  /**
   * If this item can exist in an inventory, this block will be non-null. In practice,
   * every item that currently exists has one of these blocks. But note that it is
   * not necessarily guaranteed.
   */
  int inventory;
  /**
   * If this item is a quest, this block will be non-null. In practice, I wish I had
   * called this the Quest block, but at the time it wasn't clear to me whether it
   * would end up being used for purposes other than quests. It will contain data
   * about the steps in the quest, and mechanics we can use for displaying and
   * tracking the quest.
   */
  int setData;
  /**
   * If this item can have stats (such as a weapon, armor, or vehicle), this block
   * will be non-null and populated with the stats found on the item.
   */
  int stats;
  /**
   * If the item is an emblem that has a special Objective attached to it - for
   * instance, if the emblem tracks PVP Kills, or what-have-you. This is a bit
   * different from, for example, the Vanguard Kill Tracker mod, which pipes data
   * into the "art channel". When I get some time, I would like to standardize these
   * so you can get at the values they expose without having to care about what they'
   * re being used for and how they are wired up, but for now here's the raw data.
   */
  int emblemObjectiveHash;
  /**
   * If this item can be equipped, this block will be non-null and will be populated
   * with the conditions under which it can be equipped.
   */
  int equippingBlock;
  /**
   * If this item can be rendered, this block will be non-null and will be populated
   * with rendering information.
   */
  int translationBlock;
  /**
   * If this item can be Used or Acquired to gain other items (for instance, how
   * Eververse Boxes can be consumed to get items from the box), this block will be
   * non-null and will give summary information for the items that can be acquired.
   */
  int preview;
  /**
   * If this item can have a level or stats, this block will be non-null and will be
   * populated with default quality (item level, "quality", and infusion) data. See
   * the block for more details, there's often less upfront information in D2 so you'
   * ll want to be aware of how you use quality and item level on the definition
   * level now.
   */
  int quality;
  /**
   * The conceptual "Value" of an item, if any was defined. See the
   * DestinyItemValueBlockDefinition for more details.
   */
  int value;
  /**
   * If this item has a known source, this block will be non-null and populated with
   * source information. Unfortunately, at this time we are not generating sources:
   * that is some aggressively manual work which we didn't have time for, and I'm
   * hoping to get back to at some point in the future.
   */
  int sourceData;
  /**
   * If this item has Objectives (extra tasks that can be accomplished related to the
   * item... most frequently when the item is a Quest Step and the Objectives need to
   * be completed to move on to the next Quest Step), this block will be non-null and
   * the objectives defined herein.
   */
  int objectives;
  /**
   * If this item *is* a Plug, this will be non-null and the info defined herein. See
   * DestinyItemPlugDefinition for more information.
   */
  int plug;
  /**
   * If this item has related items in a "Gear Set", this will be non-null and the
   * relationships defined herein.
   */
  int gearset;
  /**
   * If this item is a "reward sack" that can be opened to provide other items, this
   * will be non-null and the properties of the sack contained herein.
   */
  int sack;
  /**
   * If this item has any Sockets, this will be non-null and the individual sockets
   * on the item will be defined herein.
   */
  int sockets;
  /** Summary data about the item. */
  int summary;
  /**
   * If the item has a Talent Grid, this will be non-null and the properties of the
   * grid defined herein. Note that, while many items still have talent grids, the
   * only ones with meaningful Nodes still on them will be Subclass/"Build" items.
   */
  int talentGrid;
  /**
   * If the item has stats, this block will be defined. It has the "raw" investment
   * stats for the item. These investment stats don't take into account the ways that
   * the items can spawn, nor do they take into account any Stat Group
   * transformations. I have retained them for debugging purposes, but I do not know
   * how useful people will find them.
   */
  List<DestinyItemInvestmentStatDefinition> investmentStats;
  /**
   * If the item has any *intrinsic* Perks (Perks that it will provide regardless of
   * Sockets, Talent Grid, and other transitory state), they will be defined here.
   */
  List<DestinyItemPerkEntryDefinition> perks;
  /**
   * If the item has any related Lore (DestinyLoreDefinition), this will be the hash
   * identifier you can use to look up the lore definition.
   *
   * Mapped to DestinyLoreDefinition in the manifest.
   */
  int loreHash;
  /**
   * There are times when the game will show you a "summary/vague" version of an item
   * - such as a description of its type represented as a
   * DestinyInventoryItemDefinition - rather than display the item itself.
   *
   * This happens sometimes when summarizing possible rewards in a tooltip. This is
   * the item displayed instead, if it exists.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int summaryItemHash;
  /**
   * If any animations were extracted from game content for this item, these will be
   * the definitions of those animations.
   */
  List<DestinyAnimationReference> animations;
  /**
   * BNet may forbid the execution of actions on this item via the API. If that is
   * occurring, allowActions will be set to false.
   */
  bool allowActions;
  /**
   * If we added any help or informational URLs about this item, these will be those
   * links.
   */
  List<HyperlinkReference> links;
  /**
   * The boolean will indicate to us (and you!) whether something *could* happen when
   * you transfer this item from the Postmaster that might be considered a "
   * destructive" action.
   *
   * It is not feasible currently to tell you (or ourelves!) in a consistent way
   * whether this *will* actually cause a destructive action, so we are playing it
   * safe: if it has the potential to do so, we will not allow it to be transferred
   * from the Postmaster by default. You will need to check for this flag before
   * transferring an item from the Postmaster, or else you'll end up receiving an
   * error.
   */
  bool doesPostmasterPullHaveSideEffects;
  /**
   * The intrinsic transferability of an item.
   *
   * I hate that this boolean is negative - but there's a reason.
   *
   * Just because an item is intrinsically transferrable doesn't mean that it can be
   * transferred, and we don't want to imply that this is the only source of that
   * transferability.
   */
  bool nonTransferrable;
  /**
   * BNet attempts to make a more formal definition of item "Categories", as defined
   * by DestinyItemCategoryDefinition. This is a list of all Categories that we were
   * able to algorithmically determine that this item is a member of. (for instance,
   * that it's a "Weapon", that it's an "Auto Rifle", etc...)
   *
   * The algorithm for these is, unfortunately, volatile. If you believe you see a
   * miscategorized item, please let us know on the Bungie API forums.
   *
   * Mapped to DestinyItemCategoryDefinition in the manifest.
   */
  List<int> itemCategoryHashes;
  /**
   * In Destiny 1, we identified some items as having particular categories that we'd
   * like to know about for various internal logic purposes. These are defined in
   * SpecialItemType, and while these days the itemCategoryHashes are the preferred
   * way of identifying types, we have retained this enum for its convenience.
   */
  int specialItemType;
  /**
   * A value indicating the "base" the of the item. This enum is a useful but
   * dramatic oversimplification of what it means for an item to have a "Type". Still,
   * it's handy in many situations.
   *
   * itemCategoryHashes are the preferred way of identifying types, we have retained
   * this enum for its convenience.
   */
  int itemType;
  /**
   * A value indicating the "sub-type" of the item. For instance, where an item might
   * have an itemType value "Weapon", this will be something more specific like "Auto
   * Rifle".
   *
   * itemCategoryHashes are the preferred way of identifying types, we have retained
   * this enum for its convenience.
   */
  int itemSubType;
  /**
   * We run a similarly weak-sauce algorithm to try and determine whether an item is
   * restricted to a specific class. If we find it to be restricted in such a way, we
   * set this classType property to match the class' enumeration value so that users
   * can easily identify class restricted items.
   *
   * If you see a mis-classed item, please inform the developers in the Bungie API
   * forum.
   */
  int classType;
  /**
   * If true, then you will be allowed to equip the item if you pass its other
   * requirements.
   *
   * This being false means that you cannot equip the item under any circumstances.
   */
  bool equippable;
  /**
   * Theoretically, an item can have many possible damage types. In *practice*, this
   * is not true, but just in case weapons start being made that have multiple (for
   * instance, an item where a socket has reusable plugs for every possible damage
   * type that you can choose from freely), this field will return all of the
   * possible damage types that are available to the weapon by default.
   *
   * Mapped to DestinyDamageTypeDefinition in the manifest.
   */
  List<int> damageTypeHashes;
  /**
   * This is the list of all damage types that we know ahead of time the item can
   * take on. Unfortunately, this does not preclude the possibility of something
   * funky happening to give the item a damage type that cannot be predicted
   * beforehand: for example, if some designer decides to create arbitrary non-
   * reusable plugs that cause damage type to change.
   *
   * This damage type prediction will only use the following to determine potential
   * damage types:
   *
   * - Intrinsic perks
   *
   * - Talent Node perks
   *
   * - Known, reusable plugs for sockets
   */
  List<DamageType> damageTypes;
  /**
   * If the item has a damage type that could be considered to be default, it will be
   * populated here.
   *
   * For various upsetting reasons, it's surprisingly cumbersome to figure this out.
   * I hope you're happy.
   */
  int defaultDamageType;
  /**
   * Similar to defaultDamageType, but represented as the hash identifier for a
   * DestinyDamageTypeDefinition.
   *
   * I will likely regret leaving in the enumeration versions of these properties,
   * but for now they're very convenient.
   *
   * Mapped to DestinyDamageTypeDefinition in the manifest.
   */
  int defaultDamageTypeHash;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * Many Destiny*Definition contracts - the "first order" entities of Destiny that
 * have their own tables in the Manifest Database - also have displayable
 * information. This is the base class for that display information.
 */
class DestinyDisplayPropertiesDefinition {
  String description;
  String name;
  /**
   * Note that "icon" is sometimes misleading, and should be interpreted in the
   * context of the entity. For instance, in Destiny 1 the
   * DestinyRecordBookDefinition's icon was a big picture of a book.
   *
   * But usually, it will be a small square image that you can use as... well, an
   * icon.
   */
  String icon;
  bool hasIcon;
}

/** Defines a */
class DestinyCollectibleDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * Indicates whether this Collectible's state is determined on a per-character or
   * on an account-wide basis.
   */
  int scope;
  /** A human readable string for a hint about how to acquire the item. */
  String sourceString;
  /**
   * This is a hash identifier we are building on the BNet side in an attempt to let
   * people group collectibles by similar sources.
   *
   * I can't promise that it's going to be 100% accurate, but if the designers were
   * consistent in assigning the same source strings to items with the same sources,
   * it *ought to* be. No promises though.
   *
   * This hash also doesn't relate to an actual definition, just to note: we've got
   * nothing useful other than the source string for this data.
   */
  int sourceHash;
  /** Mapped to DestinyInventoryItemDefinition in the manifest. */
  int itemHash;
  DestinyCollectibleAcquisitionBlock acquisitionInfo;
  DestinyCollectibleStateBlock stateInfo;
  DestinyPresentationChildBlock presentationInfo;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinyScope {
   static const int Profile = 0;
   static const int Character = 1;
}

class DestinyCollectibleAcquisitionBlock {
  /** Mapped to DestinyMaterialRequirementSetDefinition in the manifest. */
  int acquireMaterialRequirementHash;
  /** Mapped to DestinyUnlockValueDefinition in the manifest. */
  int acquireTimestampUnlockValueHash;
}

/**
 * Represent a set of material requirements: Items that either need to be owned or
 * need to be consumed in order to perform an action.
 *
 * A variety of other entities refer to these as gatekeepers and payments for
 * actions that can be performed in game.
 */
class DestinyMaterialRequirementSetDefinition {
  /** The list of all materials that are required. */
  List<DestinyMaterialRequirement> materials;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * Many actions relating to items require you to expend materials: - Activating a
 * talent node - Inserting a plug into a socket The items will refer to material
 * requirements by a materialRequirementsHash in these cases, and this is the
 * definition for those requirements in terms of the item required, how much of it
 * is required and other interesting info. This is one of the rare/strange times
 * where a single contract class is used both in definitions *and* in live data
 * response contracts. I'm not sure yet whether I regret that.
 */
class DestinyMaterialRequirement {
  /**
   * The hash identifier of the material required. Use it to look up the material's
   * DestinyInventoryItemDefinition.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int itemHash;
  /**
   * If True, the material will be removed from the character's inventory when the
   * action is performed.
   */
  bool deleteOnAction;
  /** The amount of the material required. */
  int count;
  /**
   * If True, this requirement is "silent": don't bother showing it in a material
   * requirements display. I mean, I'm not your mom: I'm not going to tell you you *
   * can't* show it. But we won't show it in our UI.
   */
  bool omitFromRequirements;
}

/**
 * An Unlock Value is an internal integer value, stored on the server and used in a
 * variety of ways, most frequently for the gating/requirement checks that the game
 * performs across all of its main features. They can also be used as the storage
 * data for mapped Progressions, Objectives, and other features that require
 * storage of variable numeric values.
 */
class DestinyUnlockValueDefinition {
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinyCollectibleStateBlock {
  /** Mapped to DestinyInventoryItemDefinition in the manifest. */
  int obscuredOverrideItemHash;
  DestinyPresentationNodeRequirementsBlock requirements;
}

/**
 * Presentation nodes can be restricted by various requirements. This defines the
 * rules of those requirements, and the message(s) to be shown if these
 * requirements aren't met.
 */
class DestinyPresentationNodeRequirementsBlock {
  /**
   * If this node is not accessible due to Entitlements (for instance, you don't own
   * the required game expansion), this is the message to show.
   */
  String entitlementUnavailableMessage;
}

class DestinyPresentationChildBlock {
  DestinyPresentationNodeType presentationNodeType;
  /** Mapped to DestinyPresentationNodeDefinition in the manifest. */
  List<int> parentPresentationNodeHashes;
  DestinyPresentationDisplayStyle displayStyle;
}

class DestinyPresentationNodeType {
   static const int Default = 0;
   static const int Category = 1;
   static const int Collectibles = 2;
   static const int Records = 3;
}

/**
 * A PresentationNode is an entity that represents a logical grouping of other
 * entities visually/organizationally.
 *
 * For now, Presentation Nodes may contain the following... but it may be used for
 * more in the future:
 *
 * - Collectibles - Records (Or, as the public will call them, "Triumphs." Don't
 * ask me why we're overloading the term "Triumph", it still hurts me to think
 * about it) - Other Presentation Nodes, allowing a tree of Presentation Nodes to
 * be created
 *
 * Part of me wants to break these into conceptual definitions per entity being
 * collected, but the possibility of these different types being mixed in the same
 * UI and the possibility that it could actually be more useful to return the "bare
 * metal" presentation node concept has resulted in me deciding against that for
 * the time being.
 *
 * We'll see if I come to regret this as well.
 */
class DestinyPresentationNodeDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /** The original icon for this presentation node, before we futzed with it. */
  String originalIcon;
  /**
   * Some presentation nodes are meant to be explicitly shown on the "root" or "entry"
   * screens for the feature to which they are related. You should use this icon
   * when showing them on such a view, if you have a similar "entry point" view in
   * your UI. If you don't have a UI, then I guess it doesn't matter either way does
   * it?
   */
  String rootViewIcon;
  DestinyPresentationNodeType nodeType;
  /**
   * Indicates whether this presentation node's state is determined on a per-
   * character or on an account-wide basis.
   */
  int scope;
  /**
   * If this presentation node shows a related objective (for instance, if it tracks
   * the progress of its children), the objective being tracked is indicated here.
   *
   * Mapped to DestinyObjectiveDefinition in the manifest.
   */
  int objectiveHash;
  /**
   * If this presentation node has an associated "Record" that you can accomplish for
   * completing its children, this is the identifier of that Record.
   *
   * Mapped to DestinyRecordDefinition in the manifest.
   */
  int completionRecordHash;
  /** The child entities contained by this presentation node. */
  int children;
  /** A hint for how to display this presentation node when it's shown in a list. */
  int displayStyle;
  /**
   * A hint for how to display this presentation node when it's shown in its own
   * detail screen.
   */
  int screenStyle;
  /**
   * The requirements for being able to interact with this presentation node and its
   * children.
   */
  int requirements;
  /**
   * If this presentation node has children, but the game doesn't let you inspect the
   * details of those children, that is indicated here.
   */
  bool disableChildSubscreenNavigation;
  /**
   * A quick reference to presentation nodes that have this node as a child. (
   * presentation nodes can be parented under multiple parents)
   *
   * Mapped to DestinyPresentationNodeDefinition in the manifest.
   */
  List<int> parentNodeHashes;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * Defines an "Objective".
 *
 * An objective is a specific task you should accomplish in the game. These are
 * referred to by:
 *
 * - Quest Steps (which are DestinyInventoryItemDefinition entities with Objectives)
 *
 * - Challenges (which are Objectives defined on an DestinyActivityDefintion)
 *
 * - Milestones (which refer to Objectives that are defined on both Quest Steps and
 * Activities)
 *
 * - Anything else that the designers decide to do later.
 *
 * Objectives have progress, a notion of having been Completed, human readable data
 * describing the task to be accomplished, and a lot of optional tack-on data that
 * can enhance the information provided about the task.
 */
class DestinyObjectiveDefinition {
  /**
   * Ideally, this should tell you what your task is. I'm not going to lie to you
   * though. Sometimes this doesn't have useful information at all. Which sucks, but
   * there's nothing either of us can do about it.
   */
  int displayProperties;
  /**
   * The value that the unlock value defined in unlockValueHash must reach in order
   * for the objective to be considered Completed. Used in calculating progress and
   * completion status.
   */
  int completionValue;
  /**
   * A shortcut for determining the most restrictive gating that this Objective is
   * set to use. This includes both the dynamic determination of progress and of
   * completion values. See the DestinyGatingScope enum's documentation for more
   * details.
   */
  int scope;
  /**
   * OPTIONAL: a hash identifier for the location at which this objective must be
   * accomplished, if there is a location defined. Look up the
   * DestinyLocationDefinition for this hash for that additional location info.
   *
   * Mapped to DestinyLocationDefinition in the manifest.
   */
  int locationHash;
  /** If true, the value is allowed to go negative. */
  bool allowNegativeValue;
  /**
   * If true, you can effectively "un-complete" this objective if you lose progress
   * after crossing the completion threshold.
   *
   * If False, once you complete the task it will remain completed forever by locking
   * the value.
   */
  bool allowValueChangeWhenCompleted;
  /**
   * If true, completion means having an unlock value less than or equal to the
   * completionValue.
   *
   * If False, completion means having an unlock value greater than or equal to the
   * completionValue.
   */
  bool isCountingDownward;
  /**
   * The UI style applied to the objective. It's an enum, take a look at
   * DestinyUnlockValueUIStyle for details of the possible styles. Use this info as
   * you wish to customize your UI.
   */
  int valueStyle;
  /** Text to describe the progress bar. */
  String progressDescription;
  /**
   * If this objective enables Perks intrinsically, the conditions for that enabling
   * are defined here.
   */
  int perks;
  /**
   * If this objective enables modifications on a player's stats intrinsically, the
   * conditions are defined here.
   */
  int stats;
  /**
   * If nonzero, this is the minimum value at which the objective's progression
   * should be shown. Otherwise, don't show it yet.
   */
  int minimumVisibilityThreshold;
  /**
   * If True, the progress will continue even beyond the point where the objective
   * met its minimum completion requirements. Your UI will have to accommodate it.
   */
  bool allowOvercompletion;
  /**
   * If True, you should continue showing the progression value in the UI after it's
   * complete. I mean, we already do that in BNet anyways, but if you want to be
   * better behaved than us you could honor this flag.
   */
  bool showValueOnComplete;
  /** The style to use when the objective is completed. */
  int completedValueStyle;
  /** The style to use when the objective is still in progress. */
  int inProgressValueStyle;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinyGatingScope {
   static const int None = 0;
   static const int Global = 1;
   static const int Clan = 2;
   static const int Profile = 3;
   static const int Character = 4;
   static const int Item = 5;
   static const int AssumedWorstCase = 6;
}

/**
 * A "Location" is a sort of shortcut for referring to a specific combination of
 * Activity, Destination, Place, and even Bubble or NavPoint within a space.
 *
 * Most of this data isn't intrinsically useful to us, but Objectives refer to
 * locations, and through that we can at least infer the Activity, Destination, and
 * Place being referred to by the Objective.
 */
class DestinyLocationDefinition {
  /**
   * If the location has a Vendor on it, this is the hash identifier for that Vendor.
   * Look them up with DestinyVendorDefinition.
   *
   * Mapped to DestinyVendorDefinition in the manifest.
   */
  int vendorHash;
  /**
   * A Location may refer to different specific spots in the world based on the world'
   * s current state. This is a list of those potential spots, and the data we can
   * use at runtime to determine which one of the spots is the currently valid one.
   */
  List<DestinyLocationReleaseDefinition> locationReleases;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * These are the definitions for Vendors.
 *
 * In Destiny, a Vendor can be a lot of things - some things that you wouldn't
 * expect, and some things that you don't even see directly in the game. Vendors
 * are the Dolly Levi of the Destiny universe.
 *
 * - Traditional Vendors as you see in game: people who you come up to and who give
 * you quests, rewards, or who you can buy things from.
 *
 * - Kiosks/Collections, which are really just Vendors that don't charge currency (
 * or charge some pittance of a currency) and whose gating for purchases revolves
 * more around your character's state.
 *
 * - Previews for rewards or the contents of sacks. These are implemented as
 * Vendors, where you can't actually purchase from them but the items that they
 * have for sale and the categories of sale items reflect the rewards or contents
 * of the sack. This is so that the game could reuse the existing Vendor display UI
 * for rewards and save a bunch of wheel reinvention.
 *
 * - Item Transfer capabilities, like the Vault and Postmaster. Vendors can have "
 * acceptedItem" buckets that determine the source and destination buckets for
 * transfers. When you interact with such a vendor, these buckets are what gets
 * shown in the UI instead of any items that the Vendor would have for sale. Yep,
 * the Vault is a vendor.
 *
 * It is pretty much guaranteed that they'll be used for even more features in the
 * future. They have come to be seen more as generic categorized containers for
 * items than "vendors" in a traditional sense, for better or worse.
 *
 * Where possible and time allows, we'll attempt to split those out into their own
 * more digestible derived "Definitions": but often time does not allow that, as
 * you can see from the above ways that vendors are used which we never split off
 * from Vendor Definitions externally.
 *
 * Since Vendors are so many things to so many parts of the game, the definition is
 * understandably complex. You will want to combine this data with live Vendor
 * information from the API when it is available.
 */
class DestinyVendorDefinition {
  DestinyVendorDisplayPropertiesDefinition displayProperties;
  /**
   * If the vendor has a custom localized string describing the "buy" action, that is
   * returned here.
   */
  String buyString;
  /**
   * Ditto for selling. Not that you can sell items to a vendor anymore. Will it come
   * back? Who knows. The string's still there.
   */
  String sellString;
  /**
   * If the vendor has an item that should be displayed as the "featured" item, this
   * is the hash identifier for that DestinyVendorItemDefinition.
   *
   * Apparently this is usually a related currency, like a reputation token. But it
   * need not be restricted to that.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int displayItemHash;
  /** If this is true, you aren't allowed to buy whatever the vendor is selling. */
  bool inhibitBuying;
  /** If this is true, you're not allowed to sell whatever the vendor is buying. */
  bool inhibitSelling;
  /**
   * If the Vendor has a faction, this hash will be valid and point to a
   * DestinyFactionDefinition.
   *
   * The game UI and BNet often mine the faction definition for additional elements
   * and details to place on the screen, such as the faction's Progression status (
   * aka "Reputation").
   *
   * Mapped to DestinyFactionDefinition in the manifest.
   */
  int factionHash;
  /**
   * A number used for calculating the frequency of a vendor's inventory resetting/
   * refreshing.
   *
   * Don't worry about calculating this - we do it on the server side and send you
   * the next refresh date with the live data.
   */
  int resetIntervalMinutes;
  /**
   * Again, used for reset/refreshing of inventory. Don't worry too much about it.
   * Unless you want to.
   */
  int resetOffsetMinutes;
  /**
   * If an item can't be purchased from the vendor, there may be many "custom"/game
   * state specific reasons why not.
   *
   * This is a list of localized strings with messages for those custom failures. The
   * live BNet data will return a failureIndexes property for items that can't be
   * purchased: using those values to index into this array, you can show the user
   * the appropriate failure message for the item that can't be bought.
   */
  List<String> failureStrings;
  /**
   * If we were able to predict the dates when this Vendor will be visible/available,
   * this will be the list of those date ranges. Sadly, we're not able to predict
   * this very frequently, so this will often be useless data.
   */
  List<DateRange> unlockRanges;
  /**
   * The internal identifier for the Vendor. A holdover from the old days of Vendors,
   * but we don't have time to refactor it away.
   */
  String vendorIdentifier;
  /** A portrait of the Vendor's smiling mug. Or frothing tentacles. */
  String vendorPortrait;
  /** If the vendor has a custom banner image, that can be found here. */
  String vendorBanner;
  /**
   * If a vendor is not enabled, we won't even save the vendor's definition, and we
   * won't return any items or info about them. It's as if they don't exist.
   */
  bool enabled;
  /**
   * If a vendor is not visible, we still have and will give vendor definition info,
   * but we won't use them for things like Advisors or UI.
   */
  bool visible;
  /** The identifier of the VendorCategoryDefinition for this vendor's subcategory. */
  String vendorSubcategoryIdentifier;
  /**
   * If TRUE, consolidate categories that only differ by trivial properties (such as
   * having minor differences in name)
   */
  bool consolidateCategories;
  /**
   * Describes "actions" that can be performed on a vendor. Currently, none of these
   * exist. But theoretically a Vendor could let you interact with it by performing
   * actions. We'll see what these end up looking like if they ever get used.
   */
  List<DestinyVendorActionDefinition> actions;
  /**
   * These are the headers for sections of items that the vendor is selling. When you
   * see items organized by category in the header, it is these categories that it is
   * showing.
   *
   * Well, technically not *exactly* these. On BNet, it doesn't make sense to have
   * categories be "paged" as we do in Destiny, so we run some heuristics to attempt
   * to aggregate pages of categories together.
   *
   * These are the categories post-concatenation, if the vendor had concatenation
   * applied. If you want the pre-aggregated category data, use originalCategories.
   */
  List<DestinyVendorCategoryEntryDefinition> categories;
  /**
   * See the categories property for a description of categories and why
   * originalCategories exists.
   */
  List<DestinyVendorCategoryEntryDefinition> originalCategories;
  /**
   * Display Categories are different from "categories" in that these are
   * specifically for visual grouping and display of categories in Vendor UI.
   *
   * The "categories" structure is for validation of the contained items, and can be
   * categorized entirely separately from "Display Categories", there need be and
   * often will be no meaningful relationship between the two.
   */
  List<DestinyDisplayCategoryDefinition> displayCategories;
  /**
   * In addition to selling items, vendors can have "interactions": UI where you "
   * talk" with the vendor and they offer you a reward, some item, or merely
   * acknowledge via dialog that you did something cool.
   */
  List<DestinyVendorInteractionDefinition> interactions;
  /**
   * If the vendor shows you items from your own inventory - such as the Vault vendor
   * does - this data describes the UI around showing those inventory buckets and
   * which ones get shown.
   */
  List<DestinyVendorInventoryFlyoutDefinition> inventoryFlyouts;
  /**
   * If the vendor sells items (or merely has a list of items to show like the "Sack"
   * vendors do), this is the list of those items that the vendor can sell. From this
   * list, only a subset will be available from the vendor at any given time,
   * selected randomly and reset on the vendor's refresh interval.
   *
   * Note that a vendor can sell the same item multiple ways: for instance, nothing
   * stops a vendor from selling you some specific weapon but using two different
   * currencies, or the same weapon at multiple "item levels".
   */
  List<DestinyVendorItemDefinition> itemList;
  /**
   * BNet doesn't use this data yet, but it appears to be an optional list of flavor
   * text about services that the Vendor can provide.
   */
  List<DestinyVendorServiceDefinition> services;
  /**
   * If the Vendor is actually a vehicle for the transferring of items (like the
   * Vault and Postmaster vendors), this defines the list of source->destination
   * buckets for transferring.
   */
  List<DestinyVendorAcceptedItemDefinition> acceptedItems;
  /**
   * As many of you know, Vendor data has historically been pretty brutal on the BNet
   * servers. In an effort to reduce this workload, only Vendors with this flag set
   * will be returned on Vendor requests. This allows us to filter out Vendors that
   * don't dynamic data that's particularly useful: things like "Preview/Sack"
   * vendors, for example, that you can usually suss out the details for using just
   * the definitions themselves.
   */
  bool returnWithVendorRequest;
  /**
   * A vendor can be at different places in the world depending on the game/character/
   * account state. This is the list of possible locations for the vendor, along with
   * conditions we use to determine which one is currently active.
   */
  List<DestinyVendorLocationDefinition> locations;
  /**
   * A vendor can be a part of 0 or 1 "groups" at a time: a group being a collection
   * of Vendors related by either location or function/purpose. It's used for our our
   * Companion Vendor UI. Only one of these can be active for a Vendor at a time.
   */
  List<DestinyVendorGroupReference> groups;
  /**
   * Some items don't make sense to return in the API, for example because they
   * represent an action to be performed rather than an item being sold. I'd rather
   * we not do this, but at least in the short term this is a workable workaround.
   */
  List<int> ignoreSaleItemHashes;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinyVendorDisplayPropertiesDefinition {
  /**
   * I regret calling this a "large icon". It's more like a medium-sized image with a
   * picture of the vendor's mug on it, trying their best to look cool. Not what one
   * would call an icon.
   */
  String largeIcon;
  String subtitle;
  /**
   * If we replaced the icon with something more glitzy, this is the original icon
   * that the vendor had according to the game's content. It may be more lame and/or
   * have less razzle-dazzle. But who am I to tell you which icon to use.
   */
  String originalIcon;
  /**
   * Vendors, in addition to expected display property data, may also show some "
   * common requirements" as statically defined definition data. This might be when a
   * vendor accepts a single type of currency, or when the currency is unique to the
   * vendor and the designers wanted to show that currency when you interact with the
   * vendor.
   */
  List<DestinyVendorRequirementDisplayEntryDefinition> requirementsDisplay;
  /** This is the icon used in parts of the game UI such as the vendor's waypoint. */
  String smallTransparentIcon;
  /** This is the icon used in the map overview, when the vendor is located on the map. */
  String mapIcon;
  /**
   * This is apparently the "Watermark". I am not certain offhand where this is
   * actually used in the Game UI, but some people may find it useful.
   */
  String largeTransparentIcon;
  String description;
  String name;
  /**
   * Note that "icon" is sometimes misleading, and should be interpreted in the
   * context of the entity. For instance, in Destiny 1 the
   * DestinyRecordBookDefinition's icon was a big picture of a book.
   *
   * But usually, it will be a small square image that you can use as... well, an
   * icon.
   */
  String icon;
  bool hasIcon;
}

/**
 * The localized properties of the requirementsDisplay, allowing information about
 * the requirement or item being featured to be seen.
 */
class DestinyVendorRequirementDisplayEntryDefinition {
  String icon;
  String name;
  String source;
  String type;
}

/**
 * These definitions represent Factions in the game. Factions have ended up
 * unilaterally being related to Vendors that represent them, but that need not
 * necessarily be the case.
 *
 * A Faction is really just an entity that has a related progression for which a
 * character can gain experience. In Destiny 1, Dead Orbit was an example of a
 * Faction: there happens to be a Vendor that represents Dead Orbit (and indeed,
 * DestinyVendorDefinition.factionHash defines to this relationship), but Dead
 * Orbit could theoretically exist without the Vendor that provides rewards.
 */
class DestinyFactionDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * The hash identifier for the DestinyProgressionDefinition that indicates the
   * character's relationship with this faction in terms of experience and levels.
   *
   * Mapped to DestinyProgressionDefinition in the manifest.
   */
  int progressionHash;
  /** The faction token item hashes, and their respective progression values. */
  Map<int, int> tokenValues;
  /**
   * The faction reward item hash, usually an engram.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int rewardItemHash;
  /**
   * The faction reward vendor hash, used for faction engram previews.
   *
   * Mapped to DestinyVendorDefinition in the manifest.
   */
  int rewardVendorHash;
  /**
   * List of vendors that are associated with this faction. The last vendor that
   * passes the unlock flag checks is the one that should be shown.
   */
  List<DestinyFactionVendorDefinition> vendors;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * These definitions represent faction vendors at different points in the game.
 *
 * A single faction may contain multiple vendors, or the same vendor available at
 * two different locations.
 */
class DestinyFactionVendorDefinition {
  /**
   * The faction vendor hash.
   *
   * Mapped to DestinyVendorDefinition in the manifest.
   */
  int vendorHash;
  /**
   * The hash identifier for a Destination at which this vendor may be located. Each
   * destination where a Vendor may exist will only ever have a single entry.
   *
   * Mapped to DestinyDestinationDefinition in the manifest.
   */
  int destinationHash;
  /**
   * The relative path to the background image representing this Vendor at this
   * location, for use in a banner.
   */
  String backgroundImagePath;
}

/**
 * On to one of the more confusing subjects of the API. What is a Destination, and
 * what is the relationship between it, Activities, Locations, and Places?
 *
 * A "Destination" is a specific region/city/area of a larger "Place". For instance,
 * a Place might be Earth where a Destination might be Bellevue, Washington. (
 * Please, pick a more interesting destination if you come to visit Earth).
 */
class DestinyDestinationDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * The place that "owns" this Destination. Use this hash to look up the
   * DestinyPlaceDefinition.
   *
   * Mapped to DestinyPlaceDefinition in the manifest.
   */
  int placeHash;
  /**
   * If this Destination has a default Free-Roam activity, this is the hash for that
   * Activity. Use it to look up the DestinyActivityDefintion.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int defaultFreeroamActivityHash;
  /**
   * If the Destination has default Activity Graphs (i.e. "Map") that should be shown
   * in the director, this is the list of those Graphs. At most, only one should be
   * active at any given time for a Destination: these would represent, for example,
   * different variants on a Map if the Destination is changing on a macro level
   * based on game state.
   */
  List<DestinyActivityGraphListEntryDefinition> activityGraphEntries;
  /**
   * A Destination may have many "Bubbles" zones with human readable properties.
   *
   * We don't get as much info as I'd like about them - I'd love to return info like
   * where on the map they are located - but at least this gives you the name of
   * those bubbles. bubbleSettings and bubbles both have the identical number of
   * entries, and you should match up their indexes to provide matching bubble and
   * bubbleSettings data.
   *
   * DEPRECATED - Just use bubbles, it now has this data.
   */
  List<DestinyDestinationBubbleSettingDefinition> bubbleSettings;
  /**
   * This provides the unique identifiers for every bubble in the destination (only
   * guaranteed unique within the destination), and any intrinsic properties of the
   * bubble.
   *
   * bubbleSettings and bubbles both have the identical number of entries, and you
   * should match up their indexes to provide matching bubble and bubbleSettings data.
   */
  List<DestinyBubbleDefinition> bubbles;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * Okay, so Activities (DestinyActivityDefinition) take place in Destinations (
 * DestinyDestinationDefinition). Destinations are part of larger locations known
 * as Places (you're reading its documentation right now).
 *
 * Places are more on the planetary scale, like "Earth" and "Your Mom."
 */
class DestinyPlaceDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * The static data about Activities in Destiny 2.
 *
 * Note that an Activity must be combined with an ActivityMode to know - from a
 * Gameplay perspective - what the user is "Playing".
 *
 * In most PvE activities, this is fairly straightforward. A Story Activity can
 * only be played in the Story Activity Mode.
 *
 * However, in PvP activities, the Activity alone only tells you the map being
 * played, or the Playlist that the user chose to enter. You'll need to know the
 * Activity Mode they're playing to know that they're playing Mode X on Map Y.
 *
 * Activity Definitions tell a great deal of information about what *could* be
 * relevant to a user: what rewards they can earn, what challenges could be
 * performed, what modifiers could be applied. To figure out which of these
 * properties is actually live, you'll need to combine the definition with "Live"
 * data from one of the Destiny endpoints.
 *
 * Activities also have Activity Types, but unfortunately in Destiny 2 these are
 * even less reliable of a source of information than they were in Destiny 1. I
 * will be looking into ways to provide more reliable sources for type information
 * as time goes on, but for now we're going to have to deal with the limitations.
 * See DestinyActivityTypeDefinition for more information.
 */
class DestinyActivityDefinition {
  /**
   * The title, subtitle, and icon for the activity. We do a little post-processing
   * on this to try and account for Activities where the designers have left this
   * data too minimal to determine what activity is actually being played.
   */
  int displayProperties;
  /**
   * The unadulterated form of the display properties, as they ought to be shown in
   * the Director (if the activity appears in the director).
   */
  int originalDisplayProperties;
  /**
   * The title, subtitle, and icon for the activity as determined by Selection Screen
   * data, if there is any for this activity. There won't be data in this field if
   * the activity is never shown in a selection/options screen.
   */
  int selectionScreenDisplayProperties;
  /**
   * If the activity has an icon associated with a specific release (such as a DLC),
   * this is the path to that release's icon.
   */
  String releaseIcon;
  /**
   * If the activity will not be visible until a specific and known time, this will
   * be the seconds since the Epoch when it will become visible.
   */
  int releaseTime;
  /** The difficulty level of the activity. */
  int activityLevel;
  /** The recommended light level for this activity. */
  int activityLightLevel;
  /**
   * The hash identifier for the Destination on which this Activity is played. Use it
   * to look up the DestinyDestinationDefinition for human readable info about the
   * destination. A Destination can be thought of as a more specific location than a "
   * Place". For instance, if the "Place" is Earth, the "Destination" would be a
   * specific city or region on Earth.
   *
   * Mapped to DestinyDestinationDefinition in the manifest.
   */
  int destinationHash;
  /**
   * The hash identifier for the "Place" on which this Activity is played. Use it to
   * look up the DestinyPlaceDefinition for human readable info about the Place. A
   * Place is the largest-scoped concept for location information. For instance, if
   * the "Place" is Earth, the "Destination" would be a specific city or region on
   * Earth.
   *
   * Mapped to DestinyPlaceDefinition in the manifest.
   */
  int placeHash;
  /**
   * The hash identifier for the Activity Type of this Activity. You may use it to
   * look up the DestinyActivityTypeDefinition for human readable info, but be
   * forewarned: Playlists and many PVP Map Activities will map to generic Activity
   * Types. You'll have to use your knowledge of the Activity Mode being played to
   * get more specific information about what the user is playing.
   *
   * Mapped to DestinyActivityTypeDefinition in the manifest.
   */
  int activityTypeHash;
  /** The difficulty tier of the activity. */
  int tier;
  /**
   * When Activities are completed, we generate a "Post-Game Carnage Report", or PGCR,
   * with details about what happened in that activity (how many kills someone got,
   * which team won, etc...) We use this image as the background when displaying PGCR
   * information, and often use it when we refer to the Activity in general.
   */
  String pgcrImage;
  /**
   * The expected possible rewards for the activity. These rewards may or may not be
   * accessible for an individual player based on their character state, the account
   * state, and even the game's state overall. But it is a useful reference for
   * possible rewards you can earn in the activity. These match up to rewards
   * displayed when you hover over the Activity in the in-game Director, and often
   * refer to Placeholder or "Dummy" items: items that tell you what you can earn in
   * vague terms rather than what you'll specifically be earning (partly because the
   * game doesn't even know what you'll earn specifically until you roll for it at
   * the end)
   */
  List<DestinyActivityRewardDefinition> rewards;
  /**
   * Activities can have Modifiers, as defined in DestinyActivityModifierDefinition.
   * These are references to the modifiers that *can* be applied to that activity,
   * along with data that we use to determine if that modifier is actually active at
   * any given point in time.
   */
  List<DestinyActivityModifierReferenceDefinition> modifiers;
  /**
   * If True, this Activity is actually a Playlist that refers to multiple possible
   * specific Activities and Activity Modes. For instance, a Crucible Playlist may
   * have references to multiple Activities (Maps) with multiple Activity Modes (
   * specific PvP gameplay modes). If this is true, refer to the playlistItems
   * property for the specific entries in the playlist.
   */
  bool isPlaylist;
  /**
   * An activity can have many Challenges, of which any subset of them may be active
   * for play at any given period of time. This gives the information about the
   * challenges and data that we use to understand when they're active and what
   * rewards they provide. Sadly, at the moment there's no central definition for
   * challenges: much like "Skulls" were in Destiny 1, these are defined on
   * individual activities and there can be many duplicates/near duplicates across
   * the Destiny 2 ecosystem. I have it in mind to centralize these in a future
   * revision of the API, but we are out of time.
   */
  List<DestinyActivityChallengeDefinition> challenges;
  /**
   * If there are status strings related to the activity and based on internal state
   * of the game, account, or character, then this will be the definition of those
   * strings and the states needed in order for the strings to be shown.
   */
  List<DestinyActivityUnlockStringDefinition> optionalUnlockStrings;
  /**
   * Represents all of the possible activities that could be played in the Playlist,
   * along with information that we can use to determine if they are active at the
   * present time.
   */
  List<DestinyActivityPlaylistItemDefinition> playlistItems;
  /**
   * Unfortunately, in practice this is almost never populated. In theory, this is
   * supposed to tell which Activity Graph to show if you bring up the director while
   * in this activity.
   */
  List<DestinyActivityGraphListEntryDefinition> activityGraphList;
  /**
   * This block of data provides information about the Activity's matchmaking
   * attributes: how many people can join and such.
   */
  int matchmaking;
  /**
   * This block of data, if it exists, provides information about the guided game
   * experience and restrictions for this activity. If it doesn't exist, the game is
   * not able to be played as a guided game.
   */
  int guidedGame;
  /**
   * If this activity had an activity mode directly defined on it, this will be the
   * hash of that mode.
   *
   * Mapped to DestinyActivityModeDefinition in the manifest.
   */
  int directActivityModeHash;
  /**
   * If the activity had an activity mode directly defined on it, this will be the
   * enum value of that mode.
   */
  int directActivityModeType;
  /**
   * The set of all possible loadout requirements that could be active for this
   * activity. Only one will be active at any given time, and you can discover which
   * one through activity-associated data such as Milestones that have activity info
   * on them.
   */
  List<DestinyActivityLoadoutRequirementSet> loadouts;
  /**
   * The hash identifiers for Activity Modes relevant to this activity.  Note that if
   * this is a playlist, the specific playlist entry chosen will determine the actual
   * activity modes that end up being relevant.
   *
   * Mapped to DestinyActivityModeDefinition in the manifest.
   */
  List<int> activityModeHashes;
  /**
   * The activity modes - if any - in enum form. Because we can't seem to escape the
   * enums.
   */
  List<DestinyActivityModeType> activityModeTypes;
  /** If true, this activity is a PVP activity or playlist. */
  bool isPvP;
  /**
   * The list of phases or points of entry into an activity, along with information
   * we can use to determine their gating and availability.
   */
  List<DestinyActivityInsertionPointDefinition> insertionPoints;
  /**
   * A list of location mappings that are affected by this activity. Pulled out of
   * DestinyLocationDefinitions for our/your lookup convenience.
   */
  List<DestinyEnvironmentLocationMapping> activityLocationMappings;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * The definition for an Activity Type.
 *
 * In Destiny 2, an Activity Type represents a conceptual categorization of
 * Activities.
 *
 * These are most commonly used in the game for the subtitle under Activities, but
 * BNet uses them extensively to identify and group activities by their common
 * properties.
 *
 * Unfortunately, there has been a movement away from providing the richer data in
 * Destiny 2 that we used to get in Destiny 1 for Activity Types. For instance,
 * Nightfalls are grouped under the same Activity Type as regular Strikes.
 *
 * For this reason, BNet will eventually migrate toward Activity Modes as a better
 * indicator of activity category. But for the time being, it is still referred to
 * in many places across our codebase.
 */
class DestinyActivityTypeDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * Activities can refer to one or more sets of tooltip-friendly reward data. These
 * are the definitions for those tooltip friendly rewards.
 */
class DestinyActivityRewardDefinition {
  /** The header for the reward set, if any. */
  String rewardText;
  /**
   * The "Items provided" in the reward. This is almost always a pointer to a
   * DestinyInventoryItemDefintion for an item that you can't actually earn in-game,
   * but that has name/description/icon information for the vague concept of the
   * rewards you will receive. This is because the actual reward generation is non-
   * deterministic and extremely complicated, so the best the game can do is tell you
   * what you'll get in vague terms. And so too shall we.
   *
   * Interesting trivia: you actually *do* earn these items when you complete the
   * activity. They go into a single-slot bucket on your profile, which is how you
   * see the pop-ups of these rewards when you complete an activity that match these "
   * dummy" items. You can even see them if you look at the last one you earned in
   * your profile-level inventory through the BNet API! Who said reading
   * documentation is a waste of time?
   */
  List<DestinyItemQuantity> rewardItems;
}

/**
 * A reference to an Activity Modifier from another entity, such as an Activity (
 * for now, just Activities).
 *
 * This defines some
 */
class DestinyActivityModifierReferenceDefinition {
  /**
   * The hash identifier for the DestinyActivityModifierDefinition referenced by this
   * activity.
   *
   * Mapped to DestinyActivityModifierDefinition in the manifest.
   */
  int activityModifierHash;
}

/**
 * Modifiers - in Destiny 1, these were referred to as "Skulls" - are changes that
 * can be applied to an Activity.
 */
class DestinyActivityModifierDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/** Represents a reference to a Challenge, which for now is just an Objective. */
class DestinyActivityChallengeDefinition {
  /**
   * The hash for the Objective that matches this challenge. Use it to look up the
   * DestinyObjectiveDefinition.
   *
   * Mapped to DestinyObjectiveDefinition in the manifest.
   */
  int objectiveHash;
  /**
   * The rewards as they're represented in the UI. Note that they generally link to "
   * dummy" items that give a summary of rewards rather than direct, real items
   * themselves.
   *
   * If the quantity is 0, don't show the quantity.
   */
  List<DestinyItemQuantity> dummyRewards;
}

/**
 * Represents a status string that could be conditionally displayed about an
 * activity. Note that externally, you can only see the strings themselves.
 * Internally we combine this information with server state to determine which
 * strings should be shown.
 */
class DestinyActivityUnlockStringDefinition {
  /** The string to be displayed if the conditions are met. */
  String displayString;
}

/**
 * If the activity is a playlist, this is the definition for a specific entry in
 * the playlist: a single possible combination of Activity and Activity Mode that
 * can be chosen.
 */
class DestinyActivityPlaylistItemDefinition {
  /**
   * The hash identifier of the Activity that can be played. Use it to look up the
   * DestinyActivityDefinition.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int activityHash;
  /**
   * If this playlist entry had an activity mode directly defined on it, this will be
   * the hash of that mode.
   *
   * Mapped to DestinyActivityModeDefinition in the manifest.
   */
  int directActivityModeHash;
  /**
   * If the playlist entry had an activity mode directly defined on it, this will be
   * the enum value of that mode.
   */
  int directActivityModeType;
  /**
   * The hash identifiers for Activity Modes relevant to this entry.
   *
   * Mapped to DestinyActivityModeDefinition in the manifest.
   */
  List<int> activityModeHashes;
  /**
   * The activity modes - if any - in enum form. Because we can't seem to escape the
   * enums.
   */
  List<DestinyActivityModeType> activityModeTypes;
}

/**
 * This definition represents an "Activity Mode" as it exists in the Historical
 * Stats endpoints. An individual Activity Mode represents a collection of
 * activities that are played in a certain way. For example, Nightfall Strikes are
 * part of a "Nightfall" activity mode, and any activities played as the PVP mode "
 * Clash" are part of the "Clash activity mode.
 *
 * Activity modes are nested under each other in a hierarchy, so that if you ask
 * for - for example - "AllPvP", you will get any PVP activities that the user has
 * played, regardless of what specific PVP mode was being played.
 */
class DestinyActivityModeDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * If this activity mode has a related PGCR image, this will be the path to said
   * image.
   */
  String pgcrImage;
  /**
   * The Enumeration value for this Activity Mode. Pass this identifier into Stats
   * endpoints to get aggregate stats for this mode.
   */
  int modeType;
  /** The type of play being performed in broad terms (PVP, PVE) */
  int activityModeCategory;
  /**
   * If True, this mode has oppositional teams fighting against each other rather
   * than "Free-For-All" or Co-operative modes of play.
   *
   * Note that Aggregate modes are never marked as team based, even if they happen to
   * be team based at the moment. At any time, an aggregate whose subordinates are
   * only team based could be changed so that one or more aren't team based, and then
   * this boolean won't make much sense (the aggregation would become "sometimes team
   * based"). Let's not deal with that right now.
   */
  bool isTeamBased;
  /**
   * If true, this mode is an aggregation of other, more specific modes rather than
   * being a mode in itself. This includes modes that group Features/Events rather
   * than Gameplay, such as Trials of The Nine: Trials of the Nine being an Event
   * that is interesting to see aggregate data for, but when you play the activities
   * within Trials of the Nine they are more specific activity modes such as Clash.
   */
  bool isAggregateMode;
  /**
   * The hash identifiers of the DestinyActivityModeDefinitions that represent all of
   * the "parent" modes for this mode. For instance, the Nightfall Mode is also a
   * member of AllStrikes and AllPvE.
   */
  List<int> parentHashes;
  /**
   * A Friendly identifier you can use for referring to this Activity Mode. We really
   * only used this in our URLs, so... you know, take that for whatever it's worth.
   */
  String friendlyName;
  /**
   * If this exists, the mode has specific Activities (referred to by the Key) that
   * should instead map to other Activity Modes when they are played. This was useful
   * in D1 for Private Matches, where we wanted to have Private Matches as an
   * activity mode while still referring to the specific mode being played.
   */
  Map<int, DestinyActivityModeType> activityModeMappings;
  /**
   * If FALSE, we want to ignore this type when we're showing activity modes in BNet
   * UI. It will still be returned in case 3rd parties want to use it for any purpose.
   */
  bool display;
  /** The relative ordering of activity modes. */
  int order;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinyActivityModeType {
   static const int None = 0;
   static const int Story = 2;
   static const int Strike = 3;
   static const int Raid = 4;
   static const int AllPvP = 5;
   static const int Patrol = 6;
   static const int AllPvE = 7;
   static const int Reserved9 = 9;
   static const int Control = 10;
   static const int Reserved11 = 11;
  /**
   * Clash -> Destiny's name for Team Deathmatch. 4v4 combat, the team with the
   * highest kills at the end of time wins.
   */
   static const int Clash = 12;
   static const int Reserved13 = 13;
   static const int CrimsonDoubles = 15;
   static const int Nightfall = 16;
   static const int HeroicNightfall = 17;
   static const int AllStrikes = 18;
   static const int IronBanner = 19;
   static const int Reserved20 = 20;
   static const int Reserved21 = 21;
   static const int Reserved22 = 22;
   static const int Reserved24 = 24;
   static const int AllMayhem = 25;
   static const int Reserved26 = 26;
   static const int Reserved27 = 27;
   static const int Reserved28 = 28;
   static const int Reserved29 = 29;
   static const int Reserved30 = 30;
   static const int Supremacy = 31;
   static const int PrivateMatchesAll = 32;
   static const int Survival = 37;
   static const int Countdown = 38;
   static const int TrialsOfTheNine = 39;
   static const int Social = 40;
   static const int TrialsCountdown = 41;
   static const int TrialsSurvival = 42;
   static const int IronBannerControl = 43;
   static const int IronBannerClash = 44;
   static const int IronBannerSupremacy = 45;
   static const int ScoredNightfall = 46;
   static const int ScoredHeroicNightfall = 47;
   static const int Rumble = 48;
   static const int AllDoubles = 49;
   static const int Doubles = 50;
   static const int PrivateMatchesClash = 51;
   static const int PrivateMatchesControl = 52;
   static const int PrivateMatchesSupremacy = 53;
   static const int PrivateMatchesCountdown = 54;
   static const int PrivateMatchesSurvival = 55;
   static const int PrivateMatchesMayhem = 56;
   static const int PrivateMatchesRumble = 57;
   static const int HeroicAdventure = 58;
   static const int Showdown = 59;
   static const int Lockdown = 60;
   static const int Scorched = 61;
   static const int ScorchedTeam = 62;
   static const int Gambit = 63;
   static const int AllPvECompetitive = 64;
   static const int Breakthrough = 65;
}

class DestinyActivityModeCategory {
  /** Activities that are neither PVP nor PVE, such as social activities. */
   static const int None = 0;
  /** PvE activities, where you shoot aliens in the face. */
   static const int PvE = 1;
  /** PvP activities, where you teabag other humans in the face. */
   static const int PvP = 2;
  /** PVE competitive activities. */
   static const int PvECompetitive = 3;
}

/**
 * Destinations and Activities may have default Activity Graphs that should be
 * shown when you bring up the Director and are playing in either.
 *
 * This contract defines the graph referred to and the gating for when it is
 * relevant.
 */
class DestinyActivityGraphListEntryDefinition {
  /**
   * The hash identifier of the DestinyActivityGraphDefinition that should be shown
   * when opening the director.
   *
   * Mapped to DestinyActivityGraphDefinition in the manifest.
   */
  int activityGraphHash;
}

/**
 * Represents a Map View in the director: be them overview views, destination views,
 * or other.
 *
 * They have nodes which map to activities, and other various visual elements that
 * we (or others) may or may not be able to use.
 *
 * Activity graphs, most importantly, have nodes which can have activities in
 * various states of playability.
 *
 * Unfortunately, activity graphs are combined at runtime with Game UI-only assets
 * such as fragments of map images, various in-game special effects, decals etc...
 * that we don't get in these definitions.
 *
 * If we end up having time, we may end up trying to manually populate those here:
 * but the last time we tried that, before the lead-up to D1, it proved to be
 * unmaintainable as the game's content changed. So don't bet the farm on us
 * providing that content in this definition.
 */
class DestinyActivityGraphDefinition {
  /**
   * These represent the visual "nodes" on the map's view. These are the activities
   * you can click on in the map.
   */
  List<DestinyActivityGraphNodeDefinition> nodes;
  /** Represents one-off/special UI elements that appear on the map. */
  List<DestinyActivityGraphArtElementDefinition> artElements;
  /**
   * Represents connections between graph nodes. However, it lacks context that we'd
   * need to make good use of it.
   */
  List<DestinyActivityGraphConnectionDefinition> connections;
  /**
   * Objectives can display on maps, and this is supposedly metadata for that. I have
   * not had the time to analyze the details of what is useful within however: we
   * could be missing important data to make this work. Expect this property to be
   * expanded on later if possible.
   */
  List<DestinyActivityGraphDisplayObjectiveDefinition> displayObjectives;
  /**
   * Progressions can also display on maps, but similarly to displayObjectives we
   * appear to lack some required information and context right now. We will have to
   * look into it later and add more data if possible.
   */
  List<DestinyActivityGraphDisplayProgressionDefinition> displayProgressions;
  /** Represents links between this Activity Graph and other ones. */
  List<DestinyLinkedGraphDefinition> linkedGraphs;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * This is the position and other data related to nodes in the activity graph that
 * you can click to launch activities. An Activity Graph node will only have one
 * active Activity at a time, which will determine the activity to be launched (and,
 * unless overrideDisplay information is provided, will also determine the tooltip
 * and other UI related to the node)
 */
class DestinyActivityGraphNodeDefinition {
  /**
   * An identifier for the Activity Graph Node, only guaranteed to be unique within
   * its parent Activity Graph.
   */
  int nodeId;
  /**
   * The node *may* have display properties that override the active Activity's
   * display properties.
   */
  int overrideDisplay;
  /** The position on the map for this node. */
  int position;
  /**
   * The node may have various visual accents placed on it, or styles applied. These
   * are the list of possible styles that the Node can have. The game iterates
   * through each, looking for the first one that passes a check of the required game/
   * character/account state in order to show that style, and then renders the node
   * in that style.
   */
  List<DestinyActivityGraphNodeFeaturingStateDefinition> featuringStates;
  /**
   * The node may have various possible activities that could be active for it,
   * however only one may be active at a time. See the
   * DestinyActivityGraphNodeActivityDefinition for details.
   */
  List<DestinyActivityGraphNodeActivityDefinition> activities;
  /**
   * Represents possible states that the graph node can be in. These are combined
   * with some checking that happens in the game client and server to determine which
   * state is actually active at any given time.
   */
  List<DestinyActivityGraphNodeStateEntry> states;
}

class DestinyPositionDefinition {
  int x;
  int y;
  int z;
}

/**
 * Nodes can have different visual states. This object represents a single visual
 * state ("highlight type") that a node can be in, and the unlock expression
 * condition to determine whether it should be set.
 */
class DestinyActivityGraphNodeFeaturingStateDefinition {
  /**
   * The node can be highlighted in a variety of ways - the game iterates through
   * these and finds the first FeaturingState that is valid at the present moment
   * given the Game, Account, and Character state, and renders the node in that state.
   * See the ActivityGraphNodeHighlightType enum for possible values.
   */
  int highlightType;
}

class ActivityGraphNodeHighlightType {
   static const int None = 0;
   static const int Normal = 1;
   static const int Hyper = 2;
   static const int Comet = 3;
   static const int RiseOfIron = 4;
}

/**
 * The actual activity to be redirected to when you click on the node. Note that a
 * node can have many Activities attached to it: but only one will be active at any
 * given time. The list of Node Activities will be traversed, and the first one
 * found to be active will be displayed. This way, a node can layer multiple
 * variants of an activity on top of each other. For instance, one node can control
 * the weekly Crucible Playlist. There are multiple possible playlists, but only
 * one is active for the week.
 */
class DestinyActivityGraphNodeActivityDefinition {
  /**
   * An identifier for this node activity. It is only guaranteed to be unique within
   * the Activity Graph.
   */
  int nodeActivityId;
  /**
   * The activity that will be activated if the user clicks on this node. Controls
   * all activity-related information displayed on the node if it is active (the text
   * shown in the tooltip etc)
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int activityHash;
}

/**
 * Represents a single state that a graph node might end up in. Depending on what's
 * going on in the game, graph nodes could be shown in different ways or even
 * excluded from view entirely.
 */
class DestinyActivityGraphNodeStateEntry {
  DestinyGraphNodeState state;
}

class DestinyGraphNodeState {
   static const int Hidden = 0;
   static const int Visible = 1;
   static const int Teaser = 2;
   static const int Incomplete = 3;
   static const int Completed = 4;
}

/**
 * These Art Elements are meant to represent one-off visual effects overlaid on the
 * map. Currently, we do not have a pipeline to import the assets for these
 * overlays, so this info exists as a placeholder for when such a pipeline exists (
 * if it ever will)
 */
class DestinyActivityGraphArtElementDefinition {
  /** The position on the map of the art element. */
  int position;
}

/**
 * Nodes on a graph can be visually connected: this appears to be the information
 * about which nodes to link. It appears to lack more detailed information, such as
 * the path for that linking.
 */
class DestinyActivityGraphConnectionDefinition {
  int sourceNodeHash;
  int destNodeHash;
}

/**
 * When a Graph needs to show active Objectives, this defines those objectives as
 * well as an identifier.
 */
class DestinyActivityGraphDisplayObjectiveDefinition {
  /**
   * $NOTE $amola 2017-01-19 This field is apparently something that CUI uses to
   * manually wire up objectives to display info. I am unsure how it works.
   */
  int id;
  /**
   * The objective being shown on the map.
   *
   * Mapped to DestinyObjectiveDefinition in the manifest.
   */
  int objectiveHash;
}

/**
 * When a Graph needs to show active Progressions, this defines those objectives as
 * well as an identifier.
 */
class DestinyActivityGraphDisplayProgressionDefinition {
  int id;
  int progressionHash;
}

/**
 * This describes links between the current graph and others, as well as when that
 * link is relevant.
 */
class DestinyLinkedGraphDefinition {
  String description;
  String name;
  DestinyUnlockExpressionDefinition unlockExpression;
  int linkedGraphId;
  List<DestinyLinkedGraphEntryDefinition> linkedGraphs;
  String overview;
}

/**
 * Where the sausage gets made. Unlock Expressions are the foundation of the game's
 * gating mechanics and investment-related restrictions. They can test Unlock Flags
 * and Unlock Values for certain states, using a sufficient amount of logical
 * operators such that unlock expressions are effectively Turing complete.
 *
 * Use UnlockExpressionParser to evaluate expressions using an IUnlockContext
 * parsed from Babel.
 */
class DestinyUnlockExpressionDefinition {
  /**
   * A shortcut for determining the most restrictive gating that this expression
   * performs. See the DestinyGatingScope enum's documentation for more details.
   */
  int scope;
}

class DestinyLinkedGraphEntryDefinition {
  int activityGraphHash;
}

/** Information about matchmaking and party size for the activity. */
class DestinyActivityMatchmakingBlockDefinition {
  /**
   * If TRUE, the activity is matchmade. Otherwise, it requires explicit forming of a
   * party.
   */
  bool isMatchmade;
  /** The minimum # of people in the fireteam for the activity to launch. */
  int minParty;
  /** The maximum # of people allowed in a Fireteam. */
  int maxParty;
  /** The maximum # of people allowed across all teams in the activity. */
  int maxPlayers;
  /** If true, you have to Solemnly Swear to be up to Nothing But Good(tm) to play. */
  bool requiresGuardianOath;
}

/** Guided Game information for this activity. */
class DestinyActivityGuidedBlockDefinition {
  /** The maximum amount of people that can be in the waiting lobby. */
  int guidedMaxLobbySize;
  /** The minimum amount of people that can be in the waiting lobby. */
  int guidedMinLobbySize;
  /**
   * If -1, the guided group cannot be disbanded. Otherwise, take the total # of
   * players in the activity and subtract this number: that is the total # of votes
   * needed for the guided group to disband.
   */
  int guidedDisbandCount;
}

class DestinyActivityLoadoutRequirementSet {
  /**
   * The set of requirements that will be applied on the activity if this requirement
   * set is active.
   */
  List<DestinyActivityLoadoutRequirement> requirements;
}

class DestinyActivityLoadoutRequirement {
  /** Mapped to DestinyEquipmentSlotDefinition in the manifest. */
  int equipmentSlotHash;
  /** Mapped to DestinyInventoryItemDefinition in the manifest. */
  List<int> allowedEquippedItemHashes;
  List<DestinyItemSubType> allowedWeaponSubTypes;
}

/**
 * Characters can not only have Inventory buckets (containers of items that are
 * generally matched by their type or functionality), they can also have Equipment
 * Slots.
 *
 * The Equipment Slot is an indicator that the related bucket can have instanced
 * items equipped on the character. For instance, the Primary Weapon bucket has an
 * Equipment Slot that determines whether you can equip primary weapons, and holds
 * the association between its slot and the inventory bucket from which it can have
 * items equipped.
 *
 * An Equipment Slot must have a related Inventory Bucket, but not all inventory
 * buckets must have Equipment Slots.
 */
class DestinyEquipmentSlotDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * These technically point to "Equipment Category Definitions". But don't get
   * excited. There's nothing of significant value in those definitions, so I didn't
   * bother to expose them. You can use the hash here to group equipment slots by
   * common functionality, which serves the same purpose as if we had the Equipment
   * Category definitions exposed.
   */
  int equipmentCategoryHash;
  /**
   * The inventory bucket that owns this equipment slot.
   *
   * Mapped to DestinyInventoryBucketDefinition in the manifest.
   */
  int bucketTypeHash;
  /**
   * If True, equipped items should have their custom art dyes applied when rendering
   * the item. Otherwise, custom art dyes on an item should be ignored if the item is
   * equipped in this slot.
   */
  bool applyCustomArtDyes;
  /** The Art Dye Channels that apply to this equipment slot. */
  List<DestinyArtDyeReference> artDyeChannels;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * An Inventory (be it Character or Profile level) is comprised of many Buckets. An
 * example of a bucket is "Primary Weapons", where all of the primary weapons on a
 * character are gathered together into a single visual element in the UI: a subset
 * of the inventory that has a limited number of slots, and in this case also has
 * an associated Equipment Slot for equipping an item in the bucket.
 *
 * Item definitions declare what their "default" bucket is (
 * DestinyInventoryItemDefinition.inventory.bucketTypeHash), and Item instances
 * will tell you which bucket they are currently residing in (DestinyItemComponent.
 * bucketHash). You can use this information along with the
 * DestinyInventoryBucketDefinition to show these items grouped by bucket.
 *
 * You cannot transfer an item to a bucket that is not its Default without going
 * through a Vendor's "accepted items" (DestinyVendorDefinition.acceptedItems).
 * This is how transfer functionality like the Vault is implemented, as a feature
 * of a Vendor. See the vendor's acceptedItems property for more details.
 */
class DestinyInventoryBucketDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /** Where the bucket is found. 0 = Character, 1 = Account */
  int scope;
  /**
   * An enum value for what items can be found in the bucket. See the BucketCategory
   * enum for more details.
   */
  int category;
  /**
   * Use this property to provide a quick-and-dirty recommended ordering for buckets
   * in the UI. Most UIs will likely want to forsake this for something more custom
   * and manual.
   */
  int bucketOrder;
  /**
   * The maximum # of item "slots" in a bucket. A slot is a given combination of item
   * + quantity.
   *
   * For instance, a Weapon will always take up a single slot, and always have a
   * quantity of 1. But a material could take up only a single slot with hundreds of
   * quantity.
   */
  int itemCount;
  /**
   * Sometimes, inventory buckets represent conceptual "locations" in the game that
   * might not be expected. This value indicates the conceptual location of the
   * bucket, regardless of where it is actually contained on the character/account.
   *
   * See ItemLocation for details.
   *
   * Note that location includes the Vault and the Postmaster (both of whom being
   * just inventory buckets with additional actions that can be performed on them
   * through a Vendor)
   */
  int location;
  /**
   * If TRUE, there is at least one Vendor that can transfer items to/from this
   * bucket. See the DestinyVendorDefinition's acceptedItems property for more
   * information on how transferring works.
   */
  bool hasTransferDestination;
  /**
   * If True, this bucket is enabled. Disabled buckets may include buckets that were
   * included for test purposes, or that were going to be used but then were
   * abandoned but never removed from content *cough*.
   */
  bool enabled;
  /**
   * if a FIFO bucket fills up, it will delete the oldest item from said bucket when
   * a new item tries to be added to it. If this is FALSE, the bucket will not allow
   * new items to be placed in it until room is made by the user manually deleting
   * items from it. You can see an example of this with the Postmaster's bucket.
   */
  bool fifo;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class BucketScope {
   static const int Character = 0;
   static const int Account = 1;
}

class BucketCategory {
   static const int Invisible = 0;
   static const int Item = 1;
   static const int Currency = 2;
   static const int Equippable = 3;
   static const int Ignored = 4;
}

class ItemLocation {
   static const int Unknown = 0;
   static const int Inventory = 1;
   static const int Vault = 2;
   static const int Vendor = 3;
   static const int Postmaster = 4;
}

class DestinyArtDyeReference {
  int artDyeChannelHash;
}

class DestinyItemSubType {
   static const int None = 0;
  /** DEPRECATED. Items can be both "Crucible" and something else interesting. */
   static const int Crucible = 1;
  /** DEPRECATED. An item can both be "Vanguard" and something else. */
   static const int Vanguard = 2;
  /** DEPRECATED. An item can both be Exotic and something else. */
   static const int Exotic = 5;
   static const int AutoRifle = 6;
   static const int Shotgun = 7;
   static const int Machinegun = 8;
   static const int HandCannon = 9;
   static const int RocketLauncher = 10;
   static const int FusionRifle = 11;
   static const int SniperRifle = 12;
   static const int PulseRifle = 13;
   static const int ScoutRifle = 14;
  /** DEPRECATED. An item can both be CRM and something else. */
   static const int Crm = 16;
   static const int Sidearm = 17;
   static const int Sword = 18;
   static const int Mask = 19;
   static const int Shader = 20;
   static const int Ornament = 21;
   static const int FusionRifleLine = 22;
   static const int GrenadeLauncher = 23;
   static const int SubmachineGun = 24;
   static const int TraceRifle = 25;
   static const int HelmetArmor = 26;
   static const int GauntletsArmor = 27;
   static const int ChestArmor = 28;
   static const int LegArmor = 29;
   static const int ClassArmor = 30;
   static const int Bow = 31;
}

/**
 * A point of entry into an activity, gated by an unlock flag and with some more-or-
 * less useless (for our purposes) phase information. I'm including it in case we
 * end up being able to bolt more useful information onto it in the future.
 *
 * UPDATE: Turns out this information isn't actually useless, and is in fact
 * actually useful for people. Who would have thought? We still don't have
 * localized info for it, but at least this will help people when they're looking
 * at phase indexes in stats data, or when they want to know what phases have been
 * completed on a weekly achievement.
 */
class DestinyActivityInsertionPointDefinition {
  /**
   * A unique hash value representing the phase. This can be useful for, for example,
   * comparing how different instances of Raids have phases in different orders!
   */
  int phaseHash;
}

class DestinyEnvironmentLocationMapping {
  /**
   * The location that is revealed on the director by this mapping.
   *
   * Mapped to DestinyLocationDefinition in the manifest.
   */
  int locationHash;
  /**
   * A hint that the UI uses to figure out how this location is activated by the
   * player.
   */
  String activationSource;
  /**
   * If this is populated, it is the item that you must possess for this location to
   * be active because of this mapping. (theoretically, a location can have multiple
   * mappings, and some might require an item while others don't)
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int itemHash;
  /**
   * If this is populated, this is an objective related to the location.
   *
   * Mapped to DestinyObjectiveDefinition in the manifest.
   */
  int objectiveHash;
  /**
   * If this is populated, this is the activity you have to be playing in order to
   * see this location appear because of this mapping. (theoretically, a location can
   * have multiple mappings, and some might require you to be in a specific activity
   * when others don't)
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int activityHash;
}

/**
 * Human readable data about the bubble. Combine with DestinyBubbleDefinition - see
 * DestinyDestinationDefinition.bubbleSettings for more information.
 *
 * DEPRECATED - Just use bubbles.
 */
class DestinyDestinationBubbleSettingDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
}

/**
 * Basic identifying data about the bubble. Combine with
 * DestinyDestinationBubbleSettingDefinition - see DestinyDestinationDefinition.
 * bubbleSettings for more information.
 */
class DestinyBubbleDefinition {
  /**
   * The identifier for the bubble: only guaranteed to be unique within the
   * Destination.
   */
  int hash;
  /**
   * The display properties of this bubble, so you don't have to look them up in a
   * separate list anymore.
   */
  int displayProperties;
}

/**
 * If a vendor can ever end up performing actions, these are the properties that
 * will be related to those actions. I'm not going to bother documenting this yet,
 * as it is unused and unclear if it will ever be used... but in case it is ever
 * populated and someone finds it useful, it is defined here.
 */
class DestinyVendorActionDefinition {
  String description;
  int executeSeconds;
  String icon;
  String name;
  String verb;
  bool isPositive;
  String actionId;
  int actionHash;
  bool autoPerformAction;
}

/**
 * This is the definition for a single Vendor Category, into which Sale Items are
 * grouped.
 */
class DestinyVendorCategoryEntryDefinition {
  /** The index of the category in the original category definitions for the vendor. */
  int categoryIndex;
  /** The string identifier of the category. */
  String categoryId;
  /**
   * Used in sorting items in vendors... but there's a lot more to it. Just go with
   * the order provided in the itemIndexes property on the
   * DestinyVendorCategoryComponent instead, it should be more reliable than trying
   * to recalculate it yourself.
   */
  int sortValue;
  /** The hashed identifier for the category. */
  int categoryHash;
  /** The amount of items that will be available when this category is shown. */
  int quantityAvailable;
  /**
   * If items aren't up for sale in this category, should we still show them (greyed
   * out)?
   */
  bool showUnavailableItems;
  /**
   * If you don't have the currency required to buy items from this category, should
   * the items be hidden?
   */
  bool hideIfNoCurrency;
  /** True if this category doesn't allow purchases. */
  bool hideFromRegularPurchase;
  /**
   * The localized string for making purchases from this category, if it is different
   * from the vendor's string for purchasing.
   */
  String buyStringOverride;
  /** If the category is disabled, this is the localized description to show. */
  String disabledDescription;
  /** The localized title of the category. */
  String displayTitle;
  /**
   * If this category has an overlay prompt that should appear, this contains the
   * details of that prompt.
   */
  int overlay;
  /**
   * A shortcut for the vendor item indexes sold under this category. Saves us from
   * some expensive reorganization at runtime.
   */
  List<int> vendorItemIndexes;
  /**
   * Sometimes a category isn't actually used to sell items, but rather to preview
   * them. This implies different UI (and manual placement of the category in the UI)
   * in the game, and special treatment.
   */
  bool isPreview;
  /** If true, this category only displays items: you can't purchase anything in them. */
  bool isDisplayOnly;
  int resetIntervalMinutesOverride;
  int resetOffsetMinutesOverride;
}

/**
 * The details of an overlay prompt to show to a user. They are all fairly self-
 * explanatory localized strings that can be shown.
 */
class DestinyVendorCategoryOverlayDefinition {
  String choiceDescription;
  String description;
  String icon;
  String title;
  /** If this overlay has a currency item that it features, this is said featured item. */
  int currencyItemHash;
}

/**
 * Display Categories are different from "categories" in that these are
 * specifically for visual grouping and display of categories in Vendor UI. The "
 * categories" structure is for validation of the contained items, and can be
 * categorized entirely separately from "Display Categories", there need be and
 * often will be no meaningful relationship between the two.
 */
class DestinyDisplayCategoryDefinition {
  /** A string identifier for the display category. */
  String identifier;
  int displayCategoryHash;
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * If true, this category should be displayed in the "Banner" section of the vendor'
   * s UI.
   */
  bool displayInBanner;
  /**
   * If it exists, this is the hash identifier of a DestinyProgressionDefinition that
   * represents the progression to show on this display category.
   *
   * Specific categories can now have thier own distinct progression, apparently. So
   * that's cool.
   *
   * Mapped to DestinyProgressionDefinition in the manifest.
   */
  int progressionHash;
  /** If this category sorts items in a nonstandard way, this will be the way we sort. */
  int sortOrder;
  /**
   * An indicator of how the category will be displayed in the UI. It's up to you to
   * do something cool or interesting in response to this, or just to treat it as a
   * normal category.
   */
  int displayStyleHash;
  /**
   * An indicator of how the category will be displayed in the UI. It's up to you to
   * do something cool or interesting in response to this, or just to treat it as a
   * normal category.
   */
  String displayStyleIdentifier;
}

class VendorDisplayCategorySortOrder {
   static const int Default = 0;
   static const int SortByTier = 1;
}

/**
 * A Vendor Interaction is a dialog shown by the vendor other than sale items or
 * transfer screens. The vendor is showing you something, and asking you to reply
 * to it by choosing an option or reward.
 */
class DestinyVendorInteractionDefinition {
  /**
   * The position of this interaction in its parent array. Note that this is NOT
   * content agnostic, and should not be used as such.
   */
  int interactionIndex;
  /** The potential replies that the user can make to the interaction. */
  List<DestinyVendorInteractionReplyDefinition> replies;
  /**
   * If >= 0, this is the category of sale items to show along with this interaction
   * dialog.
   */
  int vendorCategoryIndex;
  /**
   * If this interaction dialog is about a quest, this is the questline related to
   * the interaction. You can use this to show the quest overview, or even the
   * character's status with the quest if you use it to find the character's current
   * Quest Step by checking their inventory against this questlineItemHash's
   * DestinyInventoryItemDefinition.setData.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int questlineItemHash;
  /**
   * If this interaction is meant to show you sacks, this is the list of types of
   * sacks to be shown. If empty, the interaction is not meant to show sacks.
   */
  List<DestinyVendorInteractionSackEntryDefinition> sackInteractionList;
  /**
   * A UI hint for the behavior of the interaction screen. This is useful to
   * determine what type of interaction is occurring, such as a prompt to receive a
   * rank up reward or a prompt to choose a reward for completing a quest. The hash
   * isn't as useful as the Enum in retrospect, well what can you do. Try using
   * interactionType instead.
   */
  int uiInteractionType;
  /**
   * The enumerated version of the possible UI hints for vendor interactions, which
   * is a little easier to grok than the hash found in uiInteractionType.
   */
  int interactionType;
  /**
   * If this interaction is displaying rewards, this is the text to use for the
   * header of the reward-displaying section of the interaction.
   */
  String rewardBlockLabel;
  /**
   * If the vendor's reward list is sourced from one of his categories, this is the
   * index into the category array of items to show.
   */
  int rewardVendorCategoryIndex;
  /** If the vendor interaction has flavor text, this is some of it. */
  String flavorLineOne;
  /** If the vendor interaction has flavor text, this is the rest of it. */
  String flavorLineTwo;
  /** The header for the interaction dialog. */
  int headerDisplayProperties;
  /** The localized text telling the player what to do when they see this dialog. */
  String instructions;
}

/**
 * When the interaction is replied to, Reward sites will fire and items potentially
 * selected based on whether the given unlock expression is TRUE.
 *
 * You can potentially choose one from multiple replies when replying to an
 * interaction: this is how you get either/or rewards from vendors.
 */
class DestinyVendorInteractionReplyDefinition {
  /** The rewards granted upon responding to the vendor. */
  int itemRewardsSelection;
  /** The localized text for the reply. */
  String reply;
  /** An enum indicating the type of reply being made. */
  int replyType;
}

class DestinyVendorInteractionRewardSelection {
   static const int None = 0;
   static const int One = 1;
   static const int All = 2;
}

class DestinyVendorReplyType {
   static const int Accept = 0;
   static const int Decline = 1;
   static const int Complete = 2;
}

/**
 * Compare this sackType to the sack identifier in the
 * DestinyInventoryItemDefinition.vendorSackType property of items. If they match,
 * show this sack with this interaction.
 */
class DestinyVendorInteractionSackEntryDefinition {
  int sackType;
}

class VendorInteractionType {
   static const int Unknown = 0;
  /** An interaction shown when you complete a quest and receive a reward. */
   static const int QuestComplete = 1;
  /**
   * An interaction shown when you talk to a Vendor as an intermediary step of a
   * quest.
   */
   static const int QuestContinue = 2;
  /** An interaction shown when you are previewing the vendor's reputation rewards. */
   static const int ReputationPreview = 3;
  /** An interaction shown when you rank up with the vendor. */
   static const int RankUpReward = 4;
  /** An interaction shown when you have tokens to turn in for the vendor. */
   static const int TokenTurnIn = 5;
  /** An interaction shown when you're accepting a new quest. */
   static const int QuestAccept = 6;
  /**
   * Honestly, this doesn't seem consistent to me. It is used to give you choices in
   * the Cryptarch as well as some reward prompts by the Eververse vendor. I'll have
   * to look into that further at some point.
   */
   static const int ProgressTab = 7;
  /** These seem even less consistent. I don't know what these are. */
   static const int End = 8;
  /** Also seem inconsistent. I also don't know what these are offhand. */
   static const int Start = 9;
}

/**
 * The definition for an "inventory flyout": a UI screen where we show you part of
 * an otherwise hidden vendor inventory: like the Vault inventory buckets.
 */
class DestinyVendorInventoryFlyoutDefinition {
  /** If the flyout is locked, this is the reason why. */
  String lockedDescription;
  /** The title and other common properties of the flyout. */
  int displayProperties;
  /** A list of inventory buckets and other metadata to show on the screen. */
  List<DestinyVendorInventoryFlyoutBucketDefinition> buckets;
  /** An identifier for the flyout, in case anything else needs to refer to them. */
  int flyoutId;
  /**
   * If this is true, don't show any of the glistening "this is a new item" UI
   * elements, like we show on the inventory items themselves in in-game UI.
   */
  bool suppressNewness;
  /**
   * If this flyout is meant to show you the contents of the player's equipment slot,
   * this is the slot to show.
   */
  int equipmentSlotHash;
}

/**
 * Information about a single inventory bucket in a vendor flyout UI and how it is
 * shown.
 */
class DestinyVendorInventoryFlyoutBucketDefinition {
  /** If true, the inventory bucket should be able to be collapsed visually. */
  bool collapsible;
  /**
   * The inventory bucket whose contents should be shown.
   *
   * Mapped to DestinyInventoryBucketDefinition in the manifest.
   */
  int inventoryBucketHash;
  /** The methodology to use for sorting items from the flyout. */
  int sortItemsBy;
}

class DestinyItemSortType {
   static const int ItemId = 0;
   static const int Timestamp = 1;
   static const int StackSize = 2;
}

/** This represents an item being sold by the vendor. */
class DestinyVendorItemDefinition {
  /**
   * The index into the DestinyVendorDefinition.saleList. This is what we use to
   * refer to items being sold throughout live and definition data.
   */
  int vendorItemIndex;
  /**
   * The hash identifier of the item being sold (DestinyInventoryItemDefinition).
   *
   * Note that a vendor can sell the same item in multiple ways, so don't assume that
   * itemHash is a unique identifier for this entity.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int itemHash;
  /**
   * The amount you will recieve of the item described in itemHash if you make the
   * purchase.
   */
  int quantity;
  /**
   * An list of indexes into the DestinyVendorDefinition.failureStrings array,
   * indicating the possible failure strings that can be relevant for this item.
   */
  List<int> failureIndexes;
  /**
   * This is a pre-compiled aggregation of item value and priceOverrideList, so that
   * we have one place to check for what the purchaser must pay for the item. Use
   * this instead of trying to piece together the price separately.
   *
   * The somewhat crappy part about this is that, now that item quantity overrides
   * have dynamic modifiers, this will not necessarily be statically true. If you
   * were using this instead of live data, switch to using live data.
   */
  List<DestinyVendorItemQuantity> currencies;
  /**
   * If this item can be refunded, this is the policy for what will be refundd, how,
   * and in what time period.
   */
  int refundPolicy;
  /** The amount of time before refundability of the newly purchased item will expire. */
  int refundTimeLimit;
  /**
   * The Default level at which the item will spawn. Almost always driven by an
   * adjusto these days. Ideally should be singular. It's a long story how this ended
   * up as a list, but there is always either going to be 0:1 of these entities.
   */
  List<DestinyItemCreationEntryLevelDefinition> creationLevels;
  /**
   * This is an index specifically into the display category, as opposed to the
   * server-side Categories (which do not need to match or pair with each other in
   * any way: server side categories are really just structures for common validation.
   * Display Category will let us more easily categorize items visually)
   */
  int displayCategoryIndex;
  /**
   * The index into the DestinyVendorDefinition.categories array, so you can find the
   * category associated with this item.
   */
  int categoryIndex;
  /** Same as above, but for the original category indexes. */
  int originalCategoryIndex;
  /** The minimum character level at which this item is available for sale. */
  int minimumLevel;
  /** The maximum character level at which this item is available for sale. */
  int maximumLevel;
  /** The action to be performed when purchasing the item, if it's not just "buy". */
  int action;
  /** The string identifier for the category selling this item. */
  String displayCategory;
  /** The inventory bucket into which this item will be placed upon purchase. */
  int inventoryBucketHash;
  /**
   * The most restrictive scope that determines whether the item is available in the
   * Vendor's inventory. See DestinyGatingScope's documentation for more information.
   *
   * This can be determined by Unlock gating, or by whether or not the item has
   * purchase level requirements (minimumLevel and maximumLevel properties).
   */
  int visibilityScope;
  /**
   * Similar to visibilityScope, it represents the most restrictive scope that
   * determines whether the item can be purchased. It will at least be as restrictive
   * as visibilityScope, but could be more restrictive if the item has additional
   * purchase requirements beyond whether it is merely visible or not.
   *
   * See DestinyGatingScope's documentation for more information.
   */
  int purchasableScope;
  /**
   * If this item can only be purchased by a given platform, this indicates the
   * platform to which it is restricted.
   */
  int exclusivity;
  /** If this sale can only be performed as the result of an offer check, this is true. */
  bool isOffer;
  /**
   * If this sale can only be performed as the result of receiving a CRM offer, this
   * is true.
   */
  bool isCrm;
  /**
   * *if* the category this item is in supports non-default sorting, this value
   * should represent the sorting value to use, pre-processed and ready to go.
   */
  int sortValue;
  /**
   * If this item can expire, this is the tooltip message to show with its expiration
   * info.
   */
  String expirationTooltip;
  /**
   * If this is populated, the purchase of this item should redirect to purchasing
   * these other items instead.
   */
  List<int> redirectToSaleIndexes;
  List<DestinyVendorItemSocketOverride> socketOverrides;
}

/**
 * In addition to item quantity information for vendor prices, this also has any
 * optional information that may exist about how the item's quantity can be
 * modified. (unfortunately not information that is able to be read outside of the
 * BNet servers, but it's there)
 */
class DestinyVendorItemQuantity {
  /**
   * The hash identifier for the item in question. Use it to look up the item's
   * DestinyInventoryItemDefinition.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int itemHash;
  /**
   * If this quantity is referring to a specific instance of an item, this will have
   * the item's instance ID. Normally, this will be null.
   */
  String itemInstanceId;
  /**
   * The amount of the item needed/available depending on the context of where
   * DestinyItemQuantity is being used.
   */
  int quantity;
}

class DestinyVendorItemRefundPolicy {
   static const int NotRefundable = 0;
   static const int DeletesItem = 1;
   static const int RevokesLicense = 2;
}

/** An overly complicated wrapper for the item level at which the item should spawn. */
class DestinyItemCreationEntryLevelDefinition {
  int level;
}

/** Not terribly useful, some basic cooldown interaction info. */
class DestinyVendorSaleItemActionBlockDefinition {
  double executeSeconds;
  bool isPositive;
}

/**
 * The information for how the vendor purchase should override a given socket with
 * custom plug data.
 */
class DestinyVendorItemSocketOverride {
  /**
   * If this is populated, the socket will be overridden with a specific plug.
   *
   * If this isn't populated, it's being overridden by something more complicated
   * that is only known by the Game Server and God, which means we can't tell you in
   * advance what it'll be.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int singleItemHash;
  /**
   * If this is greater than -1, the number of randomized plugs on this socket will
   * be set to this quantity instead of whatever it's set to by default.
   */
  int randomizedOptionsCount;
  /**
   * This appears to be used to select which socket ultimately gets the override
   * defined here.
   *
   * Mapped to DestinySocketTypeDefinition in the manifest.
   */
  int socketTypeHash;
}

/**
 * All Sockets have a "Type": a set of common properties that determine when the
 * socket allows Plugs to be inserted, what Categories of Plugs can be inserted,
 * and whether the socket is even visible at all given the current game/character/
 * account state.
 *
 * See DestinyInventoryItemDefinition for more information about Socketed items and
 * Plugs.
 */
class DestinySocketTypeDefinition {
  /**
   * There are fields for this display data, but they appear to be unpopulated as of
   * now. I am not sure where in the UI these would show if they even were populated,
   * but I will continue to return this data in case it becomes useful.
   */
  int displayProperties;
  /** Defines what happens when a plug is inserted into sockets of this type. */
  int insertAction;
  /**
   * A list of Plug "Categories" that are allowed to be plugged into sockets of this
   * type.
   *
   * These should be compared against a given plug item's
   * DestinyInventoryItemDefinition.plug.plugCategoryHash, which indicates the plug
   * item's category.
   *
   * If the plug's category matches any whitelisted plug, or if the whitelist is
   * empty, it is allowed to be inserted.
   */
  List<DestinyPlugWhitelistEntryDefinition> plugWhitelist;
  /** Mapped to DestinySocketCategoryDefinition in the manifest. */
  int socketCategoryHash;
  /**
   * Sometimes a socket isn't visible. These are some of the conditions under which
   * sockets of this type are not visible. Unfortunately, the truth of visibility is
   * much, much more complex. Best to rely on the live data for whether the socket is
   * visible and enabled.
   */
  int visibility;
  bool alwaysRandomizeSockets;
  bool isPreviewEnabled;
  bool hideDuplicateReusablePlugs;
  /**
   * This property indicates if the socket type determines whether Emblem icons and
   * nameplates should be overridden by the inserted plug item's icon and nameplate.
   */
  bool overridesUiAppearance;
  bool avoidDuplicatesOnInitialization;
  List<DestinySocketTypeScalarMaterialRequirementEntry> currencyScalars;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * Data related to what happens while a plug is being inserted, mostly for UI
 * purposes.
 */
class DestinyInsertPlugActionDefinition {
  /**
   * How long it takes for the Plugging of the item to be completed once it is
   * initiated, if you care.
   */
  int actionExecuteSeconds;
  /**
   * The type of action being performed when you act on this Socket Type. The most
   * common value is "insert plug", but there are others as well (for instance, a "
   * Masterwork" socket may allow for Re-initialization, and an Infusion socket
   * allows for items to be consumed to upgrade the item)
   */
  int actionType;
}

class SocketTypeActionType {
   static const int InsertPlug = 0;
   static const int InfuseItem = 1;
   static const int ReinitializeSocket = 2;
}

/**
 * Defines a plug "Category" that is allowed to be plugged into a socket of this
 * type.
 *
 * This should be compared against a given plug item's
 * DestinyInventoryItemDefinition.plug.plugCategoryHash, which indicates the plug
 * item's category.
 */
class DestinyPlugWhitelistEntryDefinition {
  /**
   * The hash identifier of the Plug Category to compare against the plug item's plug.
   * plugCategoryHash.
   *
   * Note that this does NOT relate to any Definition in itself, it is only used for
   * comparison purposes.
   */
  int categoryHash;
  /** The string identifier for the category, which is here mostly for debug purposes. */
  String categoryIdentifier;
  /**
   * The list of all plug items (DestinyInventoryItemDefinition) that the socket may
   * randomly be populated with when reinitialized.
   *
   * Which ones you should actually show are determined by the plug being inserted
   * into the socket, and the socket’s type.
   *
   * When you inspect the plug that could go into a Masterwork Socket, look up the
   * socket type of the socket being inspected and find the
   * DestinySocketTypeDefinition.
   *
   * Then, look at the Plugs that can fit in that socket. Find the Whitelist in the
   * DestinySocketTypeDefinition that matches the plug item’s categoryhash.
   *
   * That whitelist entry will potentially have a new “
   * reinitializationPossiblePlugHashes” property.If it does, that means we know what
   * it will roll if you try to insert this plug into this socket.
   */
  List<int> reinitializationPossiblePlugHashes;
}

/**
 * Sockets on an item are organized into Categories visually.
 *
 * You can find references to the socket category defined on an item's
 * DestinyInventoryItemDefinition.sockets.socketCategories property.
 *
 * This has the display information for rendering the categories' header, and a
 * hint for how the UI should handle showing this category.
 *
 * The shitty thing about this, however, is that the socket categories' UI style
 * can be overridden by the item's UI style. For instance, the Socket Category used
 * by Emote Sockets says it's "consumable," but that's a lie: they're all reusable,
 * and overridden by the detail UI pages in ways that we can't easily account for
 * in the API.
 *
 * As a result, I will try to compile these rules into the individual sockets on
 * items, and provide the best hint possible there through the plugSources property.
 * In the future, I may attempt to use this information in conjunction with the
 * item to provide a more usable UI hint on the socket layer, but for now improving
 * the consistency of plugSources is the best I have time to provide. (See https://
 * github.com/Bungie-net/api/issues/522 for more info)
 */
class DestinySocketCategoryDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * A string hinting to the game's UI system about how the sockets in this category
   * should be displayed.
   *
   * BNet doesn't use it: it's up to you to find valid values and make your own
   * special UI if you want to honor this category style.
   */
  int uiCategoryStyle;
  /** Same as uiCategoryStyle, but in a more usable enumeration form. */
  int categoryStyle;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinySocketCategoryStyle {
   static const int Unknown = 0;
   static const int Reusable = 1;
   static const int Consumable = 2;
   static const int Unlockable = 3;
   static const int Intrinsic = 4;
}

class DestinySocketVisibility {
   static const int Visible = 0;
   static const int Hidden = 1;
   static const int HiddenWhenEmpty = 2;
   static const int HiddenIfNoPlugsAvailable = 3;
}

class DestinySocketTypeScalarMaterialRequirementEntry {
  int currencyItemHash;
  int scalarValue;
}

/** When a vendor provides services, this is the localized name of those services. */
class DestinyVendorServiceDefinition {
  /** The localized name of a service provided. */
  String name;
}

/**
 * If you ever wondered how the Vault works, here it is.
 *
 * The Vault is merely a set of inventory buckets that exist on your Profile/
 * Account level. When you transfer items in the Vault, the game is using the Vault
 * Vendor's DestinyVendorAcceptedItemDefinitions to see where the appropriate
 * destination bucket is for the source bucket from whence your item is moving. If
 * it finds such an entry, it transfers the item to the other bucket.
 *
 * The mechanics for Postmaster works similarly, which is also a vendor. All driven
 * by Accepted Items.
 */
class DestinyVendorAcceptedItemDefinition {
  /**
   * The "source" bucket for a transfer. When a user wants to transfer an item, the
   * appropriate DestinyVendorDefinition's acceptedItems property is evaluated,
   * looking for an entry where acceptedInventoryBucketHash matches the bucket that
   * the item being transferred is currently located. If it exists, the item will be
   * transferred into whatever bucket is defined by destinationInventoryBucketHash.
   *
   * Mapped to DestinyInventoryBucketDefinition in the manifest.
   */
  int acceptedInventoryBucketHash;
  /**
   * This is the bucket where the item being transferred will be put, given that it
   * was being transferred *from* the bucket defined in acceptedInventoryBucketHash.
   *
   * Mapped to DestinyInventoryBucketDefinition in the manifest.
   */
  int destinationInventoryBucketHash;
}

/**
 * These definitions represent vendors' locations and relevant display information
 * at different times in the game.
 */
class DestinyVendorLocationDefinition {
  /**
   * The hash identifier for a Destination at which this vendor may be located. Each
   * destination where a Vendor may exist will only ever have a single entry.
   *
   * Mapped to DestinyDestinationDefinition in the manifest.
   */
  int destinationHash;
  /**
   * The relative path to the background image representing this Vendor at this
   * location, for use in a banner.
   */
  String backgroundImagePath;
}

class DestinyVendorGroupReference {
  /**
   * The DestinyVendorGroupDefinition to which this Vendor can belong.
   *
   * Mapped to DestinyVendorGroupDefinition in the manifest.
   */
  int vendorGroupHash;
}

/**
 * BNet attempts to group vendors into similar collections. These groups aren't
 * technically game canonical, but they are helpful for filtering vendors or
 * showing them organized into a clean view on a webpage or app.
 *
 * These definitions represent the groups we've built. Unlike in Destiny 1, a
 * Vendors' group may change dynamically as the game state changes: thus, you will
 * want to check DestinyVendorComponent responses to find a vendor's currently
 * active Group (if you care).
 *
 * Using this will let you group your vendors in your UI in a similar manner to how
 * we will do grouping in the Companion.
 */
class DestinyVendorGroupDefinition {
  /** The recommended order in which to render the groups, Ascending order. */
  int order;
  /** For now, a group just has a name. */
  String categoryName;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * A specific "spot" referred to by a location. Only one of these can be active at
 * a time for a given Location.
 */
class DestinyLocationReleaseDefinition {
  /** Sadly, these don't appear to be populated anymore (ever?) */
  int displayProperties;
  String smallTransparentIcon;
  String mapIcon;
  String largeTransparentIcon;
  /**
   * If we had map information, this spawnPoint would be interesting. But sadly, we
   * don't have that info.
   */
  int spawnPoint;
  /**
   * The Destination being pointed to by this location.
   *
   * Mapped to DestinyDestinationDefinition in the manifest.
   */
  int destinationHash;
  /**
   * The Activity being pointed to by this location.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int activityHash;
  /** The Activity Graph being pointed to by this location. */
  int activityGraphHash;
  /**
   * The Activity Graph Node being pointed to by this location. (Remember that
   * Activity Graph Node hashes are only unique within an Activity Graph: so use the
   * combination to find the node being spoken of)
   */
  int activityGraphNodeHash;
  /**
   * The Activity Bubble within the Destination. Look this up in the
   * DestinyDestinationDefinition's bubbles and bubbleSettings properties.
   */
  int activityBubbleName;
  /**
   * If we had map information, this would tell us something cool about the path this
   * location wants you to take. I wish we had map information.
   */
  int activityPathBundle;
  /**
   * If we had map information, this would tell us about path information related to
   * destination on the map. Sad. Maybe you can do something cool with it. Go to town
   * man.
   */
  int activityPathDestination;
  /** The type of Nav Point that this represents. See the enumeration for more info. */
  int navPointType;
  /**
   * Looks like it should be the position on the map, but sadly it does not look
   * populated... yet?
   */
  List<int> worldPosition;
}

class DestinyActivityNavPointType {
   static const int Inactive = 0;
   static const int PrimaryObjective = 1;
   static const int SecondaryObjective = 2;
   static const int TravelObjective = 3;
   static const int PublicEventObjective = 4;
   static const int AmmoCache = 5;
   static const int PointTypeFlag = 6;
   static const int CapturePoint = 7;
   static const int DefensiveEncounter = 8;
   static const int GhostInteraction = 9;
   static const int KillAi = 10;
   static const int QuestItem = 11;
   static const int PatrolMission = 12;
   static const int Incoming = 13;
   static const int ArenaObjective = 14;
   static const int AutomationHint = 15;
   static const int TrackedQuest = 16;
}

class DestinyUnlockValueUIStyle {
  /** Generally, Automatic means "Just show the number" */
   static const int Automatic = 0;
  /**
   * Show the number as a fractional value. For this to make sense, the value being
   * displayed should have a comparable upper bound, like the progress to the next
   * level of a Progression.
   */
   static const int Fraction = 1;
  /**
   * Show the number as a checkbox. 0 Will mean unchecked, any other value will mean
   * checked.
   */
   static const int Checkbox = 2;
  /**
   * Show the number as a percentage. For this to make sense, the value being
   * displayed should have a comparable upper bound, like the progress to the next
   * level of a Progression.
   */
   static const int Percentage = 3;
  /**
   * Show the number as a date and time. The number will be the number of seconds
   * since the Unix Epoch (January 1st, 1970 at midnight UTC). It'll be up to you to
   * convert this into a date and time format understandable to the user in their
   * time zone.
   */
   static const int DateTime = 4;
  /**
   * Show the number as a floating point value that represents a fraction, where 0 is
   * min and 1 is max. For this to make sense, the value being displayed should have
   * a comparable upper bound, like the progress to the next level of a Progression.
   */
   static const int FractionFloat = 5;
  /** Show the number as a straight-up integer. */
   static const int Integer = 6;
  /** Show the number as a time duration. The value will be returned as seconds. */
   static const int TimeDuration = 7;
  /**
   * Don't bother showing the value at all, it's not easily human-interpretable, and
   * used for some internal purpose.
   */
   static const int Hidden = 8;
   static const int Multiplier = 9;
}

/**
 * Defines the conditions under which an intrinsic perk is applied while
 * participating in an Objective.
 *
 * These perks will generally not be benefit-granting perks, but rather a perk that
 * modifies gameplay in some interesting way.
 */
class DestinyObjectivePerkEntryDefinition {
  /**
   * The hash identifier of the DestinySandboxPerkDefinition that will be applied to
   * the character.
   *
   * Mapped to DestinySandboxPerkDefinition in the manifest.
   */
  int perkHash;
  /**
   * An enumeration indicating whether it will be applied as long as the Objective is
   * active, when it's completed, or until it's completed.
   */
  int style;
}

/**
 * Perks are modifiers to a character or item that can be applied situationally.
 *
 * - Perks determine a weapons' damage type.
 *
 * - Perks put the Mods in Modifiers (they are literally the entity that bestows
 * the Sandbox benefit for whatever fluff text about the modifier in the Socket,
 * Plug or Talent Node)
 *
 * - Perks are applied for unique alterations of state in Objectives
 *
 * Anyways, I'm sure you can see why perks are so interesting.
 *
 * What Perks often don't have is human readable information, so we attempt to
 * reverse engineer that by pulling that data from places that uniquely refer to
 * these perks: namely, Talent Nodes and Plugs. That only gives us a subset of
 * perks that are human readable, but those perks are the ones people generally
 * care about anyways. The others are left as a mystery, their true purpose mostly
 * unknown and undocumented.
 */
class DestinySandboxPerkDefinition {
  /**
   * These display properties are by no means guaranteed to be populated. Usually
   * when it is, it's only because we back-filled them with the displayProperties of
   * some Talent Node or Plug item that happened to be uniquely providing that perk.
   */
  int displayProperties;
  /** The string identifier for the perk. */
  String perkIdentifier;
  /**
   * If true, you can actually show the perk in the UI. Otherwise, it doesn't have
   * useful player-facing information.
   */
  bool isDisplayable;
  /**
   * If this perk grants a damage type to a weapon, the damage type will be defined
   * here.
   *
   * Unless you have a compelling reason to use this enum value, use the
   * damageTypeHash instead to look up the actual DestinyDamageTypeDefinition.
   */
  int damageType;
  /**
   * The hash identifier for looking up the DestinyDamageTypeDefinition, if this perk
   * has a damage type.
   *
   * This is preferred over using the damageType enumeration value, which has been
   * left purely because it is occasionally convenient.
   */
  int damageTypeHash;
  /**
   * An old holdover from the original Armory, this was an attempt to group perks by
   * functionality.
   *
   * It is as yet unpopulated, and there will be quite a bit of work needed to
   * restore it to its former working order.
   */
  int perkGroups;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DamageType {
   static const int None = 0;
   static const int Kinetic = 1;
   static const int Arc = 2;
   static const int Thermal = 3;
   static const int Void = 4;
   static const int Raid = 5;
}

/**
 * These properties are an attempt to categorize talent node steps by certain
 * common properties. See the related enumerations for the type of properties being
 * categorized.
 */
class DestinyTalentNodeStepGroups {
  DestinyTalentNodeStepWeaponPerformances weaponPerformance;
  DestinyTalentNodeStepImpactEffects impactEffects;
  DestinyTalentNodeStepGuardianAttributes guardianAttributes;
  DestinyTalentNodeStepLightAbilities lightAbilities;
  DestinyTalentNodeStepDamageTypes damageTypes;
}

class DestinyTalentNodeStepWeaponPerformances {
   static const int None = 0;
   static const int RateOfFire = 1;
   static const int Damage = 2;
   static const int Accuracy = 4;
   static const int Range = 8;
   static const int Zoom = 16;
   static const int Recoil = 32;
   static const int Ready = 64;
   static const int Reload = 128;
   static const int HairTrigger = 256;
   static const int AmmoAndMagazine = 512;
   static const int TrackingAndDetonation = 1024;
   static const int ShotgunSpread = 2048;
   static const int ChargeTime = 4096;
   static const int All = 8191;
}

class DestinyTalentNodeStepImpactEffects {
   static const int None = 0;
   static const int ArmorPiercing = 1;
   static const int Ricochet = 2;
   static const int Flinch = 4;
   static const int CollateralDamage = 8;
   static const int Disorient = 16;
   static const int HighlightTarget = 32;
   static const int All = 63;
}

class DestinyTalentNodeStepGuardianAttributes {
   static const int None = 0;
   static const int Stats = 1;
   static const int Shields = 2;
   static const int Health = 4;
   static const int Revive = 8;
   static const int AimUnderFire = 16;
   static const int Radar = 32;
   static const int Invisibility = 64;
   static const int Reputations = 128;
   static const int All = 255;
}

class DestinyTalentNodeStepLightAbilities {
   static const int None = 0;
   static const int Grenades = 1;
   static const int Melee = 2;
   static const int MovementModes = 4;
   static const int Orbs = 8;
   static const int SuperEnergy = 16;
   static const int SuperMods = 32;
   static const int All = 63;
}

class DestinyTalentNodeStepDamageTypes {
   static const int None = 0;
   static const int Kinetic = 1;
   static const int Arc = 2;
   static const int Solar = 4;
   static const int Void = 8;
   static const int All = 15;
}

class DestinyObjectiveGrantStyle {
   static const int WhenIncomplete = 0;
   static const int WhenComplete = 1;
   static const int Always = 2;
}

/**
 * Defines the conditions under which stat modifications will be applied to a
 * Character while participating in an objective.
 */
class DestinyObjectiveStatEntryDefinition {
  /** The stat being modified, and the value used. */
  int stat;
  /**
   * Whether it will be applied as long as the objective is active, when it's
   * completed, or until it's completed.
   */
  int style;
}

/**
 * Represents a "raw" investment stat, before calculated stats are calculated and
 * before any DestinyStatGroupDefinition is applied to transform the stat into
 * something closer to what you see in-game.
 *
 * Because these won't match what you see in-game, consider carefully whether you
 * really want to use these stats. I have left them in case someone can do
 * something useful or interesting with the pre-processed statistics.
 */
class DestinyItemInvestmentStatDefinition {
  /**
   * The hash identifier for the DestinyStatDefinition defining this stat.
   *
   * Mapped to DestinyStatDefinition in the manifest.
   */
  int statTypeHash;
  /**
   * The raw "Investment" value for the stat, before transformations are performed to
   * turn this raw stat into stats that are displayed in the game UI.
   */
  int value;
  /**
   * If this is true, the stat will only be applied on the item in certain game state
   * conditions, and we can't know statically whether or not this stat will be
   * applied. Check the "live" API data instead for whether this value is being
   * applied on a specific instance of the item in question, and you can use this to
   * decide whether you want to show the stat on the generic view of the item, or
   * whether you want to show some kind of caveat or warning about the stat value
   * being conditional on game state.
   */
  bool isConditionallyActive;
}

/**
 * This represents a stat that's applied to a character or an item (such as a
 * weapon, piece of armor, or a vehicle).
 *
 * An example of a stat might be Attack Power on a weapon.
 *
 * Stats go through a complex set of transformations before they end up being shown
 * to the user as a number or a progress bar, and those transformations are
 * fundamentally intertwined with the concept of a "Stat Group" (
 * DestinyStatGroupDefinition). Items have both Stats and a reference to a Stat
 * Group, and it is the Stat Group that takes the raw stat information and gives it
 * both rendering metadata (such as whether to show it as a number or a progress
 * bar) and the final transformation data (interpolation tables to turn the raw
 * investment stat into a display stat). Please see DestinyStatGroupDefinition for
 * more information on that transformational process.
 *
 * Stats are segregated from Stat Groups because different items and types of items
 * can refer to the same stat, but have different "scales" for the stat while still
 * having the same underlying value. For example, both a Shotgun and an Auto Rifle
 * may have a "raw" impact stat of 50, but the Auto Rifle's Stat Group will scale
 * that 50 down so that, when it is displayed, it is a smaller value relative to
 * the shotgun. (this is a totally made up example, don't assume shotguns have
 * naturally higher impact than auto rifles because of this)
 *
 * A final caveat is that some stats, even after this "final" transformation, go
 * through yet another set of transformations directly in the game as a result of
 * dynamic, stateful scripts that get run. BNet has no access to these scripts, nor
 * any way to know which scripts get executed. As a result, the stats for an item
 * that you see in-game - particularly for stats that are often impacted by Perks,
 * like Magazine Size - can change dramatically from what we return on Bungie.Net.
 * This is a known issue with no fix coming down the pipeline. Take these stats
 * with a grain of salt.
 *
 * Stats actually go through four transformations, for those interested:
 *
 * 1) "Sandbox" stat, the "most raw" form. These are pretty much useless without
 * transformations applied, and thus are not currently returned in the API. If you
 * really want these, we can provide them. Maybe someone could do something cool
 * with it?
 *
 * 2) "Investment" stat (the stat's value after DestinyStatDefinition's
 * interpolation tables and aggregation logic is applied to the "Sandbox" stat
 * value)
 *
 * 3) "Display" stat (the stat's base UI-visible value after
 * DestinyStatGroupDefinition's interpolation tables are applied to the Investment
 * Stat value. For most stats, this is what is displayed.)
 *
 * 4) Underlying in-game stat (the stat's actual value according to the game, after
 * the game runs dynamic scripts based on the game and character's state. This is
 * the final transformation that BNet does not have access to. For most stats, this
 * is not actually displayed to the user, with the exception of Magazine Size which
 * is then piped back to the UI for display in-game, but not to BNet.)
 */
class DestinyStatDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * Stats can exist on a character or an item, and they may potentially be
   * aggregated in different ways. The DestinyStatAggregationType enum value
   * indicates the way that this stat is being aggregated.
   */
  int aggregationType;
  /**
   * True if the stat is computed rather than being delivered as a raw value on items.
   *
   * For instance, the Light stat in Destiny 1 was a computed stat.
   */
  bool hasComputedBlock;
  /** The category of the stat, according to the game. */
  int statCategory;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinyStatAggregationType {
   static const int CharacterAverage = 0;
   static const int Character = 1;
   static const int Item = 2;
}

class DestinyStatCategory {
   static const int Gameplay = 0;
   static const int Weapon = 1;
   static const int Defense = 2;
   static const int Primary = 3;
}

class DestinyRecordDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * Indicates whether this Record's state is determined on a per-character or on an
   * account-wide basis.
   */
  int scope;
  DestinyPresentationChildBlock presentationInfo;
  /** Mapped to DestinyLoreDefinition in the manifest. */
  int loreHash;
  /** Mapped to DestinyObjectiveDefinition in the manifest. */
  List<int> objectiveHashes;
  DestinyRecordValueStyle recordValueStyle;
  DestinyRecordTitleBlock titleInfo;
  DestinyRecordCompletionBlock completionInfo;
  SchemaRecordStateBlock stateInfo;
  DestinyPresentationNodeRequirementsBlock requirements;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * These are definitions for in-game "Lore," meant to be narrative enhancements of
 * the game experience.
 *
 * DestinyInventoryItemDefinitions for interesting items point to these definitions,
 * but nothing's stopping you from scraping all of these and doing something cool
 * with them. If they end up having cool data.
 */
class DestinyLoreDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  String subtitle;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinyRecordValueStyle {
   static const int Integer = 0;
   static const int Percentage = 1;
   static const int Milliseconds = 2;
   static const int Boolean = 3;
   static const int Decimal = 4;
}

class DestinyRecordTitleBlock {
  bool hasTitle;
  Map<int, String> titlesByGender;
}

class DestinyRecordCompletionBlock {
  int partialCompletionObjectiveCountThreshold;
  int ScoreValue;
  bool shouldFireToast;
  DestinyRecordToastStyle toastStyle;
}

class DestinyRecordToastStyle {
   static const int None = 0;
   static const int Record = 1;
   static const int Lore = 2;
   static const int Badge = 3;
   static const int MetaRecord = 4;
   static const int MedalComplete = 5;
}

class SchemaRecordStateBlock {
  int featuredPriority;
  String obscuredString;
}

/**
 * As/if presentation nodes begin to host more entities as children, these lists
 * will be added to. One list property exists per type of entity that can be
 * treated as a child of this presentation node, and each holds the identifier of
 * the entity and any associated information needed to display the UI for that
 * entity (if anything)
 */
class DestinyPresentationNodeChildrenBlock {
  List<DestinyPresentationNodeChildEntry> presentationNodes;
  List<DestinyPresentationNodeCollectibleChildEntry> collectibles;
  List<DestinyPresentationNodeRecordChildEntry> records;
}

class DestinyPresentationNodeChildEntry {
  /** Mapped to DestinyPresentationNodeDefinition in the manifest. */
  int presentationNodeHash;
}

class DestinyPresentationNodeCollectibleChildEntry {
  /** Mapped to DestinyCollectibleDefinition in the manifest. */
  int collectibleHash;
}

class DestinyPresentationNodeRecordChildEntry {
  /** Mapped to DestinyRecordDefinition in the manifest. */
  int recordHash;
}

class DestinyPresentationDisplayStyle {
  /** Display the item as a category, through which sub-items are filtered. */
   static const int Category = 0;
   static const int Badge = 1;
   static const int Medals = 2;
   static const int Collectible = 3;
   static const int Record = 4;
}

class DestinyPresentationScreenStyle {
  /** Use the "default" view for the presentation nodes. */
   static const int Default = 0;
  /**
   * Show sub-items as "category sets". In-game, you'd see these as a vertical list
   * of child presentation nodes - armor sets for example - and the icons of items
   * within those sets displayed horizontally.
   */
   static const int CategorySets = 1;
  /**
   * Show sub-items as Badges. (I know, I know. We don't need no stinkin' badges har
   * har har)
   */
   static const int Badge = 2;
}

/**
 * Represents a color whose RGBA values are all represented as values between 0 and
 * 255.
 */
class DestinyColor {
  int red;
  int green;
  int blue;
  int alpha;
}

/**
 * If an item can have an action performed on it (like "Dismantle"), it will be
 * defined here if you care.
 */
class DestinyItemActionBlockDefinition {
  /** Localized text for the verb of the action being performed. */
  String verbName;
  /** Localized text describing the action being performed. */
  String verbDescription;
  /** The content has this property, however it's not entirely clear how it is used. */
  bool isPositive;
  /**
   * If the action has an overlay screen associated with it, this is the name of that
   * screen. Unfortunately, we cannot return the screen's data itself.
   */
  String overlayScreenName;
  /** The icon associated with the overlay screen for the action, if any. */
  String overlayIcon;
  /** The number of seconds to delay before allowing this action to be performed again. */
  int requiredCooldownSeconds;
  /**
   * If the action requires other items to exist or be destroyed, this is the list of
   * those items and requirements.
   */
  List<DestinyItemActionRequiredItemDefinition> requiredItems;
  /**
   * If performing this action earns you Progression, this is the list of
   * progressions and values granted for those progressions by performing this action.
   */
  List<DestinyProgressionRewardDefinition> progressionRewards;
  /** The internal identifier for the action. */
  String actionTypeLabel;
  /**
   * Theoretically, an item could have a localized string for a hint about the
   * location in which the action should be performed. In practice, no items yet have
   * this property.
   */
  String requiredLocation;
  /**
   * The identifier hash for the Cooldown associated with this action. We have not
   * pulled this data yet for you to have more data to use for cooldowns.
   */
  int requiredCooldownHash;
  /** If true, the item is deleted when the action completes. */
  bool deleteOnAction;
  /** If true, the entire stack is deleted when the action completes. */
  bool consumeEntireStack;
  /**
   * If true, this action will be performed as soon as you earn this item. Some
   * rewards work this way, providing you a single item to pick up from a reward-
   * granting vendor in-game and then immediately consuming itself to provide you
   * multiple items.
   */
  bool useOnAcquire;
}

/**
 * The definition of an item and quantity required in a character's inventory in
 * order to perform an action.
 */
class DestinyItemActionRequiredItemDefinition {
  /** The minimum quantity of the item you have to have. */
  int count;
  /**
   * The hash identifier of the item you need to have. Use it to look up the
   * DestinyInventoryItemDefinition for more info.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int itemHash;
  /**
   * If true, the item/quantity will be deleted from your inventory when the action
   * is performed. Otherwise, you'll retain these required items after the action is
   * complete.
   */
  bool deleteOnAction;
}

/**
 * Inventory Items can reward progression when actions are performed on them. A
 * common example of this in Destiny 1 was Bounties, which would reward Experience
 * on your Character and the like when you completed the bounty.
 *
 * Note that this maps to a DestinyProgressionMappingDefinition, and *not* a
 * DestinyProgressionDefinition directly. This is apparently so that multiple
 * progressions can be granted progression points/experience at the same time.
 */
class DestinyProgressionRewardDefinition {
  /**
   * The hash identifier of the DestinyProgressionMappingDefinition that contains the
   * progressions for which experience should be applied.
   *
   * Mapped to DestinyProgressionMappingDefinition in the manifest.
   */
  int progressionMappingHash;
  /** The amount of experience to give to each of the mapped progressions. */
  int amount;
  /**
   * If true, the game's internal mechanisms to throttle progression should be
   * applied.
   */
  bool applyThrottles;
}

/**
 * Aggregations of multiple progressions.
 *
 * These are used to apply rewards to multiple progressions at once. They can
 * sometimes have human readable data as well, but only extremely sporadically.
 */
class DestinyProgressionMappingDefinition {
  /**
   * Infrequently defined in practice. Defer to the individual progressions' display
   * properties.
   */
  int displayProperties;
  /**
   * The localized unit of measurement for progression across the progressions
   * defined in this mapping. Unfortunately, this is very infrequently defined. Defer
   * to the individual progressions' display units.
   */
  String displayUnits;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * If the item can exist in an inventory - the overwhelming majority of them can
 * and do - then this is the basic properties regarding the item's relationship
 * with the inventory.
 */
class DestinyItemInventoryBlockDefinition {
  /**
   * If this string is populated, you can't have more than one stack with this label
   * in a given inventory. Note that this is different from the equipping block's
   * unique label, which is used for equipping uniqueness.
   */
  String stackUniqueLabel;
  /** The maximum quantity of this item that can exist in a stack. */
  int maxStackSize;
  /**
   * The hash identifier for the DestinyInventoryBucketDefinition to which this item
   * belongs. I should have named this "bucketHash", but too many things refer to it
   * now. Sigh.
   *
   * Mapped to DestinyInventoryBucketDefinition in the manifest.
   */
  int bucketTypeHash;
  /**
   * If the item is picked up by the lost loot queue, this is the hash identifier for
   * the DestinyInventoryBucketDefinition into which it will be placed. Again, I
   * should have named this recoveryBucketHash instead.
   *
   * Mapped to DestinyInventoryBucketDefinition in the manifest.
   */
  int recoveryBucketTypeHash;
  /**
   * The hash identifier for the Tier Type of the item, use to look up its
   * DestinyItemTierTypeDefinition if you need to show localized data for the item's
   * tier.
   *
   * Mapped to DestinyItemTierTypeDefinition in the manifest.
   */
  int tierTypeHash;
  /**
   * If TRUE, this item is instanced. Otherwise, it is a generic item that merely has
   * a quantity in a stack (like Glimmer).
   */
  bool isInstanceItem;
  /**
   * The localized name of the tier type, which is a useful shortcut so you don't
   * have to look up the definition every time. However, it's mostly a holdover from
   * days before we had a DestinyItemTierTypeDefinition to refer to.
   */
  String tierTypeName;
  /**
   * The enumeration matching the tier type of the item to known values, again for
   * convenience sake.
   */
  int tierType;
  /** The tooltip message to show, if any, when the item expires. */
  String expirationTooltip;
  /** If the item expires while playing in an activity, we show a different message. */
  String expiredInActivityMessage;
  /**
   * If the item expires in orbit, we show a... more different message. ("Consummate
   * V's, consummate!")
   */
  String expiredInOrbitMessage;
  bool suppressExpirationWhenObjectivesComplete;
}

/**
 * Defines the tier type of an item. Mostly this provides human readable properties
 * for types like Common, Rare, etc...
 *
 * It also provides some base data for infusion that could be useful.
 */
class DestinyItemTierTypeDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /** If this tier defines infusion properties, they will be contained here. */
  int infusionProcess;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinyItemTierTypeInfusionBlock {
  /**
   * The default portion of quality that will transfer from the infuser to the
   * infusee item. (InfuserQuality - InfuseeQuality) * baseQualityTransferRatio =
   * base quality transferred.
   */
  double baseQualityTransferRatio;
  /**
   * As long as InfuserQuality > InfuseeQuality, the amount of quality bestowed is
   * guaranteed to be at least this value, even if the transferRatio would dictate
   * that it should be less. The total amount of quality that ends up in the Infusee
   * cannot exceed the Infuser's quality however (for instance, if you infuse a 300
   * item with a 301 item and the minimum quality increment is 10, the infused item
   * will not end up with 310 quality)
   */
  int minimumQualityIncrement;
}

class TierType {
   static const int Unknown = 0;
   static const int Currency = 1;
   static const int Basic = 2;
   static const int Common = 3;
   static const int Rare = 4;
   static const int Superior = 5;
   static const int Exotic = 6;
}

/**
 * Primarily for Quests, this is the definition of properties related to the item
 * if it is a quest and its various quest steps.
 */
class DestinyItemSetBlockDefinition {
  /**
   * A collection of hashes of set items, for items such as Quest Metadata items that
   * possess this data.
   */
  List<DestinyItemSetBlockEntryDefinition> itemList;
  /**
   * If true, items in the set can only be added in increasing order, and adding an
   * item will remove any previous item. For Quests, this is by necessity true. Only
   * one quest step is present at a time, and previous steps are removed as you
   * advance in the quest.
   */
  bool requireOrderedSetItemAdd;
  /** If true, the UI should treat this quest as "featured" */
  bool setIsFeatured;
  /** A string identifier we can use to attempt to identify the category of the Quest. */
  String setType;
}

/** Defines a particular entry in an ItemSet (AKA a particular Quest Step in a Quest) */
class DestinyItemSetBlockEntryDefinition {
  /**
   * Used for tracking which step a user reached. These values will be populated in
   * the user's internal state, which we expose externally as a more usable
   * DestinyQuestStatus object. If this item has been obtained, this value will be
   * set in trackingUnlockValueHash.
   */
  int trackingValue;
  /**
   * This is the hash identifier for a DestinyInventoryItemDefinition representing
   * this quest step.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int itemHash;
}

/**
 * Information about the item's calculated stats, with as much data as we can find
 * for the stats without having an actual instance of the item.
 *
 * Note that this means the entire concept of providing these stats is
 * fundamentally insufficient: we cannot predict with 100% accuracy the conditions
 * under which an item can spawn, so we use various heuristics to attempt to
 * simulate the conditions as accurately as possible. Actual stats for items in-
 * game can and will vary, but these should at least be useful base points for
 * comparison and display.
 *
 * It is also worth noting that some stats, like Magazine size, have further
 * calculations performed on them by scripts in-game and on the game servers that
 * BNet does not have access to. We cannot know how those stats are further
 * transformed, and thus some stats will be inaccurate even on instances of items
 * in BNet vs. how they appear in-game. This is a known limitation of our item
 * statistics, without any planned fix.
 */
class DestinyItemStatBlockDefinition {
  /**
   * If true, the game won't show the "primary" stat on this item when you inspect it.
   *
   * NOTE: This is being manually mapped, because I happen to want it in a block that
   * isn't going to directly create this derivative block.
   */
  bool disablePrimaryStatDisplay;
  /**
   * If the item's stats are meant to be modified by a DestinyStatGroupDefinition,
   * this will be the identifier for that definition.
   *
   * If you are using live data or precomputed stats data on the
   * DestinyInventoryItemDefinition.stats.stats property, you don't have to worry
   * about statGroupHash and how it alters stats: the already altered stats are
   * provided to you. But if you want to see how the sausage gets made, or perform
   * computations yourself, this is valuable information.
   *
   * Mapped to DestinyStatGroupDefinition in the manifest.
   */
  int statGroupHash;
  /**
   * If you are looking for precomputed values for the stats on a weapon, this is
   * where they are stored. Technically these are the "Display" stat values. Please
   * see DestinyStatsDefinition for what Display Stat Values means, it's a very long
   * story... but essentially these are the closest values BNet can get to the item
   * stats that you see in-game.
   *
   * These stats are keyed by the DestinyStatDefinition's hash identifier for the
   * stat that's found on the item.
   *
   * Mapped to DestinyStatDefinition in the manifest.
   */
  Map<int, DestinyInventoryItemStatDefinition> stats;
  /**
   * A quick and lazy way to determine whether any stat other than the "primary" stat
   * is actually visible on the item. Items often have stats that we return in case
   * people find them useful, but they're not part of the "Stat Group" and thus we
   * wouldn't display them in our UI. If this is False, then we're not going to
   * display any of these stats other than the primary one.
   */
  bool hasDisplayableStats;
  /**
   * This stat is determined to be the "primary" stat, and can be looked up in the
   * stats or any other stat collection related to the item.
   *
   * Use this hash to look up the stat's value using DestinyInventoryItemDefinition.
   * stats.stats, and the renderable data for the primary stat in the related
   * DestinyStatDefinition.
   *
   * Mapped to DestinyStatDefinition in the manifest.
   */
  int primaryBaseStatHash;
}

/**
 * When an inventory item (DestinyInventoryItemDefinition) has Stats (such as
 * Attack Power), the item will refer to a Stat Group. This definition enumerates
 * the properties used to transform the item's "Investment" stats into "Display"
 * stats.
 *
 * See DestinyStatDefinition's documentation for information about the
 * transformation of Stats, and the meaning of an Investment vs. a Display stat.
 *
 * If you don't want to do these calculations on your own, fear not: pulling live
 * data from the BNet endpoints will return display stat values pre-computed and
 * ready for you to use. I highly recommend this approach, saves a lot of time and
 * also accounts for certain stat modifiers that can't easily be accounted for
 * without live data (such as stat modifiers on Talent Grids and Socket Plugs)
 */
class DestinyStatGroupDefinition {
  /**
   * The maximum possible value that any stat in this group can be transformed into.
   *
   * This is used by stats that *don't* have scaledStats entries below, but that
   * still need to be displayed as a progress bar, in which case this is used as the
   * upper bound for said progress bar. (the lower bound is always 0)
   */
  int maximumValue;
  /**
   * This apparently indicates the position of the stats in the UI? I've returned it
   * in case anyone can use it, but it's not of any use to us on BNet. Something's
   * being lost in translation with this value.
   */
  int uiPosition;
  /**
   * Any stat that requires scaling to be transformed from an "Investment" stat to a "
   * Display" stat will have an entry in this list. For more information on what
   * those types of stats mean and the transformation process, see
   * DestinyStatDefinition.
   *
   * In retrospect, I wouldn't mind if this was a dictionary keyed by the stat hash
   * instead. But I'm going to leave it be because [[After Apple Picking]].
   */
  List<DestinyStatDisplayDefinition> scaledStats;
  /**
   * The game has the ability to override, based on the stat group, what the
   * localized text is that is displayed for Stats being shown on the item.
   *
   * Mercifully, no Stat Groups use this feature currently. If they start using them,
   * we'll all need to start using them (and those of you who are more prudent than I
   * am can go ahead and start pre-checking for this.)
   */
  Map<int, DestinyStatOverrideDefinition> overrides;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * Describes the way that an Item Stat (see DestinyStatDefinition) is transformed
 * using the DestinyStatGroupDefinition related to that item. See both of the
 * aforementioned definitions for more information about the stages of stat
 * transformation.
 *
 * This represents the transformation of a stat into a "Display" stat (the closest
 * value that BNet can get to the in-game display value of the stat)
 */
class DestinyStatDisplayDefinition {
  /**
   * The hash identifier for the stat being transformed into a Display stat.
   *
   * Use it to look up the DestinyStatDefinition, or key into a
   * DestinyInventoryItemDefinition's stats property.
   *
   * Mapped to DestinyStatDefinition in the manifest.
   */
  int statHash;
  /**
   * Regardless of the output of interpolation, this is the maximum possible value
   * that the stat can be. It should also be used as the upper bound for displaying
   * the stat as a progress bar (the minimum always being 0)
   */
  int maximumValue;
  /**
   * If this is true, the stat should be displayed as a number. Otherwise, display it
   * as a progress bar. Or, you know, do whatever you want. There's no
   * displayAsNumeric police.
   */
  bool displayAsNumeric;
  /**
   * The interpolation table representing how the Investment Stat is transformed into
   * a Display Stat.
   *
   * See DestinyStatDefinition for a description of the stages of stat transformation.
   */
  List<InterpolationPoint> displayInterpolation;
}

/**
 * Stat Groups (DestinyStatGroupDefinition) has the ability to override the
 * localized text associated with stats that are to be shown on the items with
 * which they are associated.
 *
 * This defines a specific overridden stat. You could theoretically check these
 * before rendering your stat UI, and for each stat that has an override show these
 * displayProperties instead of those on the DestinyStatDefinition.
 *
 * Or you could be like us, and skip that for now because the game has yet to
 * actually use this feature. But know that it's here, waiting for a resilliant
 * young designer to take up the mantle and make us all look foolish by showing the
 * wrong name for stats.
 *
 * Note that, if this gets used, the override will apply only to items using the
 * overriding Stat Group. Other items will still show the default stat's name/
 * description.
 */
class DestinyStatOverrideDefinition {
  /**
   * The hash identifier of the stat whose display properties are being overridden.
   *
   * Mapped to DestinyStatDefinition in the manifest.
   */
  int statHash;
  /**
   * The display properties to show instead of the base DestinyStatDefinition display
   * properties.
   */
  int displayProperties;
}

/**
 * Defines a specific stat value on an item, and the minimum/maximum range that we
 * could compute for the item based on our heuristics for how the item might be
 * generated.
 *
 * Not guaranteed to match real-world instances of the item, but should hopefully
 * at least be close. If it's not close, let us know on the Bungie API forums.
 */
class DestinyInventoryItemStatDefinition {
  /**
   * The hash for the DestinyStatDefinition representing this stat.
   *
   * Mapped to DestinyStatDefinition in the manifest.
   */
  int statHash;
  /**
   * This value represents the stat value assuming the minimum possible roll but
   * accounting for any mandatory bonuses that should be applied to the stat on item
   * creation.
   *
   * In Destiny 1, this was different from the "minimum" value because there were
   * certain conditions where an item could be theoretically lower level/value than
   * the initial roll.
   *
   * In Destiny 2, this is not possible unless Talent Grids begin to be used again
   * for these purposes or some other system change occurs... thus in practice, value
   * and minimum should be the same in Destiny 2. Good riddance.
   */
  int value;
  /** The minimum possible value for this stat that we think the item can roll. */
  int minimum;
  /**
   * The maximum possible value for this stat that we think the item can roll.
   *
   * WARNING: In Destiny 1, this field was calculated using the potential stat rolls
   * on the item's talent grid. In Destiny 2, items no longer have meaningful talent
   * grids and instead have sockets: but the calculation of this field was never
   * altered to adapt to this change. As such, this field should be considered
   * deprecated until we can address this oversight.
   */
  int maximum;
}

/**
 * Items that can be equipped define this block. It contains information we need to
 * understand how and when the item can be equipped.
 */
class DestinyEquippingBlockDefinition {
  /**
   * If the item is part of a gearset, this is a reference to that gearset item.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int gearsetItemHash;
  /**
   * If defined, this is the label used to check if the item has other items of
   * matching types already equipped.
   *
   * For instance, when you aren't allowed to equip more than one Exotic Weapon, that'
   * s because all exotic weapons have identical uniqueLabels and the game checks the
   * to-be-equipped item's uniqueLabel vs. all other already equipped items (other
   * than the item in the slot that's about to be occupied).
   */
  String uniqueLabel;
  /** The hash of that unique label. Does not point to a specific definition. */
  int uniqueLabelHash;
  /**
   * An equipped item *must* be equipped in an Equipment Slot. This is the hash
   * identifier of the DestinyEquipmentSlotDefinition into which it must be equipped.
   *
   * Mapped to DestinyEquipmentSlotDefinition in the manifest.
   */
  int equipmentSlotTypeHash;
  /**
   * These are custom attributes on the equippability of the item.
   *
   * For now, this can only be "equip on acquire", which would mean that the item
   * will be automatically equipped as soon as you pick it up.
   */
  int attributes;
  /**
   * Ammo type used by a weapon is no longer determined by the bucket in which it is
   * contained. If the item has an ammo type - i.e. if it is a weapon - this will be
   * the type of ammunition expected.
   */
  int ammoType;
  /**
   * These are strings that represent the possible Game/Account/Character state
   * failure conditions that can occur when trying to equip the item. They match up
   * one-to-one with requiredUnlockExpressions.
   */
  List<String> displayStrings;
}

class EquippingItemBlockAttributes {
   static const int None = 0;
   static const int EquipOnAcquire = 1;
}

class DestinyAmmunitionType {
   static const int None = 0;
   static const int Primary = 1;
   static const int Special = 2;
   static const int Heavy = 3;
   static const int Unknown = 4;
}

/** This Block defines the rendering data associated with the item, if any. */
class DestinyItemTranslationBlockDefinition {
  String weaponPatternIdentifier;
  int weaponPatternHash;
  List<DyeReference> defaultDyes;
  List<DyeReference> lockedDyes;
  List<DyeReference> customDyes;
  List<DestinyGearArtArrangementReference> arrangements;
  bool hasGeometry;
}

class DyeReference {
  int channelHash;
  int dyeHash;
}

class DestinyGearArtArrangementReference {
  int classHash;
  int artArrangementHash;
}

/**
 * Items like Sacks or Boxes can have items that it shows in-game when you view
 * details that represent the items you can obtain if you use or acquire the item.
 *
 * This defines those categories, and gives some insights into that data's source.
 */
class DestinyItemPreviewBlockDefinition {
  /**
   * A string that the game UI uses as a hint for which detail screen to show for the
   * item. You, too, can leverage this for your own custom screen detail views. Note,
   * however, that these are arbitrarily defined by designers: there's no guarantees
   * of a fixed, known number of these - so fall back to something reasonable if you
   * don't recognize it.
   */
  String screenStyle;
  /**
   * If the preview data is derived from a fake "Preview" Vendor, this will be the
   * hash identifier for the DestinyVendorDefinition of that fake vendor.
   *
   * Mapped to DestinyVendorDefinition in the manifest.
   */
  int previewVendorHash;
  /**
   * If the preview has an associated action (like "Open"), this will be the
   * localized string for that action.
   */
  String previewActionString;
  /**
   * This is a list of the items being previewed, categorized in the same way as they
   * are in the preview UI.
   */
  List<DestinyDerivedItemCategoryDefinition> derivedItemCategories;
}

/**
 * A shortcut for the fact that some items have a "Preview Vendor" - See
 * DestinyInventoryItemDefinition.preview.previewVendorHash - that is intended to
 * be used to show what items you can get as a result of acquiring or using this
 * item.
 *
 * A common example of this in Destiny 1 was Eververse "Boxes," which could have
 * many possible items. This "Preview Vendor" is not a vendor you can actually see
 * in the game, but it defines categories and sale items for all of the possible
 * items you could get from the Box so that the game can show them to you. We
 * summarize that info here so that you don't have to do that Vendor lookup and
 * aggregation manually.
 */
class DestinyDerivedItemCategoryDefinition {
  /**
   * The localized string for the category title. This will be something describing
   * the items you can get as a group, or your likelihood/the quantity you'll get.
   */
  String categoryDescription;
  /**
   * This is the list of all of the items for this category and the basic properties
   * we'll know about them.
   */
  List<DestinyDerivedItemDefinition> items;
}

/**
 * This is a reference to, and summary data for, a specific item that you can get
 * as a result of Using or Acquiring some other Item (For example, this could be
 * summary information for an Emote that you can get by opening an an Eververse Box)
 * See DestinyDerivedItemCategoryDefinition for more information.
 */
class DestinyDerivedItemDefinition {
  /**
   * The hash for the DestinyInventoryItemDefinition of this derived item, if there
   * is one. Sometimes we are given this information as a manual override, in which
   * case there won't be an actual DestinyInventoryItemDefinition for what we display,
   * but you can still show the strings from this object itself.
   */
  int itemHash;
  /** The name of the derived item. */
  String itemName;
  /** Additional details about the derived item, in addition to the description. */
  String itemDetail;
  /** A brief description of the item. */
  String itemDescription;
  /** An icon for the item. */
  String iconPath;
  /**
   * If the item was derived from a "Preview Vendor", this will be an index into the
   * DestinyVendorDefinition's itemList property. Otherwise, -1.
   */
  int vendorItemIndex;
}

/**
 * An item's "Quality" determines its calculated stats. The Level at which the item
 * spawns is combined with its "qualityLevel" along with some additional
 * calculations to determine the value of those stats.
 *
 * In Destiny 2, most items don't have default item levels and quality, making this
 * property less useful: these apparently are almost always determined by the
 * complex mechanisms of the Reward system rather than statically. They are still
 * provided here in case they are still useful for people. This also contains some
 * information about Infusion.
 */
class DestinyItemQualityBlockDefinition {
  /**
   * The "base" defined level of an item. This is a list because, in theory, each
   * Expansion could define its own base level for an item.
   *
   * In practice, not only was that never done in Destiny 1, but now this isn't even
   * populated at all. When it's not populated, the level at which it spawns has to
   * be inferred by Reward information, of which BNet receives an imperfect view and
   * will only be reliable on instanced data as a result.
   */
  List<int> itemLevels;
  /**
   * qualityLevel is used in combination with the item's level to calculate stats
   * like Attack and Defense. It plays a role in that calculation, but not nearly as
   * large as itemLevel does.
   */
  int qualityLevel;
  /**
   * The string identifier for this item's "infusability", if any.
   *
   * Items that match the same infusionCategoryName are allowed to infuse with each
   * other.
   *
   * DEPRECATED: Items can now have multiple infusion categories. Please use
   * infusionCategoryHashes instead.
   */
  String infusionCategoryName;
  /**
   * The hash identifier for the infusion. It does not map to a Definition entity.
   *
   * DEPRECATED: Items can now have multiple infusion categories. Please use
   * infusionCategoryHashes instead.
   */
  int infusionCategoryHash;
  /**
   * If any one of these hashes matches any value in another item's
   * infusionCategoryHashes, the two can infuse with each other.
   */
  List<int> infusionCategoryHashes;
  /**
   * An item can refer to pre-set level requirements. They are defined in
   * DestinyProgressionLevelRequirementDefinition, and you can use this hash to find
   * the appropriate definition.
   *
   * Mapped to DestinyProgressionLevelRequirementDefinition in the manifest.
   */
  int progressionLevelRequirementHash;
}

/**
 * These are pre-constructed collections of data that can be used to determine the
 * Level Requirement for an item given a Progression to be tested (such as the
 * Character's level).
 *
 * For instance, say a character receives a new Auto Rifle, and that Auto Rifle's
 * DestinyInventoryItemDefinition.quality.progressionLevelRequirementHash property
 * is pointing at one of these DestinyProgressionLevelRequirementDefinitions. Let's
 * pretend also that the progressionHash it is pointing at is the Character Level
 * progression. In that situation, the character's level will be used to
 * interpolate a value in the requirementCurve property. The value picked up from
 * that interpolation will be the required level for the item.
 */
class DestinyProgressionLevelRequirementDefinition {
  /**
   * A curve of level requirements, weighted by the related progressions' level.
   *
   * Interpolate against this curve with the character's progression level to
   * determine what the level requirement of the generated item that is using this
   * data will be.
   */
  List<InterpolationPointFloat> requirementCurve;
  /**
   * The progression whose level should be used to determine the level requirement.
   *
   * Look up the DestinyProgressionDefinition with this hash for more information
   * about the progression in question.
   *
   * Mapped to DestinyProgressionDefinition in the manifest.
   */
  int progressionHash;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * This defines an item's "Value". Unfortunately, this appears to be used in
 * different ways depending on the way that the item itself is used.
 *
 * For items being sold at a Vendor, this is the default "sale price" of the item.
 * These days, the vendor itself almost always sets the price, but it still
 * possible for the price to fall back to this value. For quests, it is a preview
 * of rewards you can gain by completing the quest. For dummy items, if the
 * itemValue refers to an Emblem, it is the emblem that should be shown as the
 * reward. (jeez louise)
 *
 * It will likely be used in a number of other ways in the future, it appears to be
 * a bucket where they put arbitrary items and quantities into the item.
 */
class DestinyItemValueBlockDefinition {
  /** References to the items that make up this item's "value", and the quantity. */
  List<DestinyItemQuantity> itemValue;
  /**
   * If there's a localized text description of the value provided, this will be said
   * description.
   */
  String valueDescription;
}

/** Data about an item's "sources": ways that the item can be obtained. */
class DestinyItemSourceBlockDefinition {
  /**
   * The list of hash identifiers for Reward Sources that hint where the item can be
   * found (DestinyRewardSourceDefinition).
   *
   * Mapped to DestinyRewardSourceDefinition in the manifest.
   */
  List<int> sourceHashes;
  /**
   * A collection of details about the stats that were computed for the ways we found
   * that the item could be spawned.
   */
  List<DestinyItemSourceDefinition> sources;
  /**
   * If we found that this item is exclusive to a specific platform, this will be set
   * to the BungieMembershipType enumeration that matches that platform.
   */
  int exclusive;
}

/**
 * Represents a heuristically-determined "item source" according to Bungie.net.
 * These item sources are non-canonical: we apply a combination of special
 * configuration and often-fragile heuristics to attempt to discern whether an item
 * should be part of a given "source," but we have known cases of false positives
 * and negatives due to our imperfect heuristics.
 *
 * Still, they provide a decent approximation for people trying to figure out how
 * an item can be obtained. DestinyInventoryItemDefinition refers to sources in the
 * sourceDatas.sourceHashes property for all sources we determined the item could
 * spawn from.
 *
 * An example in Destiny 1 of a Source would be "Nightfall". If an item has the "
 * Nightfall" source associated with it, it's extremely likely that you can earn
 * that item while playing Nightfall, either during play or as an after-completion
 * reward.
 */
class DestinyRewardSourceDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * Sources are grouped into categories: common ways that items are provided. I hope
   * to see this expand in Destiny 2 once we have time to generate accurate reward
   * source data.
   */
  int category;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinyRewardSourceCategory {
  /** The source doesn't fit well into any of the other types. */
   static const int None = 0;
  /**
   * The source is directly related to the rewards gained by playing an activity or
   * set of activities. This currently includes Quests and other action in-game.
   */
   static const int Activity = 1;
  /** This source is directly related to items that Vendors sell. */
   static const int Vendor = 2;
  /**
   * This source is a custom aggregation of items that can be earned in many ways,
   * but that share some other property in common that is useful to share. For
   * instance, in Destiny 1 we would make "Reward Sources" for every game expansion:
   * that way, you could search reward sources to see what items became available
   * with any given Expansion.
   */
   static const int Aggregate = 3;
}

/**
 * Properties of a DestinyInventoryItemDefinition that store all of the information
 * we were able to discern about how the item spawns, and where you can find the
 * item.
 *
 * Items will have many of these sources, one per level at which it spawns, to try
 * and give more granular data about where items spawn for specific level ranges.
 */
class DestinyItemSourceDefinition {
  /**
   * The level at which the item spawns. Essentially the Primary Key for this source
   * data: there will be multiple of these source entries per item that has source
   * data, grouped by the level at which the item spawns.
   */
  int level;
  /**
   * The minimum Quality at which the item spawns for this level. Examine
   * DestinyInventoryItemDefinition for more information about what Quality means.
   * Just don't ask Phaedrus about it, he'll never stop talking and you'll have to
   * write a book about it.
   */
  int minQuality;
  /** The maximum quality at which the item spawns for this level. */
  int maxQuality;
  /**
   * The minimum Character Level required for equipping the item when the item spawns
   * at the item level defined on this DestinyItemSourceDefinition, as far as we saw
   * in our processing.
   */
  int minLevelRequired;
  /**
   * The maximum Character Level required for equipping the item when the item spawns
   * at the item level defined on this DestinyItemSourceDefinition, as far as we saw
   * in our processing.
   */
  int maxLevelRequired;
  /** The stats computed for this level/quality range. */
  Map<int, DestinyInventoryItemStatDefinition> computedStats;
  /**
   * The DestinyRewardSourceDefinitions found that can spawn the item at this level.
   *
   * Mapped to DestinyRewardSourceDefinition in the manifest.
   */
  List<int> sourceHashes;
}

/**
 * An item can have objectives on it. In practice, these are the exclusive purview
 * of "Quest Step" items: DestinyInventoryItemDefinitions that represent a specific
 * step in a Quest.
 *
 * Quest steps have 1:M objectives that we end up processing and returning in live
 * data as DestinyQuestStatus data, and other useful information.
 */
class DestinyItemObjectiveBlockDefinition {
  /**
   * The hashes to Objectives (DestinyObjectiveDefinition) that are part of this
   * Quest Step, in the order that they should be rendered.
   *
   * Mapped to DestinyObjectiveDefinition in the manifest.
   */
  List<int> objectiveHashes;
  /**
   * For every entry in objectiveHashes, there is a corresponding entry in this array
   * at the same index. If the objective is meant to be associated with a specific
   * DestinyActivityDefinition, there will be a valid hash at that index. Otherwise,
   * it will be invalid (0).
   *
   * Rendered somewhat obsolete by perObjectiveDisplayProperties, which currently has
   * much the same information but may end up with more info in the future.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  List<int> displayActivityHashes;
  /**
   * If True, all objectives must be completed for the step to be completed. If False,
   * any one objective can be completed for the step to be completed.
   */
  bool requireFullObjectiveCompletion;
  /**
   * The hash for the DestinyInventoryItemDefinition representing the Quest to which
   * this Quest Step belongs.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int questlineItemHash;
  /** The localized string for narrative text related to this quest step, if any. */
  String narrative;
  /**
   * The localized string describing an action to be performed associated with the
   * objectives, if any.
   */
  String objectiveVerbName;
  /**
   * The identifier for the type of quest being performed, if any. Not associated
   * with any fixed definition, yet.
   */
  String questTypeIdentifier;
  /**
   * A hashed value for the questTypeIdentifier, because apparently I like to be
   * redundant.
   */
  int questTypeHash;
  /** One entry per Objective on the item, it will have related display information. */
  List<DestinyObjectiveDisplayProperties> perObjectiveDisplayProperties;
}

class DestinyObjectiveDisplayProperties {
  /**
   * The activity associated with this objective in the context of this item, if any.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int activityHash;
  /** If true, the game shows this objective on item preview screens. */
  bool displayOnItemPreviewScreen;
}

/**
 * If an item is a Plug, its DestinyInventoryItemDefinition.plug property will be
 * populated with an instance of one of these bad boys.
 *
 * This gives information about when it can be inserted, what the plug's category
 * is (and thus whether it is compatible with a socket... see
 * DestinySocketTypeDefinition for information about Plug Categories and socket
 * compatibility), whether it is enabled and other Plug info.
 */
class DestinyItemPlugDefinition {
  /**
   * The rules around when this plug can be inserted into a socket, aside from the
   * socket's individual restrictions.
   *
   * The live data DestinyItemPlugComponent.insertFailIndexes will be an index into
   * this array, so you can pull out the failure strings appropriate for the user.
   */
  List<DestinyPlugRuleDefinition> insertionRules;
  /**
   * The string identifier for the plug's category. Use the socket's
   * DestinySocketTypeDefinition.plugWhitelist to determine whether this plug can be
   * inserted into the socket.
   */
  String plugCategoryIdentifier;
  /**
   * The hash for the plugCategoryIdentifier. You can use this instead if you wish: I
   * put both in the definition for debugging purposes.
   */
  int plugCategoryHash;
  /**
   * If you successfully socket the item, this will determine whether or not you get "
   * refunded" on the plug.
   */
  bool onActionRecreateSelf;
  /**
   * If inserting this plug requires materials, this is the hash identifier for
   * looking up the DestinyMaterialRequirementSetDefinition for those requirements.
   *
   * Mapped to DestinyMaterialRequirementSetDefinition in the manifest.
   */
  int insertionMaterialRequirementHash;
  /**
   * In the game, if you're inspecting a plug item directly, this will be the item
   * shown with the plug attached. Look up the DestinyInventoryItemDefinition for
   * this hash for the item.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int previewItemOverrideHash;
  /**
   * It's not enough for the plug to be inserted. It has to be enabled as well. For
   * it to be enabled, it may require materials. This is the hash identifier for the
   * DestinyMaterialRequirementSetDefinition for those requirements, if there is one.
   *
   * Mapped to DestinyMaterialRequirementSetDefinition in the manifest.
   */
  int enabledMaterialRequirementHash;
  /**
   * The rules around whether the plug, once inserted, is enabled and providing its
   * benefits.
   *
   * The live data DestinyItemPlugComponent.enableFailIndexes will be an index into
   * this array, so you can pull out the failure strings appropriate for the user.
   */
  List<DestinyPlugRuleDefinition> enabledRules;
  /**
   * Plugs can have arbitrary, UI-defined identifiers that the UI designers use to
   * determine the style applied to plugs. Unfortunately, we have neither a
   * definitive list of these labels nor advance warning of when new labels might be
   * applied or how that relates to how they get rendered. If you want to, you can
   * refer to known labels to change your own styles: but know that new ones can be
   * created arbitrarily, and we have no way of associating the labels with any
   * specific UI style guidance... you'll have to piece that together on your end. Or
   * do what we do, and just show plugs more generically, without specialized styles.
   */
  String uiPlugLabel;
  PlugUiStyles plugStyle;
  /**
   * If TRUE, the plug doesn't actually convey any benefit: it only exists to show
   * information in the UI.
   */
  bool isPseudoPlug;
  /**
   * Indicates the rules about when this plug can be used. See the
   * PlugAvailabilityMode enumeration for more information!
   */
  int plugAvailability;
  /**
   * If the plug meets certain state requirements, it may have an alternative label
   * applied to it. This is the alternative label that will be applied in such a
   * situation.
   */
  String alternateUiPlugLabel;
  /**
   * The alternate plug of the plug: only applies when the item is in states that
   * only the server can know about and control, unfortunately. See
   * AlternateUiPlugLabel for the related label info.
   */
  int alternatePlugStyle;
  /**
   * If TRUE, this plug is used for UI display purposes only, and doesn't have any
   * interesting effects of its own.
   */
  bool isDummyPlug;
  /**
   * Do you ever get the feeling that a system has become so overburdened by edge
   * cases that it probably should have become some other system entirely? So do I!
   *
   * In totally unrelated news, Plugs can now override properties of their parent
   * items. This is some of the relevant definition data for those overrides.
   *
   * If this is populated, it will have the override data to be applied when this
   * plug is applied to an item.
   */
  int parentItemOverride;
}

/**
 * Dictates a rule around whether the plug is enabled or insertable.
 *
 * In practice, the live Destiny data will refer to these entries by index. You can
 * then look up that index in the appropriate property (enabledRules or
 * insertionRules) to get the localized string for the failure message if it failed.
 */
class DestinyPlugRuleDefinition {
  /** The localized string to show if this rule fails. */
  String failureMessage;
}

class PlugUiStyles {
   static const int None = 0;
   static const int Masterwork = 1;
}

class PlugAvailabilityMode {
   static const int Normal = 0;
   static const int UnavailableIfSocketContainsMatchingPlugCategory = 1;
   static const int AvailableIfSocketContainsMatchingPlugCategory = 2;
}

class DestinyParentItemOverride {
  List<String> additionalEquipRequirementsDisplayStrings;
  String pipIcon;
}

/**
 * If an item has a related gearset, this is the list of items in that set, and an
 * unlock expression that evaluates to a number representing the progress toward
 * gearset completion (a very rare use for unlock expressions!)
 */
class DestinyItemGearsetBlockDefinition {
  /** The maximum possible number of items that can be collected. */
  int trackingValueMax;
  /**
   * The list of hashes for items in the gearset. Use them to look up
   * DestinyInventoryItemDefinition entries for the items in the set.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  List<int> itemList;
}

/**
 * Some items are "sacks" - they can be "opened" to produce other items. This is
 * information related to its sack status, mostly UI strings. Engrams are an
 * example of items that are considered to be "Sacks".
 */
class DestinyItemSackBlockDefinition {
  /**
   * A description of what will happen when you open the sack. As far as I can tell,
   * this is blank currently. Unknown whether it will eventually be populated with
   * useful info.
   */
  String detailAction;
  /** The localized name of the action being performed when you open the sack. */
  String openAction;
  int selectItemCount;
  String vendorSackType;
  bool openOnAcquire;
}

/** If defined, the item has at least one socket. */
class DestinyItemSocketBlockDefinition {
  /**
   * This was supposed to be a string that would give per-item details about sockets.
   * In practice, it turns out that all this ever has is the localized word "details".
   * ... that's lame, but perhaps it will become something cool in the future.
   */
  String detail;
  /**
   * Each non-intrinsic (or mutable) socket on an item is defined here. Check inside
   * for more info.
   */
  List<DestinyItemSocketEntryDefinition> socketEntries;
  /**
   * Each intrinsic (or immutable/permanent) socket on an item is defined here, along
   * with the plug that is permanently affixed to the socket.
   */
  List<DestinyItemIntrinsicSocketEntryDefinition> intrinsicSockets;
  /**
   * A convenience property, that refers to the sockets in the "sockets" property,
   * pre-grouped by category and ordered in the manner that they should be grouped in
   * the UI. You could form this yourself with the existing data, but why would you
   * want to? Enjoy life man.
   */
  List<DestinyItemSocketCategoryDefinition> socketCategories;
}

/**
 * The definition information for a specific socket on an item. This will determine
 * how the socket behaves in-game.
 */
class DestinyItemSocketEntryDefinition {
  /**
   * All sockets have a type, and this is the hash identifier for this particular
   * type. Use it to look up the DestinySocketTypeDefinition: read there for more
   * information on how socket types affect the behavior of the socket.
   *
   * Mapped to DestinySocketTypeDefinition in the manifest.
   */
  int socketTypeHash;
  /**
   * If a valid hash, this is the hash identifier for the
   * DestinyInventoryItemDefinition representing the Plug that will be initially
   * inserted into the item on item creation. Otherwise, this Socket will either
   * start without a plug inserted, or will have one randomly inserted.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int singleInitialItemHash;
  /**
   * This is a list of pre-determined plugs that can *always* be plugged into this
   * socket, without the character having the plug in their inventory.
   *
   * If this list is populated, you will not be allowed to plug an arbitrary item in
   * the socket: you will only be able to choose from one of these reusable plugs.
   */
  List<DestinyItemSocketEntryPlugItemDefinition> reusablePlugItems;
  /**
   * If this is true, then the socket will not be initialized with a plug if the item
   * is purchased from a Vendor.
   *
   * Remember that Vendors are much more than conceptual vendors: they include "
   * Collection Kiosks" and other entities. See DestinyVendorDefinition for more
   * information.
   */
  bool preventInitializationOnVendorPurchase;
  /**
   * If this is true, the perks provided by this socket shouldn't be shown in the
   * item's tooltip. This might be useful if it's providing a hidden bonus, or if the
   * bonus is less important than other benefits on the item.
   */
  bool hidePerksInItemTooltip;
  /**
   * Indicates where you should go to get plugs for this socket. This will affect how
   * you populate your UI, as well as what plugs are valid for this socket. It's an
   * alternative to having to check for the existence of certain properties (
   * reusablePlugItems for example) to infer where plugs should come from.
   */
  int plugSources;
  /**
   * If this socket's plugs come from a reusable DestinyPlugSetDefinition, this is
   * the identifier for that set. We added this concept to reduce some major
   * duplication that's going to come from sockets as replacements for what was once
   * implemented as large sets of items and kiosks (like Emotes).
   */
  int reusablePlugSetHash;
  /**
   * As of Forsaken, item sockets can have randomized plugs. If this is populated,
   * the live data will return a subset of plugs from this list that are active and
   * able to be inserted into the socket just like a reusable plug.
   */
  List<DestinyItemSocketEntryPlugItemRandomizedDefinition> randomizedPlugItems;
  /**
   * If true, then this socket is visible in the item's "default" state. If you have
   * an instance, you should always check the runtime state, as that can override
   * this visibility setting: but if you're looking at the item on a conceptual level,
   * this property can be useful for hiding data such as legacy sockets - which
   * remain defined on items for infrastructure purposes, but can be confusing for
   * users to see.
   */
  bool defaultVisible;
}

/** The definition of a known, reusable plug that can be applied to a socket. */
class DestinyItemSocketEntryPlugItemDefinition {
  /**
   * The hash identifier of a DestinyInventoryItemDefinition representing the plug
   * that can be inserted.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int plugItemHash;
}

class SocketPlugSources {
  /** If there's no way we can detect to insert new plugs. */
   static const int None = 0;
  /**
   * Use plugs found in the player's inventory, based on the socket type rules (see
   * DestinySocketTypeDefinition for more info)
   *
   * Note that a socket - like Shaders - can have *both* reusable plugs and inventory
   * items inserted theoretically.
   */
   static const int InventorySourced = 1;
  /**
   * Use the DestinyItemSocketsComponent.sockets.reusablePlugs property to determine
   * which plugs are valid for this socket.
   */
   static const int ReusablePlugItems = 2;
  /**
   * Use the ProfilePlugSets component data to determine which plugs are valid for
   * this socket.
   */
   static const int ProfilePlugSet = 4;
  /**
   * Use the CharacterPlugSets component data to determine which plugs are valid for
   * this socket.
   */
   static const int CharacterPlugSet = 8;
}

class DestinyItemSocketEntryPlugItemRandomizedDefinition {
  /**
   * The hash identifier of a DestinyInventoryItemDefinition representing the plug
   * that can be inserted.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int plugItemHash;
}

/**
 * Represents a socket that has a plug associated with it intrinsically. This is
 * useful for situations where the weapon needs to have a visual plug/Mod on it,
 * but that plug/Mod should never change.
 */
class DestinyItemIntrinsicSocketEntryDefinition {
  /**
   * Indicates the plug that is intrinsically inserted into this socket.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int plugItemHash;
  /**
   * Indicates the type of this intrinsic socket.
   *
   * Mapped to DestinySocketTypeDefinition in the manifest.
   */
  int socketTypeHash;
  /**
   * If true, then this socket is visible in the item's "default" state. If you have
   * an instance, you should always check the runtime state, as that can override
   * this visibility setting: but if you're looking at the item on a conceptual level,
   * this property can be useful for hiding data such as legacy sockets - which
   * remain defined on items for infrastructure purposes, but can be confusing for
   * users to see.
   */
  bool defaultVisible;
}

/**
 * Sockets are grouped into categories in the UI. These define which category and
 * which sockets are under that category.
 */
class DestinyItemSocketCategoryDefinition {
  /**
   * The hash for the Socket Category: a quick way to go get the header display
   * information for the category. Use it to look up DestinySocketCategoryDefinition
   * info.
   *
   * Mapped to DestinySocketCategoryDefinition in the manifest.
   */
  int socketCategoryHash;
  /**
   * Use these indexes to look up the sockets in the "sockets.socketEntries" property
   * on the item definition. These are the indexes under the category, in game-
   * rendered order.
   */
  List<int> socketIndexes;
}

/**
 * This appears to be information used when rendering rewards. We don't currently
 * use it on BNet.
 */
class DestinyItemSummaryBlockDefinition {
  /**
   * Apparently when rendering an item in a reward, this should be used as a sort
   * priority. We're not doing it presently.
   */
  int sortPriority;
}

/**
 * This defines information that can only come from a talent grid on an item. Items
 * mostly have negligible talent grid data these days, but instanced items still
 * retain grids as a source for some of this common information.
 *
 * Builds/Subclasses are the only items left that still have talent grids with
 * meaningful Nodes.
 */
class DestinyItemTalentGridBlockDefinition {
  /**
   * The hash identifier of the DestinyTalentGridDefinition attached to this item.
   *
   * Mapped to DestinyTalentGridDefinition in the manifest.
   */
  int talentGridHash;
  /**
   * This is meant to be a subtitle for looking at the talent grid. In practice,
   * somewhat frustratingly, this always merely says the localized word for "Details".
   * Great. Maybe it'll have more if talent grids ever get used for more than builds
   * and subclasses again.
   */
  String itemDetailString;
  /**
   * A shortcut string identifier for the "build" in question, if this talent grid
   * has an associated build. Doesn't map to anything we can expose at the moment.
   */
  String buildName;
  /**
   * If the talent grid implies a damage type, this is the enum value for that damage
   * type.
   */
  int hudDamageType;
  /**
   * If the talent grid has a special icon that's shown in the game UI (like builds,
   * funny that), this is the identifier for that icon. Sadly, we don't actually get
   * that icon right now. I'll be looking to replace this with a path to the actual
   * icon itself.
   */
  String hudIcon;
}

/**
 * The time has unfortunately come to talk about Talent Grids.
 *
 * Talent Grids are the most complex and unintuitive part of the Destiny Definition
 * data. Grab a cup of coffee before we begin, I can wait.
 *
 * Talent Grids were the primary way that items could be customized in Destiny 1.
 * In Destiny 2, for now, talent grids have become exclusively used by Subclass/
 * Build items: but the system is still in place for it to be used by items should
 * the direction change back toward talent grids.
 *
 * Talent Grids have Nodes: the visual circles on the talent grid detail screen
 * that have icons and can be activated if you meet certain requirements and pay
 * costs. The actual visual data and effects, however, are driven by the "Steps" on
 * Talent Nodes. Any given node will have 1:M of these steps, and the specific step
 * that will be considered the "current" step (and thus the dictator of all
 * benefits, visual state, and activation requirements on the Node) will almost
 * always not be determined until an instance of the item is created. This is how,
 * in Destiny 1, items were able to have such a wide variety of what users saw as "
 * Perks": they were actually Talent Grids with nodes that had a wide variety of
 * Steps, randomly chosen at the time of item creation.
 *
 * Now that Talent Grids are used exclusively by subclasses and builds, all of the
 * properties within still apply: but there are additional visual elements on the
 * Subclass/Build screens that are superimposed on top of the talent nodes.
 * Unfortunately, BNet doesn't have this data: if you want to build a subclass
 * screen, you will have to provide your own "decorative" assets, such as the
 * visual connectors between nodes and the fancy colored-fire-bathed character
 * standing behind the nodes.
 *
 * DestinyInventoryItem.talentGrid.talentGridHash defines an item's linked Talent
 * Grid, which brings you to this definition that contains enough satic data about
 * talent grids to make your head spin. These *must* be combined with instanced
 * data - found when live data returns DestinyItemTalentGridComponent - in order to
 * derive meaning. The instanced data will reference nodes and steps within these
 * definitions, which you will then have to look up in the definition and combine
 * with the instanced data to give the user the visual representation of their item'
 * s talent grid.
 */
class DestinyTalentGridDefinition {
  /**
   * The maximum possible level of the Talent Grid: at this level, any nodes are
   * allowed to be activated.
   */
  int maxGridLevel;
  /**
   * The meaning of this has been lost in the sands of time: it still exists as a
   * property, but appears to be unused in the modern UI of talent grids. It used to
   * imply that each visual "column" of talent nodes required identical progression
   * levels in order to be activated. Returning this value in case it is still useful
   * to someone? Perhaps it's just a bit of interesting history.
   */
  int gridLevelPerColumn;
  /**
   * The hash identifier of the Progression (DestinyProgressionDefinition) that
   * drives whether and when Talent Nodes can be activated on the Grid. Items will
   * have instances of this Progression, and will gain experience that will
   * eventually cause the grid to increase in level. As the grid's level increases,
   * it will cross the threshold where nodes can be activated. See
   * DestinyTalentGridStepDefinition's activation requirements for more information.
   *
   * Mapped to DestinyProgressionDefinition in the manifest.
   */
  int progressionHash;
  /**
   * The list of Talent Nodes on the Grid (recall that Nodes themselves are really
   * just locations in the UI to show whatever their current Step is. You will only
   * know the current step for a node by retrieving instanced data through platform
   * calls to the API that return DestinyItemTalentGridComponent).
   */
  List<DestinyTalentNodeDefinition> nodes;
  /**
   * Talent Nodes can exist in "exclusive sets": these are sets of nodes in which
   * only a single node in the set can be activated at any given time. Activating a
   * node in this set will automatically deactivate the other nodes in the set (
   * referred to as a "Swap").
   *
   * If a node in the exclusive set has already been activated, the game will not
   * charge you materials to activate another node in the set, even if you have never
   * activated it before, because you already paid the cost to activate one node in
   * the set.
   *
   * Not to be confused with Exclusive Groups. (how the heck do we NOT get confused
   * by that? Jeez) See the groups property for information about that only-
   * tangentially-related concept.
   */
  List<DestinyTalentNodeExclusiveSetDefinition> exclusiveSets;
  /**
   * This is a quick reference to the indexes of nodes that are not part of exclusive
   * sets. Handy for knowing which talent nodes can only be activated directly,
   * rather than via swapping.
   */
  List<int> independentNodeIndexes;
  /**
   * Talent Nodes can have "Exclusive Groups". These are not to be confused with
   * Exclusive Sets (see exclusiveSets property).
   *
   * Look at the definition of DestinyTalentExclusiveGroup for more information and
   * how they work. These groups are keyed by the "groupHash" from
   * DestinyTalentExclusiveGroup.
   */
  Map<int, DestinyTalentExclusiveGroup> groups;
  /**
   * BNet wants to show talent nodes grouped by similar purpose with localized titles.
   * This is the ordered list of those categories: if you want to show nodes by
   * category, you can iterate over this list, render the displayProperties for the
   * category as the title, and then iterate over the talent nodes referenced by the
   * category to show the related nodes.
   *
   * Note that this is different from Exclusive Groups or Sets, because these
   * categories also incorporate "Independent" nodes that belong to neither sets nor
   * groups. These are purely for visual grouping of nodes rather than functional
   * grouping.
   */
  List<DestinyTalentNodeCategory> nodeCategories;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * Talent Grids on items have Nodes. These nodes have positions in the talent grid'
 * s UI, and contain "Steps" (DestinyTalentNodeStepDefinition), one of whom will be
 * the "Current" step.
 *
 * The Current Step determines the visual properties of the node, as well as what
 * the node grants when it is activated.
 *
 * See DestinyTalentGridDefinition for a more complete overview of how Talent Grids
 * work, and how they are used in Destiny 2 (and how they were used in Destiny 1).
 */
class DestinyTalentNodeDefinition {
  /**
   * The index into the DestinyTalentGridDefinition's "nodes" property where this
   * node is located. Used to uniquely identify the node within the Talent Grid. Note
   * that this is content version dependent: make sure you have the latest version of
   * content before trying to use these properties.
   */
  int nodeIndex;
  /**
   * The hash identifier for the node, which unfortunately is also content version
   * dependent but can be (and ideally, should be) used instead of the nodeIndex to
   * uniquely identify the node.
   *
   * The two exist side-by-side for backcompat reasons due to the Great Talent Node
   * Restructuring of Destiny 1, and I ran out of time to remove one of them and
   * standardize on the other. Sorry!
   */
  int nodeHash;
  /**
   * The visual "row" where the node should be shown in the UI. If negative, then the
   * node is hidden.
   */
  int row;
  /**
   * The visual "column" where the node should be shown in the UI. If negative, the
   * node is hidden.
   */
  int column;
  /**
   * Indexes into the DestinyTalentGridDefinition.nodes property for any nodes that
   * must be activated before this one is allowed to be activated.
   *
   * I would have liked to change this to hashes for Destiny 2, but we have run out
   * of time.
   */
  List<int> prerequisiteNodeIndexes;
  /**
   * At one point, Talent Nodes supported the idea of "Binary Pairs": nodes that
   * overlapped each other visually, and where activating one deactivated the other.
   * They ended up not being used, mostly because Exclusive Sets are *almost* a
   * superset of this concept, but the potential for it to be used still exists in
   * theory.
   *
   * If this is ever used, this will be the index into the
   * DestinyTalentGridDefinition.nodes property for the node that is the binary pair
   * match to this node. Activating one deactivates the other.
   */
  int binaryPairNodeIndex;
  /**
   * If true, this node will automatically unlock when the Talent Grid's level
   * reaches the required level of the current step of this node.
   */
  bool autoUnlocks;
  /**
   * At one point, Nodes were going to be able to be activated multiple times,
   * changing the current step and potentially piling on multiple effects from the
   * previously activated steps. This property would indicate if the last step could
   * be activated multiple times.
   *
   * This is not currently used, but it isn't out of the question that this could end
   * up being used again in a theoretical future.
   */
  bool lastStepRepeats;
  /**
   * If this is true, the node's step is determined randomly rather than the first
   * step being chosen.
   */
  bool isRandom;
  /**
   * At one point, you were going to be able to repurchase talent nodes that had
   * random steps, to "re-roll" the current step of the node (and thus change the
   * properties of your item). This was to be the activation requirement for
   * performing that re-roll.
   *
   * The system still exists to do this, as far as I know, so it may yet come back
   * around!
   */
  int randomActivationRequirement;
  /**
   * If this is true, the node can be "re-rolled" to acquire a different random
   * current step. This is not used, but still exists for a theoretical future of
   * talent grids.
   */
  bool isRandomRepurchasable;
  /**
   * At this point, "steps" have been obfuscated into conceptual entities,
   * aggregating the underlying notions of "properties" and "true steps".
   *
   * If you need to know a step as it truly exists - such as when recreating Node
   * logic when processing Vendor data - you'll have to use the "realSteps" property
   * below.
   */
  List<DestinyNodeStepDefinition> steps;
  /**
   * The nodeHash values for nodes that are in an Exclusive Set with this node.
   *
   * See DestinyTalentGridDefinition.exclusiveSets for more info about exclusive sets.
   *
   * Again, note that these are nodeHashes and *not* nodeIndexes.
   */
  List<int> exclusiveWithNodeHashes;
  /**
   * If the node's step is randomly selected, this is the amount of the Talent Grid's
   * progression experience at which the progression bar for the node should be shown.
   */
  int randomStartProgressionBarAtProgression;
  /**
   * A string identifier for a custom visual layout to apply to this talent node.
   * Unfortunately, we do not have any data for rendering these custom layouts. It
   * will be up to you to interpret these strings and change your UI if you want to
   * have custom UI matching these layouts.
   */
  String layoutIdentifier;
  /**
   * As of Destiny 2, nodes can exist as part of "Exclusive Groups". These differ
   * from exclusive sets in that, within the group, many nodes can be activated. But
   * the act of activating any node in the group will cause "opposing" nodes (nodes
   * in groups that are not allowed to be activated at the same time as this group)
   * to deactivate.
   *
   * See DestinyTalentExclusiveGroup for more information on the details. This is an
   * identifier for this node's group, if it is part of one.
   */
  int groupHash;
  /**
   * Talent nodes can be associated with a piece of Lore, generally rendered in a
   * tooltip. This is the hash identifier of the lore element to show, if there is
   * one to be show.
   *
   * Mapped to DestinyLoreDefinition in the manifest.
   */
  int loreHash;
  /**
   * Comes from the talent grid node style: this identifier should be used to
   * determine how to render the node in the UI.
   */
  String nodeStyleIdentifier;
  /**
   * Comes from the talent grid node style: if true, then this node should be ignored
   * for determining whether the grid is complete.
   */
  bool ignoreForCompletion;
}

/**
 * Talent nodes have requirements that must be met before they can be activated.
 *
 * This describes the material costs, the Level of the Talent Grid's progression
 * required, and other conditional information that limits whether a talent node
 * can be activated.
 */
class DestinyNodeActivationRequirement {
  /**
   * The Progression level on the Talent Grid required to activate this node.
   *
   * See DestinyTalentGridDefinition.progressionHash for the related Progression, and
   * read DestinyProgressionDefinition's documentation to learn more about
   * Progressions.
   */
  int gridLevel;
  /**
   * The list of hash identifiers for material requirement sets: materials that are
   * required for the node to be activated. See
   * DestinyMaterialRequirementSetDefinition for more information about material
   * requirements.
   *
   * In this case, only a single DestinyMaterialRequirementSetDefinition will be
   * chosen from this list, and we won't know which one will be chosen until an
   * instance of the item is created.
   *
   * Mapped to DestinyMaterialRequirementSetDefinition in the manifest.
   */
  List<int> materialRequirementHashes;
}

/**
 * This defines the properties of a "Talent Node Step". When you see a talent node
 * in game, the actual visible properties that you see (its icon, description, the
 * perks and stats it provides) are not provided by the Node itself, but rather by
 * the currently active Step on the node.
 *
 * When a Talent Node is activated, the currently active step's benefits are
 * conferred upon the item and character.
 *
 * The currently active step on talent nodes are determined when an item is first
 * instantiated. Sometimes it is random, sometimes it is more deterministic (
 * particularly when a node has only a single step).
 *
 * Note that, when dealing with Talent Node Steps, you must ensure that you have
 * the latest version of content. stepIndex and nodeStepHash - two ways of
 * identifying the step within a node - are both content version dependent, and
 * thus are subject to change between content updates.
 */
class DestinyNodeStepDefinition {
  /**
   * These are the display properties actually used to render the Talent Node. The
   * currently active step's displayProperties are shown.
   */
  int displayProperties;
  /**
   * The index of this step in the list of Steps on the Talent Node.
   *
   * Unfortunately, this is the closest thing we have to an identifier for the Step:
   * steps are not provided a content version agnostic identifier. This means that,
   * when you are dealing with talent nodes, you will need to first ensure that you
   * have the latest version of content.
   */
  int stepIndex;
  /**
   * The hash of this node step. Unfortunately, while it can be used to uniquely
   * identify the step within a node, it is also content version dependent and should
   * not be relied on without ensuring you have the latest vesion of content.
   */
  int nodeStepHash;
  /**
   * If you can interact with this node in some way, this is the localized
   * description of that interaction.
   */
  String interactionDescription;
  /** An enum representing a damage type granted by activating this step, if any. */
  int damageType;
  /**
   * If the step provides a damage type, this will be the hash identifier used to
   * look up the damage type's DestinyDamageTypeDefinition.
   *
   * Mapped to DestinyDamageTypeDefinition in the manifest.
   */
  int damageTypeHash;
  /**
   * If the step has requirements for activation (they almost always do, if nothing
   * else than for the Talent Grid's Progression to have reached a certain level),
   * they will be defined here.
   */
  int activationRequirement;
  /**
   * There was a time when talent nodes could be activated multiple times, and the
   * effects of subsequent Steps would be compounded on each other, essentially "
   * upgrading" the node. We have moved away from this, but theoretically the
   * capability still exists.
   *
   * I continue to return this in case it is used in the future: if true and this
   * step is the current step in the node, you are allowed to activate the node a
   * second time to receive the benefits of the next step in the node, which will
   * then become the active step.
   */
  bool canActivateNextStep;
  /**
   * The stepIndex of the next step in the talent node, or -1 if this is the last
   * step or if the next step to be chosen is random.
   *
   * This doesn't really matter anymore unless canActivateNextStep begins to be used
   * again.
   */
  int nextStepIndex;
  /**
   * If true, the next step to be chosen is random, and if you're allowed to activate
   * the next step. (if canActivateNextStep = true)
   */
  bool isNextStepRandom;
  /**
   * The list of hash identifiers for Perks (DestinySandboxPerkDefinition) that are
   * applied when this step is active. Perks provide a variety of benefits and
   * modifications - examine DestinySandboxPerkDefinition to learn more.
   *
   * Mapped to DestinySandboxPerkDefinition in the manifest.
   */
  List<int> perkHashes;
  /**
   * When the Talent Grid's progression reaches this value, the circular "progress
   * bar" that surrounds the talent node should be shown.
   *
   * This also indicates the lower bound of said progress bar, with the upper bound
   * being the progress required to reach activationRequirement.gridLevel. (at some
   * point I should precalculate the upper bound and put it in the definition to save
   * people time)
   */
  int startProgressionBarAtProgress;
  /**
   * When the step provides stat benefits on the item or character, this is the list
   * of hash identifiers for stats (DestinyStatDefinition) that are provided.
   *
   * Mapped to DestinyStatDefinition in the manifest.
   */
  List<int> statHashes;
  /**
   * If this is true, the step affects the item's Quality in some way. See
   * DestinyInventoryItemDefinition for more information about the meaning of Quality.
   * I already made a joke about Zen and the Art of Motorcycle Maintenance elsewhere
   * in the documentation, so I will avoid doing it again. Oops too late
   */
  bool affectsQuality;
  /**
   * In Destiny 1, the Armory's Perk Filtering was driven by a concept of
   * TalentNodeStepGroups: categorizations of talent nodes based on their
   * functionality. While the Armory isn't a BNet-facing thing for now, and the new
   * Armory will need to account for Sockets rather than Talent Nodes, this
   * categorization capability feels useful enough to still keep around.
   */
  int stepGroups;
  /**
   * If true, this step can affect the level of the item. See
   * DestinyInventoryItemDefintion for more information about item levels and their
   * effect on stats.
   */
  bool affectsLevel;
  /**
   * If this step is activated, this will be a list of information used to replace
   * socket items with new Plugs. See DestinyInventoryItemDefinition for more
   * information about sockets and plugs.
   */
  List<DestinyNodeSocketReplaceResponse> socketReplacements;
}

/**
 * All damage types that are possible in the game are defined here, along with
 * localized info and icons as needed.
 */
class DestinyDamageTypeDefinition {
  /** The description of the damage type, icon etc... */
  int displayProperties;
  /** A variant of the icon that is transparent and colorless. */
  String transparentIconPath;
  /**
   * If TRUE, the game shows this damage type's icon. Otherwise, it doesn't. Whether
   * you show it or not is up to you.
   */
  bool showIcon;
  /**
   * We have an enumeration for damage types for quick reference. This is the current
   * definition's damage type enum value.
   */
  int enumValue;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * This is a bit of an odd duck. Apparently, if talent nodes steps have this data,
 * the game will go through on step activation and alter the first Socket it finds
 * on the item that has a type matching the given socket type, inserting the
 * indicated plug item.
 */
class DestinyNodeSocketReplaceResponse {
  /**
   * The hash identifier of the socket type to find amidst the item's sockets (the
   * item to which this talent grid is attached). See DestinyInventoryItemDefinition.
   * sockets.socketEntries to find the socket type of sockets on the item in question.
   *
   * Mapped to DestinySocketTypeDefinition in the manifest.
   */
  int socketTypeHash;
  /**
   * The hash identifier of the plug item that will be inserted into the socket found.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int plugItemHash;
}

/**
 * The list of indexes into the Talent Grid's "nodes" property for nodes in this
 * exclusive set. (See DestinyTalentNodeDefinition.nodeIndex)
 */
class DestinyTalentNodeExclusiveSetDefinition {
  /**
   * The list of node indexes for the exclusive set. Historically, these were indexes.
   * I would have liked to replace this with nodeHashes for consistency, but it's
   * way too late for that. (9:09 PM, he's right!)
   */
  List<int> nodeIndexes;
}

/**
 * As of Destiny 2, nodes can exist as part of "Exclusive Groups". These differ
 * from exclusive sets in that, within the group, many nodes can be activated. But
 * the act of activating any node in the group will cause "opposing" nodes (nodes
 * in groups that are not allowed to be activated at the same time as this group)
 * to deactivate.
 */
class DestinyTalentExclusiveGroup {
  /**
   * The identifier for this exclusive group. Only guaranteed unique within the
   * talent grid, not globally.
   */
  int groupHash;
  /**
   * If this group has an associated piece of lore to show next to it, this will be
   * the identifier for that DestinyLoreDefinition.
   *
   * Mapped to DestinyLoreDefinition in the manifest.
   */
  int loreHash;
  /**
   * A quick reference of the talent nodes that are part of this group, by their
   * Talent Node hashes. (See DestinyTalentNodeDefinition.nodeHash)
   */
  List<int> nodeHashes;
  /**
   * A quick reference of Groups whose nodes will be deactivated if any node in this
   * group is activated.
   */
  List<int> opposingGroupHashes;
  /**
   * A quick reference of Nodes that will be deactivated if any node in this group is
   * activated, by their Talent Node hashes. (See DestinyTalentNodeDefinition.
   * nodeHash)
   */
  List<int> opposingNodeHashes;
}

/**
 * An artificial construct provided by Bungie.Net, where we attempt to group talent
 * nodes by functionality.
 *
 * This is a single set of references to Talent Nodes that share a common trait or
 * purpose.
 */
class DestinyTalentNodeCategory {
  /**
   * Mostly just for debug purposes, but if you find it useful you can have it. This
   * is BNet's manually created identifier for this category.
   */
  String identifier;
  /**
   * If true, we found the localized content in a related DestinyLoreDefinition
   * instead of local BNet localization files. This is mostly for ease of my own
   * future investigations.
   */
  bool isLoreDriven;
  /**
   * Will contain at least the "name", which will be the title of the category. We
   * will likely not have description and an icon yet, but I'm going to keep my
   * options open.
   */
  int displayProperties;
  /**
   * The set of all hash identifiers for Talent Nodes (DestinyTalentNodeDefinition)
   * in this Talent Grid that are part of this Category.
   */
  List<int> nodeHashes;
}

/** An intrinsic perk on an item, and the requirements for it to be activated. */
class DestinyItemPerkEntryDefinition {
  /**
   * If this perk is not active, this is the string to show for why it's not
   * providing its benefits.
   */
  String requirementDisplayString;
  /**
   * A hash identifier for the DestinySandboxPerkDefinition being provided on the
   * item.
   *
   * Mapped to DestinySandboxPerkDefinition in the manifest.
   */
  int perkHash;
  /** Indicates whether this perk should be shown, or if it should be shown disabled. */
  int perkVisibility;
}

class ItemPerkVisibility {
   static const int Visible = 0;
   static const int Disabled = 1;
   static const int Hidden = 2;
}

class DestinyAnimationReference {
  String animName;
  String animIdentifier;
  String path;
}

/**
 * In an attempt to categorize items by type, usage, and other interesting
 * properties, we created DestinyItemCategoryDefinition: information about types
 * that is assembled using a set of heuristics that examine the properties of an
 * item such as what inventory bucket it's in, its item type name, and whether it
 * has or is missing certain blocks of data.
 *
 * This heuristic is imperfect, however. If you find an item miscategorized, let us
 * know on the Bungie API forums!
 *
 * We then populate all of the categories that we think an item belongs to in its
 * DestinyInventoryItemDefinition.itemCategoryHashes property. You can use that to
 * provide your own custom item filtering, sorting, aggregating... go nuts on it!
 * And let us know if you see more categories that you wish would be added!
 */
class DestinyItemCategoryDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * If True, this category should be visible in UI. Sometimes we make categories
   * that we don't think are interesting externally. It's up to you if you want to
   * skip on showing them.
   */
  bool visible;
  /**
   * If True, this category has been deprecated: it may have no items left, or there
   * may be only legacy items that remain in it which are no longer relevant to the
   * game.
   */
  bool deprecated;
  /**
   * A shortened version of the title. The reason why we have this is because the
   * Armory in German had titles that were too long to display in our UI, so these
   * were localized abbreviated versions of those categories. The property still
   * exists today, even though the Armory doesn't exist for D2... yet.
   */
  String shortTitle;
  /**
   * The janky regular expression we used against the item type to try and discern
   * whether the item belongs to this category.
   */
  String itemTypeRegex;
  /**
   * If the item is a plug, this is the identifier we expect to find associated with
   * it if it is in this category.
   */
  String plugCategoryIdentifier;
  /** If the item type matches this janky regex, it does *not* belong to this category. */
  String itemTypeRegexNot;
  /** If the item belongs to this bucket, it does belong to this category. */
  String originBucketIdentifier;
  /**
   * If an item belongs to this category, it will also receive this item type. This
   * is now how DestinyItemType is populated for items: it used to be an even jankier
   * process, but that's a story that requires more alcohol.
   */
  int grantDestinyItemType;
  /**
   * If an item belongs to this category, it will also receive this subtype enum
   * value.
   *
   * I know what you're thinking - what if it belongs to multiple categories that
   * provide sub-types?
   *
   * The last one processed wins, as is the case with all of these "grant" enums. Now
   * you can see one reason why we moved away from these enums... but they're so
   * convenient when they work, aren't they?
   */
  int grantDestinySubType;
  /**
   * If an item belongs to this category, it will also get this class restriction
   * enum value.
   *
   * See the other "grant"-prefixed properties on this definition for my color
   * commentary.
   */
  int grantDestinyClass;
  /**
   * If this category is a "parent" category of other categories, those children will
   * have their hashes listed in rendering order here, and can be looked up using
   * these hashes against DestinyItemCategoryDefinition.
   *
   * In this way, you can build up a visual hierarchy of item categories. That's what
   * we did, and you can do it too. I believe in you. Yes, you, Carl.
   *
   * (I hope someone named Carl reads this someday)
   *
   * Mapped to DestinyItemCategoryDefinition in the manifest.
   */
  List<int> groupedCategoryHashes;
  /**
   * All item category hashes of "parent" categories: categories that contain this as
   * a child through the hierarchy of groupedCategoryHashes. It's a bit redundant,
   * but having this child-centric list speeds up some calculations.
   */
  List<int> parentCategoryHashes;
  /**
   * If true, this category is only used for grouping, and should not be evaluated
   * with its own checks. Rather, the item only has this category if it has one of
   * its child categories.
   */
  bool groupCategoryOnly;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinyItemType {
   static const int None = 0;
   static const int Currency = 1;
   static const int Armor = 2;
   static const int Weapon = 3;
   static const int Message = 7;
   static const int Engram = 8;
   static const int Consumable = 9;
   static const int ExchangeMaterial = 10;
   static const int MissionReward = 11;
   static const int QuestStep = 12;
   static const int QuestStepComplete = 13;
   static const int Emblem = 14;
   static const int Quest = 15;
   static const int Subclass = 16;
   static const int ClanBanner = 17;
   static const int Aura = 18;
   static const int Mod = 19;
   static const int Dummy = 20;
   static const int Ship = 21;
   static const int Vehicle = 22;
   static const int Emote = 23;
   static const int Ghost = 24;
   static const int Package = 25;
   static const int Bounty = 26;
}

class DestinyClass {
   static const int Titan = 0;
   static const int Hunter = 1;
   static const int Warlock = 2;
   static const int Unknown = 3;
}

class SpecialItemType {
   static const int None = 0;
   static const int SpecialCurrency = 1;
   static const int Armor = 8;
   static const int Weapon = 9;
   static const int Engram = 23;
   static const int Consumable = 24;
   static const int ExchangeMaterial = 25;
   static const int MissionReward = 27;
   static const int Currency = 29;
}

class DestinyComponentType {
   static const int None = 0;
  /**
   * Profiles is the most basic component, only relevant when calling GetProfile.
   * This returns basic information about the profile, which is almost nothing: a
   * list of characterIds, some information about the last time you logged in, and
   * that most sobering statistic: how long you've played.
   */
   static const int Profiles = 100;
  /**
   * Only applicable for GetProfile, this will return information about receipts for
   * refundable vendor items.
   */
   static const int VendorReceipts = 101;
  /**
   * Asking for this will get you the profile-level inventories, such as your Vault
   * buckets (yeah, the Vault is really inventory buckets located on your Profile)
   */
   static const int ProfileInventories = 102;
  /**
   * This will get you a summary of items on your Profile that we consider to be "
   * currencies", such as Glimmer. I mean, if there's Glimmer in Destiny 2. I didn't
   * say there was Glimmer.
   */
   static const int ProfileCurrencies = 103;
  /**
   * This will get you any progression-related information that exists on a Profile-
   * wide level, across all characters.
   */
   static const int ProfileProgression = 104;
  /** This will get you summary info about each of the characters in the profile. */
   static const int Characters = 200;
  /**
   * This will get you information about any non-equipped items on the character or
   * character(s) in question, if you're allowed to see it. You have to either be
   * authenticated as that user, or that user must allow anonymous viewing of their
   * non-equipped items in Bungie.Net settings to actually get results.
   */
   static const int CharacterInventories = 201;
  /**
   * This will get you information about the progression (faction, experience, etc...
   * "levels") relevant to each character, if you are the currently authenticated
   * user or the user has elected to allow anonymous viewing of its progression info.
   */
   static const int CharacterProgressions = 202;
  /**
   * This will get you just enough information to be able to render the character in
   * 3D if you have written a 3D rendering library for Destiny Characters, or "
   * borrowed" ours. It's okay, I won't tell anyone if you're using it. I'm no snitch.
   * (actually, we don't care if you use it - go to town)
   */
   static const int CharacterRenderData = 203;
  /**
   * This will return info about activities that a user can see and gating on it, if
   * you are the currently authenticated user or the user has elected to allow
   * anonymous viewing of its progression info. Note that the data returned by this
   * can be unfortunately problematic and relatively unreliable in some cases. We'll
   * eventually work on making it more consistently reliable.
   */
   static const int CharacterActivities = 204;
  /**
   * This will return info about the equipped items on the character(s). Everyone can
   * see this.
   */
   static const int CharacterEquipment = 205;
  /**
   * This will return basic info about instanced items - whether they can be equipped,
   * their tracked status, and some info commonly needed in many places (current
   * damage type, primary stat value, etc)
   */
   static const int ItemInstances = 300;
  /**
   * Items can have Objectives (DestinyObjectiveDefinition) bound to them. If they do,
   * this will return info for items that have such bound objectives.
   */
   static const int ItemObjectives = 301;
  /**
   * Items can have perks (DestinyPerkDefinition). If they do, this will return info
   * for what perks are active on items.
   */
   static const int ItemPerks = 302;
  /**
   * If you just want to render the weapon, this is just enough info to do that
   * rendering.
   */
   static const int ItemRenderData = 303;
  /**
   * Items can have stats, like rate of fire. Asking for this component will return
   * requested item's stats if they have stats.
   */
   static const int ItemStats = 304;
  /**
   * Items can have sockets, where plugs can be inserted. Asking for this component
   * will return all info relevant to the sockets on items that have them.
   */
   static const int ItemSockets = 305;
  /**
   * Items can have talent grids, though that matters a lot less frequently than it
   * used to. Asking for this component will return all relevant info about activated
   * Nodes and Steps on this talent grid, like the good ol' days.
   */
   static const int ItemTalentGrids = 306;
  /**
   * Items that *aren't* instanced still have important information you need to know:
   * how much of it you have, the itemHash so you can look up their
   * DestinyInventoryItemDefinition, whether they're locked, etc... Both instanced
   * and non-instanced items will have these properties. You will get this
   * automatically with Inventory components - you only need to pass this when
   * calling GetItem on a specific item.
   */
   static const int ItemCommonData = 307;
  /**
   * Items that are "Plugs" can be inserted into sockets. This returns statuses about
   * those plugs and why they can/can't be inserted. I hear you giggling, there's
   * nothing funny about inserting plugs. Get your head out of the gutter and pay
   * attention!
   */
   static const int ItemPlugStates = 308;
  /**
   * When obtaining vendor information, this will return summary information about
   * the Vendor or Vendors being returned.
   */
   static const int Vendors = 400;
  /**
   * When obtaining vendor information, this will return information about the
   * categories of items provided by the Vendor.
   */
   static const int VendorCategories = 401;
  /**
   * When obtaining vendor information, this will return the information about items
   * being sold by the Vendor.
   */
   static const int VendorSales = 402;
  /**
   * Asking for this component will return you the account's Kiosk statuses: that is,
   * what items have been filled out/acquired. But only if you are the currently
   * authenticated user or the user has elected to allow anonymous viewing of its
   * progression info.
   */
   static const int Kiosks = 500;
  /**
   * A "shortcut" component that will give you all of the item hashes/quantities of
   * items that the requested character can use to determine if an action (purchasing,
   * socket insertion) has the required currency. (recall that all currencies are
   * just items, and that some vendor purchases require items that you might not
   * traditionally consider to be a "currency", like plugs/mods!)
   */
   static const int CurrencyLookups = 600;
  /**
   * Returns summary status information about all "Presentation Nodes". See
   * DestinyPresentationNodeDefinition for more details, but the gist is that these
   * are entities used by the game UI to bucket Collectibles and Records into a
   * hierarchy of categories. You may ask for and use this data if you want to
   * perform similar bucketing in your own UI: or you can skip it and roll your own.
   */
   static const int PresentationNodes = 700;
  /**
   * Returns summary status information about all "Collectibles". These are records
   * of what items you've discovered while playing Destiny, and some other basic
   * information. For detailed information, you will have to call a separate endpoint
   * devoted to the purpose.
   */
   static const int Collectibles = 800;
  /**
   * Returns summary status information about all "Records" (also known in the game
   * as "Triumphs". I know, it's confusing because there's also "Moments of Triumph"
   * that will themselves be represented as "Triumphs.")
   */
   static const int Records = 900;
}

class DestinyItemTransferRequest {
  int itemReferenceHash;
  int stackSize;
  bool transferToVault;
  String itemId;
  String characterId;
  BungieMembershipType membershipType;
}

class DestinyPostmasterTransferRequest {
  int itemReferenceHash;
  int stackSize;
  String itemId;
  String characterId;
  BungieMembershipType membershipType;
}

class DestinyItemActionRequest {
  String itemId;
  String characterId;
  BungieMembershipType membershipType;
}

class DestinyItemSetActionRequest {
  List<String> itemIds;
  String characterId;
  BungieMembershipType membershipType;
}

class DestinyItemStateRequest {
  bool state;
  String itemId;
  String characterId;
  BungieMembershipType membershipType;
}

class DestinyInsertPlugsActionRequest {
  /** Action token provided by the AwaGetActionToken API call. */
  String actionToken;
  /**
   * The instance ID of the item having a plug inserted. Only instanced items can
   * have sockets.
   */
  String itemInstanceId;
  /** The plugs being inserted. */
  int plug;
  String characterId;
  BungieMembershipType membershipType;
}

/**
 * If you want to report a player causing trouble in a game, this request will let
 * you report that player and the specific PGCR in which the trouble was caused,
 * along with why.
 *
 * Please don't do this just because you dislike the person! I mean, I know people
 * will do it anyways, but can you like take a good walk, or put a curse on them or
 * something? Do me a solid and reconsider.
 *
 * Note that this request object doesn't have the actual PGCR ID nor your Account/
 * Character ID in it. We will infer that information from your authentication
 * information and the PGCR ID that you pass into the URL of the reporting endpoint
 * itself.
 */
class DestinyReportOffensePgcrRequest {
  /**
   * So you've decided to report someone instead of cursing them and their
   * descendants. Well, okay then. This is the category or categorie(s) of
   * infractions for which you are reporting the user. These are hash identifiers
   * that map to DestinyReportReasonCategoryDefinition entries.
   *
   * Mapped to DestinyReportReasonCategoryDefinition in the manifest.
   */
  List<int> reasonCategoryHashes;
  /**
   * If applicable, provide a more specific reason(s) within the general category of
   * problems provided by the reasonHash. This is also an identifier for a reason.
   * All reasonHashes provided must be children of at least one the
   * reasonCategoryHashes provided.
   */
  List<int> reasonHashes;
  /**
   * Within the PGCR provided when calling the Reporting endpoint, this should be the
   * character ID of the user that you thought was violating terms of use. They must
   * exist in the PGCR provided.
   */
  String offendingCharacterId;
}

class DestinyStatsGroupType {
   static const int None = 0;
   static const int General = 1;
   static const int Weapons = 2;
   static const int Medals = 3;
  /**
   * This is purely to serve as the dividing line between filterable and un-
   * filterable groups. Below this number is a group you can pass as a filter. Above
   * it are groups used in very specific circumstances and not relevant for filtering.
   */
   static const int ReservedGroups = 100;
  /** Only applicable while generating leaderboards. */
   static const int Leaderboard = 101;
  /** These will *only* be consumed by GetAggregateStatsByActivity */
   static const int Activity = 102;
  /** These are only consumed and returned by GetUniqueWeaponHistory */
   static const int UniqueWeapon = 103;
   static const int Internal = 104;
}

class PeriodType {
   static const int None = 0;
   static const int Daily = 1;
   static const int AllTime = 2;
   static const int Activity = 3;
}

class AwaPermissionRequested {
  /** Type of advanced write action. */
  int type;
  /**
   * Item instance ID the action shall be applied to. This is optional for all but a
   * new AwaType values. Rule of thumb is to provide the item instance ID if one is
   * available.
   */
  String affectedItemId;
  /** Destiny membership type of the account to modify. */
  int membershipType;
  /** Destiny character ID, if applicable, that will be affected by the action. */
  String characterId;
}

class AwaUserResponse {
  /** Indication of the selection the user has made (Approving or rejecting the action) */
  int selection;
  /** Correlation ID of the request */
  String correlationId;
  /** Secret nonce received via the PUSH notification. */
  List<int> nonce;
}

/**
 * DestinyManifest is the external-facing contract for just the properties needed
 * by those calling the Destiny Platform.
 */
class DestinyManifest {
  String version;
  String mobileAssetContentPath;
  List<GearAssetDataBaseDefinition> mobileGearAssetDataBases;
  Map<String, String> mobileWorldContentPaths;
  String mobileClanBannerDatabasePath;
  Map<String, String> mobileGearCDN;
}

class GearAssetDataBaseDefinition {
  int version;
  String path;
}

/** Provides common properties for destiny definitions. */
class DestinyDefinition {
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * I know what you seek. You seek linked accounts. Found them, you have.
 *
 * This contract returns a minimal amount of data about Destiny Accounts that are
 * linked through your Bungie.Net account. We will not return accounts in this
 * response whose
 */
class DestinyLinkedProfilesResponse {
  /**
   * Any Destiny account for whom we could successfully pull characters will be
   * returned here, as the Platform-level summary of user data. (no character data,
   * no Destiny account data other than the Membership ID and Type so you can make
   * further queries)
   */
  List<UserInfoCard> profiles;
  /**
   * If the requested membership had a linked Bungie.Net membership ID, this is the
   * basic information about that BNet account.
   *
   * I know, Tetron; I know this is mixing UserServices concerns with DestinyServices
   * concerns. But it's so damn convenient! https://www.youtube.com/watch?v=X5R-bB-
   * gKVI
   */
  int bnetMembership;
  /**
   * This is brief summary info for profiles that we believe have valid Destiny info,
   * but who failed to return data for some other reason and thus we know that
   * subsequent calls for their info will also fail.
   */
  List<DestinyErrorProfile> profilesWithErrors;
}

/**
 * If a Destiny Profile can't be returned, but we're pretty certain it's a valid
 * Destiny account, this will contain as much info as we can get about the profile
 * for your use.
 *
 * Assume that the most you'll get is the Error Code, the Membership Type and the
 * Membership ID.
 */
class DestinyErrorProfile {
  /**
   * The error that we encountered. You should be able to look up localized text to
   * show to the user for these failures.
   */
  int errorCode;
  /**
   * Basic info about the account that failed. Don't expect anything other than
   * membership ID, Membership Type, and displayName to be populated.
   */
  int infoCard;
}

/**
 * The response for GetDestinyProfile, with components for character and item-level
 * data.
 */
class DestinyProfileResponse {
  /**
   * Recent, refundable purchases you have made from vendors. When will you use it?
   * Couldn't say...
   *
   * COMPONENT TYPE: VendorReceipts
   */
  int vendorReceipts;
  /**
   * The profile-level inventory of the Destiny Profile.
   *
   * COMPONENT TYPE: ProfileInventories
   */
  int profileInventory;
  /**
   * The profile-level currencies owned by the Destiny Profile.
   *
   * COMPONENT TYPE: ProfileCurrencies
   */
  int profileCurrencies;
  /**
   * The basic information about the Destiny Profile (formerly "Account").
   *
   * COMPONENT TYPE: Profiles
   */
  int profile;
  /**
   * Items available from Kiosks that are available Profile-wide (i.e. across all
   * characters)
   *
   * This component returns information about what Kiosk items are available to you
   * on a *Profile* level. It is theoretically possible for Kiosks to have items
   * gated by specific Character as well. If you ever have those, you will find them
   * on the characterKiosks property.
   *
   * COMPONENT TYPE: Kiosks
   */
  int profileKiosks;
  /**
   * When sockets refer to reusable Plug Sets (see DestinyPlugSetDefinition for more
   * info), this is the set of plugs and their states that are profile-scoped.
   *
   * This comes back with ItemSockets, as it is needed for a complete picture of the
   * sockets on requested items.
   *
   * COMPONENT TYPE: ItemSockets
   */
  int profilePlugSets;
  /**
   * When we have progression information - such as Checklists - that may apply
   * profile-wide, it will be returned here rather than in the per-character
   * progression data.
   *
   * COMPONENT TYPE: ProfileProgression
   */
  int profileProgression;
  /** COMPONENT TYPE: PresentationNodes */
  int profilePresentationNodes;
  /** COMPONENT TYPE: Records */
  int profileRecords;
  /** COMPONENT TYPE: Collectibles */
  int profileCollectibles;
  /**
   * Basic information about each character, keyed by the CharacterId.
   *
   * COMPONENT TYPE: Characters
   */
  int characters;
  /**
   * The character-level non-equipped inventory items, keyed by the Character's Id.
   *
   * COMPONENT TYPE: CharacterInventories
   */
  int characterInventories;
  /**
   * Character-level progression data, keyed by the Character's Id.
   *
   * COMPONENT TYPE: CharacterProgressions
   */
  int characterProgressions;
  /**
   * Character rendering data - a minimal set of info needed to render a character in
   * 3D - keyed by the Character's Id.
   *
   * COMPONENT TYPE: CharacterRenderData
   */
  int characterRenderData;
  /**
   * Character activity data - the activities available to this character and its
   * status, keyed by the Character's Id.
   *
   * COMPONENT TYPE: CharacterActivities
   */
  int characterActivities;
  /**
   * The character's equipped items, keyed by the Character's Id.
   *
   * COMPONENT TYPE: CharacterEquipment
   */
  int characterEquipment;
  /**
   * Items available from Kiosks that are available to a specific character as
   * opposed to the account as a whole. It must be combined with data from the
   * profileKiosks property to get a full picture of the character's available items
   * to check out of a kiosk.
   *
   * This component returns information about what Kiosk items are available to you
   * on a *Character* level. Usually, kiosk items will be earned for the entire
   * Profile (all characters) at once. To find those, look in the profileKiosks
   * property.
   *
   * COMPONENT TYPE: Kiosks
   */
  int characterKiosks;
  /**
   * When sockets refer to reusable Plug Sets (see DestinyPlugSetDefinition for more
   * info), this is the set of plugs and their states, per character, that are
   * character-scoped.
   *
   * This comes back with ItemSockets, as it is needed for a complete picture of the
   * sockets on requested items.
   *
   * COMPONENT TYPE: ItemSockets
   */
  int characterPlugSets;
  /**
   * Do you ever get the feeling that a system was designed *too* flexibly? That it
   * can be used in so many different ways that you end up being unable to provide an
   * easy to use abstraction for the mess that's happening under the surface?
   *
   * Let's talk about character-specific data that might be related to items without
   * instances. These two statements are totally unrelated, I promise.
   *
   * At some point during D2, it was decided that items - such as Bounties - could be
   * given to characters and *not* have instance data, but that *could* display and
   * even use relevant state information on your account and character.
   *
   * Up to now, any item that had meaningful dependencies on character or account
   * state had to be instanced, and thus "itemComponents" was all that you needed: it
   * was keyed by item's instance IDs and provided the stateful information you
   * needed inside.
   *
   * Unfortunately, we don't live in such a magical world anymore. This is
   * information held on a per-character basis about non-instanced items that the
   * characters have in their inventory - or that reference character-specific state
   * information even if it's in Account-level inventory - and the values related to
   * that item's state in relation to the given character.
   *
   * To give a concrete example, look at a Moments of Triumph bounty. They exist in a
   * character's inventory, and show/care about a character's progression toward
   * completing the bounty. But the bounty itself is a non-instanced item, like a mod
   * or a currency. This returns that data for the characters who have the bounty in
   * their inventory.
   *
   * I'm not crying, you're crying Okay we're both crying but it's going to be okay I
   * promise Actually I shouldn't promise that, I don't know if it's going to be okay
   */
  Map<String, DestinyBaseItemComponentSetOfuint32> characterUninstancedItemComponents;
  /** COMPONENT TYPE: PresentationNodes */
  int characterPresentationNodes;
  /** COMPONENT TYPE: Records */
  int characterRecords;
  /** COMPONENT TYPE: Collectibles */
  int characterCollectibles;
  /**
   * Information about instanced items across all returned characters, keyed by the
   * item's instance ID.
   *
   * COMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component
   * types.]
   */
  int itemComponents;
  /**
   * A "lookup" convenience component that can be used to quickly check if the
   * character has access to items that can be used for purchasing.
   *
   * COMPONENT TYPE: CurrencyLookups
   */
  int characterCurrencyLookups;
}

/**
 * For now, this isn't used for much: it's a record of the recent refundable
 * purchases that the user has made. In the future, it could be used for providing
 * refunds/buyback via the API. Wouldn't that be fun?
 */
class DestinyVendorReceiptsComponent {
  /** The receipts for refundable purchases made at a vendor. */
  List<DestinyVendorReceipt> receipts;
}

/**
 * If a character purchased an item that is refundable, a Vendor Receipt will be
 * created on the user's Destiny Profile. These expire after a configurable period
 * of time, but until then can be used to get refunds on items. BNet does not
 * provide the ability to refund a purchase *yet*, but you know.
 */
class DestinyVendorReceipt {
  /**
   * The amount paid for the item, in terms of items that were consumed in the
   * purchase and their quantity.
   */
  List<DestinyItemQuantity> currencyPaid;
  /** The item that was received, and its quantity. */
  int itemReceived;
  /** The unlock flag used to determine whether you still have the purchased item. */
  int licenseUnlockHash;
  /** The ID of the character who made the purchase. */
  String purchasedByCharacterId;
  /**
   * Whether you can get a refund, and what happens in order for the refund to be
   * received. See the DestinyVendorItemRefundPolicy enum for details.
   */
  int refundPolicy;
  /** The identifier of this receipt. */
  int sequenceNumber;
  /** The seconds since epoch at which this receipt is rendered invalid. */
  String timeToExpiration;
  /** The date at which this receipt is rendered invalid. */
  String expiresOn;
}

class ComponentPrivacySetting {
   static const int None = 0;
   static const int Public = 1;
   static const int Private = 2;
}

/**
 * A list of minimal information for items in an inventory: be it a character's
 * inventory, or a Profile's inventory. (Note that the Vault is a collection of
 * inventory buckets in the Profile's inventory)
 *
 * Inventory Items returned here are in a flat list, but importantly they have a
 * bucketHash property that indicates the specific inventory bucket that is holding
 * them. These buckets constitute things like the separate sections of the Vault,
 * the user's inventory slots, etc. See DestinyInventoryBucketDefinition for more
 * info.
 */
class DestinyInventoryComponent {
  /**
   * The items in this inventory. If you care to bucket them, use the item's
   * bucketHash property to group them.
   */
  List<DestinyItemComponent> items;
}

/**
 * The base item component, filled with properties that are generally useful to
 * know in any item request or that don't feel worthwhile to put in their own
 * component.
 */
class DestinyItemComponent {
  /**
   * The identifier for the item's definition, which is where most of the useful
   * static information for the item can be found.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int itemHash;
  /**
   * If the item is instanced, it will have an instance ID. Lack of an instance ID
   * implies that the item has no distinct local qualities aside from stack size.
   */
  String itemInstanceId;
  /**
   * The quantity of the item in this stack. Note that Instanced items cannot stack.
   * If an instanced item, this value will always be 1 (as the stack has exactly one
   * item in it)
   */
  int quantity;
  /** If the item is bound to a location, it will be specified in this enum. */
  int bindStatus;
  /**
   * An easy reference for where the item is located. Redundant if you got the item
   * from an Inventory, but useful when making detail calls on specific items.
   */
  int location;
  /**
   * The hash identifier for the specific inventory bucket in which the item is
   * located.
   *
   * Mapped to DestinyInventoryBucketDefinition in the manifest.
   */
  int bucketHash;
  /**
   * If there is a known error state that would cause this item to not be
   * transferable, this Flags enum will indicate all of those error states. Otherwise,
   * it will be 0 (CanTransfer).
   */
  int transferStatus;
  /** If the item can be locked, this will indicate that state. */
  bool lockable;
  /**
   * A flags enumeration indicating the transient/custom states of the item that
   * affect how it is rendered: whether it's tracked or locked for example, or
   * whether it has a masterwork plug inserted.
   */
  int state;
  /**
   * If populated, this is the hash of the item whose icon (and other secondary
   * styles, but *not* the human readable strings) should override whatever icons/
   * styles are on the item being sold.
   *
   * If you don't do this, certain items whose styles are being overridden by
   * socketed items - such as the "Recycle Shader" item - would show whatever their
   * default icon/style is, and it wouldn't be pretty or look accurate.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int overrideStyleItemHash;
  /** If the item can expire, this is the date at which it will/did expire. */
  String expirationDate;
}

class ItemBindStatus {
   static const int NotBound = 0;
   static const int BoundToCharacter = 1;
   static const int BoundToAccount = 2;
   static const int BoundToGuild = 3;
}

class TransferStatuses {
  /** The item can be transferred. */
   static const int CanTransfer = 0;
  /** You can't transfer the item because it is equipped on a character. */
   static const int ItemIsEquipped = 1;
  /**
   * The item is defined as not transferrable in its DestinyInventoryItemDefinition.
   * nonTransferrable property.
   */
   static const int NotTransferrable = 2;
  /**
   * You could transfer the item, but the place you're trying to put it has run out
   * of room! Check your remaining Vault and/or character space.
   */
   static const int NoRoomInDestination = 4;
}

class ItemState {
   static const int None = 0;
  /**
   * If this bit is set, the item has been "locked" by the user and cannot be deleted.
   * You may want to represent this visually with a "lock" icon.
   */
   static const int Locked = 1;
  /**
   * If this bit is set, the item is a quest that's being tracked by the user. You
   * may want a visual indicator to show that this is a tracked quest.
   */
   static const int Tracked = 2;
  /**
   * If this bit is set, the item has a Masterwork plug inserted. This usually
   * coincides with having a special "glowing" effect applied to the item's icon.
   */
   static const int Masterwork = 4;
}

/**
 * The most essential summary information about a Profile (in Destiny 1, we called
 * these "Accounts").
 */
class DestinyProfileComponent {
  /**
   * If you need to render the Profile (their platform name, icon, etc...) somewhere,
   * this property contains that information.
   */
  int userInfo;
  /** The last time the user played with any character on this Profile. */
  String dateLastPlayed;
  /** If you want to know what expansions they own, this will contain that data. */
  int versionsOwned;
  /** A list of the character IDs, for further querying on your part. */
  List<String> characterIds;
}

class DestinyGameVersions {
   static const int None = 0;
   static const int Destiny2 = 1;
   static const int DLC1 = 2;
   static const int DLC2 = 4;
   static const int Forsaken = 8;
}

/**
 * A Kiosk is a Vendor (DestinyVendorDefinition) that sells items based on whether
 * you have already acquired that item before.
 *
 * This component returns information about what Kiosk items are available to you
 * on a *Profile* level. It is theoretically possible for Kiosks to have items
 * gated by specific Character as well. If you ever have those, you will find them
 * on the individual character's DestinyCharacterKiosksComponent.
 *
 * Note that, because this component returns vendorItemIndexes (that is to say,
 * indexes into the Kiosk Vendor's itemList property), these results are
 * necessarily content version dependent. Make sure that you have the latest
 * version of the content manifest databases before using this data.
 */
class DestinyKiosksComponent {
  /**
   * A dictionary keyed by the Kiosk Vendor's hash identifier (use it to look up the
   * DestinyVendorDefinition for the relevant kiosk vendor), and whose value is a
   * list of all the items that the user can "see" in the Kiosk, and any other
   * interesting metadata.
   *
   * Mapped to DestinyVendorDefinition in the manifest.
   */
  Map<int, List<DestinyKioskItem>> kioskItems;
}

class DestinyKioskItem {
  /**
   * The index of the item in the related DestinyVendorDefintion's itemList property,
   * representing the sale.
   */
  int index;
  /**
   * If true, the user can not only see the item, but they can acquire it. It is
   * possible that a user can see a kiosk item and not be able to acquire it.
   */
  bool canAcquire;
  /**
   * Indexes into failureStrings for the Vendor, indicating the reasons why it failed
   * if any.
   */
  List<int> failureIndexes;
  /**
   * I may regret naming it this way - but this represents when an item has an
   * objective that doesn't serve a beneficial purpose, but rather is used for "
   * flavor" or additional information. For instance, when Emblems track specific
   * stats, those stats are represented as Objectives on the item.
   */
  int flavorObjective;
}

/**
 * Returns data about a character's status with a given Objective. Combine with
 * DestinyObjectiveDefinition static data for display purposes.
 */
class DestinyObjectiveProgress {
  /**
   * The unique identifier of the Objective being referred to. Use to look up the
   * DestinyObjectiveDefinition in static data.
   *
   * Mapped to DestinyObjectiveDefinition in the manifest.
   */
  int objectiveHash;
  /**
   * If the Objective has a Destination associated with it, this is the unique
   * identifier of the Destination being referred to. Use to look up the
   * DestinyDestinationDefinition in static data. This will give localized data about
   * *where* in the universe the objective should be achieved.
   *
   * Mapped to DestinyDestinationDefinition in the manifest.
   */
  int destinationHash;
  /**
   * If the Objective has an Activity associated with it, this is the unique
   * identifier of the Activity being referred to. Use to look up the
   * DestinyActivityDefinition in static data. This will give localized data about *
   * what* you should be playing for the objective to be achieved.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int activityHash;
  /**
   * If progress has been made, and the progress can be measured numerically, this
   * will be the value of that progress. You can compare it to the
   * DestinyObjectiveDefinition.completionValue property for current vs. upper bounds,
   * and use DestinyObjectiveDefinition.valueStyle to determine how this should be
   * rendered. Note that progress, in Destiny 2, need not be a literal numeric
   * progression. It could be one of a number of possible values, even a Timestamp.
   * Always examine DestinyObjectiveDefinition.valueStyle before rendering progress.
   */
  int progress;
  /**
   * As of Forsaken, objectives' completion value is determined dynamically at
   * runtime.
   *
   * This value represents the threshold of progress you need to surpass in order for
   * this objective to be considered "complete".
   *
   * If you were using objective data, switch from using the
   * DestinyObjectiveDefinition's "completionValue" to this value.
   */
  int completionValue;
  /** Whether or not the Objective is completed. */
  bool complete;
  /**
   * If this is true, the objective is visible in-game. Otherwise, it's not yet
   * visible to the player. Up to you if you want to honor this property.
   */
  bool visible;
}

/**
 * Sockets may refer to a "Plug Set": a set of reusable plugs that may be shared
 * across multiple sockets (or even, in theory, multiple sockets over multiple
 * items).
 *
 * This is the set of those plugs that we came across in the users' inventory,
 * along with the values for plugs in the set. Any given set in this component may
 * be represented in Character and Profile-level, as some plugs may be Profile-
 * level restricted, and some character-level restricted. (note that the ones that
 * are even more specific will remain on the actual socket component itself, as
 * they cannot be reused)
 */
class DestinyPlugSetsComponent {
  /**
   * The shared list of plugs for each relevant PlugSet, keyed by the hash identifier
   * of the PlugSet (DestinyPlugSetDefinition).
   *
   * Mapped to DestinyPlugSetDefinition in the manifest.
   */
  Map<int, List<DestinyItemPlug>> plugs;
}

class DestinyItemPlug {
  /**
   * The hash identifier of the DestinyInventoryItemDefinition that represents this
   * plug.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int plugItemHash;
  /**
   * Sometimes, Plugs may have objectives: these are often used for flavor and
   * display purposes, but they can be used for any arbitrary purpose (both
   * fortunately and unfortunately). Recently (with Season 2) they were expanded in
   * use to be used as the "gating" for whether the plug can be inserted at all. For
   * instance, a Plug might be tracking the number of PVP kills you have made. It
   * will use the parent item's data about that tracking status to determine what to
   * show, and will generally show it using the DestinyObjectiveDefinition's
   * progressDescription property. Refer to the plug's itemHash and objective
   * property for more information if you would like to display even more data.
   */
  List<DestinyObjectiveProgress> plugObjectives;
  /** If true, this plug has met all of its insertion requirements. Big if true. */
  bool canInsert;
  /** If true, this plug will provide its benefits while inserted. */
  bool enabled;
  /**
   * If the plug cannot be inserted for some reason, this will have the indexes into
   * the plug item definition's plug.insertionRules property, so you can show the
   * reasons why it can't be inserted.
   *
   * This list will be empty if the plug can be inserted.
   */
  List<int> insertFailIndexes;
  /**
   * If a plug is not enabled, this will be populated with indexes into the plug item
   * definition's plug.enabledRules property, so that you can show the reasons why it
   * is not enabled.
   *
   * This list will be empty if the plug is enabled.
   */
  List<int> enableFailIndexes;
}

/**
 * Sometimes, we have large sets of reusable plugs that are defined identically and
 * thus can (and in some cases, are so large that they *must*) be shared across the
 * places where they are used. These are the definitions for those reusable sets of
 * plugs.
 *
 * See DestinyItemSocketEntryDefinition.plugSource and reusablePlugSetHash for the
 * relationship between these reusable plug sets and the sockets that leverage them
 * (for starters, Emotes).
 */
class DestinyPlugSetDefinition {
  /**
   * If you want to show these plugs in isolation, these are the display properties
   * for them.
   */
  int displayProperties;
  /**
   * This is a list of pre-determined plugs that can be plugged into this socket,
   * without the character having the plug in their inventory.
   *
   * If this list is populated, you will not be allowed to plug an arbitrary item in
   * the socket: you will only be able to choose from one of these reusable plugs.
   */
  List<DestinyItemSocketEntryPlugItemDefinition> reusablePlugItems;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * The set of progression-related information that applies at a Profile-wide level
 * for your Destiny experience. This differs from the Jimi Hendrix Experience
 * because there's less guitars on fire. Yet. #spoileralert?
 *
 * This will include information such as Checklist info.
 */
class DestinyProfileProgressionComponent {
  /**
   * The set of checklists that can be examined on a profile-wide basis, keyed by the
   * hash identifier of the Checklist (DestinyChecklistDefinition)
   *
   * For each checklist returned, its value is itself a Dictionary keyed by the
   * checklist's hash identifier with the value being a boolean indicating if it's
   * been discovered yet.
   *
   * Mapped to DestinyChecklistDefinition in the manifest.
   */
  Map<int, Map<int, bool>> checklists;
}

/**
 * By public demand, Checklists are loose sets of "things to do/things you have
 * done" in Destiny that we were actually able to track. They include easter eggs
 * you find in the world, unique chests you unlock, and other such data where the
 * first time you do it is significant enough to be tracked, and you have the
 * potential to "get them all".
 *
 * These may be account-wide, or may be per character. The status of these will be
 * returned in related "Checklist" data coming down from API requests such as
 * GetProfile or GetCharacter.
 *
 * Generally speaking, the items in a checklist can be completed in any order: we
 * return an ordered list which only implies the way we are showing them in our own
 * UI, and you can feel free to alter it as you wish.
 *
 * Note that, in the future, there will be something resembling the old D1 Record
 * Books in at least some vague form. When that is created, it may be that it will
 * supercede much or all of this Checklist data. It remains to be seen if that will
 * be the case, so for now assume that the Checklists will still exist even after
 * the release of D2: Forsaken.
 */
class DestinyChecklistDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /** A localized string prompting you to view the checklist. */
  String viewActionString;
  /**
   * Indicates whether you will find this checklist on the Profile or Character
   * components.
   */
  int scope;
  /** The individual checklist items. Gotta catch 'em all. */
  List<DestinyChecklistEntryDefinition> entries;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * The properties of an individual checklist item. Note that almost everything is
 * optional: it is *highly* variable what kind of data we'll actually be able to
 * return: at times we may have no other relationships to entities at all.
 *
 * Whatever UI you build, do it with the knowledge that any given entry might not
 * actually be able to be associated with some other Destiny entity.
 */
class DestinyChecklistEntryDefinition {
  /**
   * The identifier for this Checklist entry. Guaranteed unique only within this
   * Checklist Definition, and not globally/for all checklists.
   */
  int hash;
  /**
   * Even if no other associations exist, we will give you *something* for display
   * properties. In cases where we have no associated entities, it may be as simple
   * as a numerical identifier.
   */
  int displayProperties;
  /** Mapped to DestinyDestinationDefinition in the manifest. */
  int destinationHash;
  /** Mapped to DestinyLocationDefinition in the manifest. */
  int locationHash;
  /**
   * Note that a Bubble's hash doesn't uniquely identify a "top level" entity in
   * Destiny. Only the combination of location and bubble can uniquely identify a
   * place in the world of Destiny: so if bubbleHash is populated, locationHash must
   * too be populated for it to have any meaning.
   *
   * You can use this property if it is populated to look up the
   * DestinyLocationDefinition's associated .locationReleases[].activityBubbleName
   * property.
   */
  int bubbleHash;
  /** Mapped to DestinyActivityDefinition in the manifest. */
  int activityHash;
  /** Mapped to DestinyInventoryItemDefinition in the manifest. */
  int itemHash;
  int vendorHash;
  int vendorInteractionIndex;
  /** The scope at which this specific entry can be computed. */
  int scope;
}

class DestinyPresentationNodesComponent {
  Map<int, DestinyPresentationNodeComponent> nodes;
}

class DestinyPresentationNodeComponent {
  DestinyPresentationNodeState state;
  DestinyObjectiveProgress objective;
}

class DestinyPresentationNodeState {
   static const int None = 0;
  /**
   * If this is set, the game recommends that you not show this node. But you know
   * your life, do what you've got to do.
   */
   static const int Invisible = 1;
  /** Turns out Presentation Nodes can also be obscured. If they are, this is set. */
   static const int Obscured = 2;
}

class DestinyProfileRecordsComponent {
  /** Your "Triumphs" score. */
  int score;
  /**
   * If this profile is tracking a record, this is the hash identifier of the record
   * it is tracking.
   *
   * Mapped to DestinyRecordDefinition in the manifest.
   */
  int trackedRecordHash;
  Map<int, DestinyRecordComponent> records;
}

class DestinyRecordComponent {
  DestinyRecordState state;
  List<DestinyObjectiveProgress> objectives;
}

class DestinyRecordState {
  /**
   * If there are no flags set, the record is in a state where it *could* be redeemed,
   * but it has not been yet.
   */
   static const int None = 0;
  /** If this is set, the completed record has been redeemed. */
   static const int RecordRedeemed = 1;
  /**
   * If this is set, there's a reward available from this Record but it's unavailable
   * for redemption.
   */
   static const int RewardUnavailable = 2;
  /** If this is set, the objective for this Record has not yet been completed. */
   static const int ObjectiveNotCompleted = 4;
  /**
   * If this is set, the game recommends that you replace the display text of this
   * Record with DestinyRecordDefinition.stateInfo.obscuredString.
   */
   static const int Obscured = 8;
  /**
   * If this is set, the game recommends that you not show this record. Do what you
   * will with this recommendation.
   */
   static const int Invisible = 16;
  /**
   * If this is set, you can't complete this record because you lack some permission
   * that's required to complete it.
   */
   static const int EntitlementUnowned = 32;
  /**
   * If this is set, the record has a title (check DestinyRecordDefinition for title
   * info) and you can equip it.
   */
   static const int CanEquipTitle = 64;
}

class DestinyProfileCollectiblesComponent {
  /**
   * The list of collectibles determined by the game as having been "recently"
   * acquired.
   *
   * Mapped to DestinyCollectibleDefinition in the manifest.
   */
  List<int> recentCollectibleHashes;
  /**
   * The list of collectibles determined by the game as having been "recently"
   * acquired.
   *
   * The game client itself actually controls this data, so I personally question
   * whether anyone will get much use out of this: because we can't edit this value
   * through the API. But in case anyone finds it useful, here it is.
   *
   * Mapped to DestinyCollectibleDefinition in the manifest.
   */
  List<int> newnessFlaggedCollectibleHashes;
  Map<int, DestinyCollectibleComponent> collectibles;
}

class DestinyCollectibleComponent {
  DestinyCollectibleState state;
}

class DestinyCollectibleState {
   static const int None = 0;
  /** If this flag is set, you have not yet obtained this collectible. */
   static const int NotAcquired = 1;
  /**
   * If this flag is set, the item is "obscured" to you: you can/should use the
   * alternate item hash found in DestinyCollectibleDefinition.stateInfo.
   * obscuredOverrideItemHash when displaying this collectible instead of the default
   * display info.
   */
   static const int Obscured = 2;
  /**
   * If this flag is set, the collectible should not be shown to the user.
   *
   * But, I mean do what you want: I'm not your mom. It's much more likely that I'm
   * your Dad - wait, I promised your mom that I wouldn't tell you. Don't tell her
   * that I told you.
   */
   static const int Invisible = 4;
  /**
   * If this flag is set, the collectible requires payment for creating an instance
   * of the item, and you are lacking in currency. Bring the benjamins next time. Or
   * spinmetal. Whatever.
   */
   static const int CannotAffordMaterialRequirements = 8;
  /**
   * If this flag is set, you can't pull this item out of your collection because
   * there's no room left in your inventory.
   */
   static const int InventorySpaceUnavailable = 16;
  /**
   * If this flag is set, you already have one of these items and can't have a second
   * one.
   */
   static const int UniquenessViolation = 32;
  /**
   * If this flag is set, the ability to pull this item out of your collection has
   * been disabled.
   */
   static const int PurchaseDisabled = 64;
}

/**
 * This component contains base properties of the character. You'll probably want
 * to always request this component, but hey you do you.
 */
class DestinyCharacterComponent {
  /**
   * Every Destiny Profile has a membershipId. This is provided on the character as
   * well for convenience.
   */
  String membershipId;
  /**
   * membershipType tells you the platform on which the character plays. Examine the
   * BungieMembershipType enumeration for possible values.
   */
  int membershipType;
  /** The unique identifier for the character. */
  String characterId;
  /** The last date that the user played Destiny. */
  String dateLastPlayed;
  /** If the user is currently playing, this is how long they've been playing. */
  String minutesPlayedThisSession;
  /**
   * If this value is 525,600, then they played Destiny for a year. Or they're a very
   * dedicated Rent fan. Note that this includes idle time, not just time spent
   * actually in activities shooting things.
   */
  String minutesPlayedTotal;
  /**
   * The user's calculated "Light Level". Light level is an indicator of your power
   * that mostly matters in the end game, once you've reached the maximum character
   * level: it's a level that's dependent on the average Attack/Defense power of your
   * items.
   */
  int light;
  /**
   * Your character's stats, such as Agility, Resilience, etc... *not* historical
   * stats.
   *
   * You'll have to call a different endpoint for those.
   */
  Map<int, int> stats;
  /**
   * Use this hash to look up the character's DestinyRaceDefinition.
   *
   * Mapped to DestinyRaceDefinition in the manifest.
   */
  int raceHash;
  /**
   * Use this hash to look up the character's DestinyGenderDefinition.
   *
   * Mapped to DestinyGenderDefinition in the manifest.
   */
  int genderHash;
  /**
   * Use this hash to look up the character's DestinyClassDefinition.
   *
   * Mapped to DestinyClassDefinition in the manifest.
   */
  int classHash;
  /**
   * Mostly for historical purposes at this point, this is an enumeration for the
   * character's race.
   *
   * It'll be preferable in the general case to look up the related definition: but
   * for some people this was too convenient to remove.
   */
  int raceType;
  /**
   * Mostly for historical purposes at this point, this is an enumeration for the
   * character's class.
   *
   * It'll be preferable in the general case to look up the related definition: but
   * for some people this was too convenient to remove.
   */
  int classType;
  /**
   * Mostly for historical purposes at this point, this is an enumeration for the
   * character's Gender.
   *
   * It'll be preferable in the general case to look up the related definition: but
   * for some people this was too convenient to remove. And yeah, it's an enumeration
   * and not a boolean. Fight me.
   */
  int genderType;
  /**
   * A shortcut path to the user's currently equipped emblem image. If you're just
   * showing summary info for a user, this is more convenient than examining their
   * equipped emblem and looking up the definition.
   */
  String emblemPath;
  /**
   * A shortcut path to the user's currently equipped emblem background image. If you'
   * re just showing summary info for a user, this is more convenient than examining
   * their equipped emblem and looking up the definition.
   */
  String emblemBackgroundPath;
  /**
   * The hash of the currently equipped emblem for the user. Can be used to look up
   * the DestinyInventoryItemDefinition.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int emblemHash;
  /**
   * A shortcut for getting the background color of the user's currently equipped
   * emblem without having to do a DestinyInventoryItemDefinition lookup.
   */
  int emblemColor;
  /**
   * The progression that indicates your character's level. Not their light level,
   * but their character level: you know, the thing you max out a couple hours in and
   * then ignore for the sake of light level.
   */
  int levelProgression;
  /** The "base" level of your character, not accounting for any light level. */
  int baseCharacterLevel;
  /**
   * A number between 0 and 100, indicating the whole and fractional % remaining to
   * get to the next character level.
   */
  double percentToNextLevel;
  /**
   * If this Character has a title assigned to it, this is the identifier of the
   * DestinyRecordDefinition that has that title information.
   *
   * Mapped to DestinyRecordDefinition in the manifest.
   */
  int titleRecordHash;
}

/**
 * In Destiny, "Races" are really more like "Species". Sort of. I mean, are the
 * Awoken a separate species from humans? I'm not sure. But either way, they're
 * defined here. You'll see Exo, Awoken, and Human as examples of these Species.
 * Players will choose one for their character.
 */
class DestinyRaceDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * An enumeration defining the existing, known Races/Species for player characters.
   * This value will be the enum value matching this definition.
   */
  int raceType;
  /**
   * A localized string referring to the singular form of the Race's name when
   * referred to in gendered form. Keyed by the DestinyGender.
   */
  Map<int, String> genderedRaceNames;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinyRace {
   static const int Human = 0;
   static const int Awoken = 1;
   static const int Exo = 2;
   static const int Unknown = 3;
}

/**
 * Gender is a social construct, and as such we have definitions for Genders. Right
 * now there happens to only be two, but we'll see what the future holds.
 */
class DestinyGenderDefinition {
  /**
   * This is a quick reference enumeration for all of the currently defined Genders.
   * We use the enumeration for quicker lookups in related data, like
   * DestinyClassDefinition.genderedClassNames.
   */
  int genderType;
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinyGender {
   static const int Male = 0;
   static const int Female = 1;
   static const int Unknown = 2;
}

/**
 * Defines a Character Class in Destiny 2. These are types of characters you can
 * play, like Titan, Warlock, and Hunter.
 */
class DestinyClassDefinition {
  /**
   * In Destiny 1, we added a convenience Enumeration for referring to classes. We've
   * kept it, though mostly for posterity. This is the enum value for this definition'
   * s class.
   */
  int classType;
  DestinyDisplayPropertiesDefinition displayProperties;
  /**
   * A localized string referring to the singular form of the Class's name when
   * referred to in gendered form. Keyed by the DestinyGender.
   */
  Map<int, String> genderedClassNames;
  /**
   * Mentors don't really mean anything anymore. Don't expect this to be populated.
   *
   * Mapped to DestinyVendorDefinition in the manifest.
   */
  int mentorVendorHash;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * This component returns anything that could be considered "Progression" on a user:
 * data where the user is gaining levels, reputation, completions, rewards, etc...
 */
class DestinyCharacterProgressionComponent {
  /**
   * A Dictionary of all known progressions for the Character, keyed by the
   * Progression's hash.
   *
   * Not all progressions have user-facing data, but those who do will have that data
   * contained in the DestinyProgressionDefinition.
   *
   * Mapped to DestinyProgressionDefinition in the manifest.
   */
  Map<int, DestinyProgression> progressions;
  /**
   * A dictionary of all known Factions, keyed by the Faction's hash. It contains
   * data about this character's status with the faction.
   *
   * Mapped to DestinyFactionDefinition in the manifest.
   */
  Map<int, DestinyFactionProgression> factions;
  /**
   * Milestones are related to the simple progressions shown in the game, but return
   * additional and hopefully helpful information for users about the specifics of
   * the Milestone's status.
   *
   * Mapped to DestinyMilestoneDefinition in the manifest.
   */
  Map<int, DestinyMilestone> milestones;
  /**
   * If the user has any active quests, the quests' statuses will be returned here.
   *
   * Note that quests have been largely supplanted by Milestones, but that doesn't
   * mean that they won't make a comeback independent of milestones at some point.
   */
  List<DestinyQuestStatus> quests;
  /**
   * Sometimes, you have items in your inventory that don't have instances, but still
   * have Objective information. This provides you that objective information for
   * uninstanced items.
   *
   * This dictionary is keyed by the item's hash: which you can use to look up the
   * name and description for the overall task(s) implied by the objective. The value
   * is the list of objectives for this item, and their statuses.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  Map<int, List<DestinyObjectiveProgress>> uninstancedItemObjectives;
  /**
   * The set of checklists that can be examined for this specific character, keyed by
   * the hash identifier of the Checklist (DestinyChecklistDefinition)
   *
   * For each checklist returned, its value is itself a Dictionary keyed by the
   * checklist's hash identifier with the value being a boolean indicating if it's
   * been discovered yet.
   *
   * Mapped to DestinyChecklistDefinition in the manifest.
   */
  Map<int, Map<int, bool>> checklists;
}

/**
 * Mostly for historical purposes, we segregate Faction progressions from other
 * progressions. This is just a DestinyProgression with a shortcut for finding the
 * DestinyFactionDefinition of the faction related to the progression.
 */
class DestinyFactionProgression {
  /**
   * The hash identifier of the Faction related to this progression. Use it to look
   * up the DestinyFactionDefinition for more rendering info.
   *
   * Mapped to DestinyFactionDefinition in the manifest.
   */
  int factionHash;
  /**
   * The index of the Faction vendor that is currently available. Will be set to -1
   * if no vendors are available.
   */
  int factionVendorIndex;
  /**
   * The hash identifier of the Progression in question. Use it to look up the
   * DestinyProgressionDefinition in static data.
   *
   * Mapped to DestinyProgressionDefinition in the manifest.
   */
  int progressionHash;
  /** The amount of progress earned today for this progression. */
  int dailyProgress;
  /** If this progression has a daily limit, this is that limit. */
  int dailyLimit;
  /** The amount of progress earned toward this progression in the current week. */
  int weeklyProgress;
  /** If this progression has a weekly limit, this is that limit. */
  int weeklyLimit;
  /**
   * This is the total amount of progress obtained overall for this progression (for
   * instance, the total amount of Character Level experience earned)
   */
  int currentProgress;
  /** This is the level of the progression (for instance, the Character Level). */
  int level;
  /**
   * This is the maximum possible level you can achieve for this progression (for
   * example, the maximum character level obtainable)
   */
  int levelCap;
  /**
   * Progressions define their levels in "steps". Since the last step may be
   * repeatable, the user may be at a higher level than the actual Step achieved in
   * the progression. Not necessarily useful, but potentially interesting for those
   * cruising the API. Relate this to the "steps" property of the DestinyProgression
   * to see which step the user is on, if you care about that. (Note that this is
   * Content Version dependent since it refers to indexes.)
   */
  int stepIndex;
  /**
   * The amount of progression (i.e. "Experience") needed to reach the next level of
   * this Progression. Jeez, progression is such an overloaded word.
   */
  int progressToNextLevel;
  /**
   * The total amount of progression (i.e. "Experience") needed in order to reach the
   * next level.
   */
  int nextLevelAt;
}

/**
 * Represents a runtime instance of a user's milestone status. Live Milestone data
 * should be combined with DestinyMilestoneDefinition data to show the user a
 * picture of what is available for them to do in the game, and their status in
 * regards to said "things to do." Consider it a big, wonky to-do list, or Advisors
 * 3.0 for those who remember the Destiny 1 API.
 */
class DestinyMilestone {
  /**
   * The unique identifier for the Milestone. Use it to look up the
   * DestinyMilestoneDefinition, so you can combine the other data in this contract
   * with static definition data.
   *
   * Mapped to DestinyMilestoneDefinition in the manifest.
   */
  int milestoneHash;
  /**
   * Indicates what quests are available for this Milestone. Usually this will be
   * only a single Quest, but some quests have multiple available that you can choose
   * from at any given time. All possible quests for a milestone can be found in the
   * DestinyMilestoneDefinition, but they must be combined with this Live data to
   * determine which one(s) are actually active right now. It is possible for
   * Milestones to not have any quests.
   */
  List<DestinyMilestoneQuest> availableQuests;
  /**
   * The currently active Activities in this milestone, when the Milestone is driven
   * by Challenges.
   *
   * Not all Milestones have Challenges, but when they do this will indicate the
   * Activities and Challenges under those Activities related to this Milestone.
   */
  List<DestinyMilestoneChallengeActivity> activities;
  /**
   * Milestones may have arbitrary key/value pairs associated with them, for data
   * that users will want to know about but that doesn't fit neatly into any of the
   * common components such as Quests. A good example of this would be - if this
   * existed in Destiny 1 - the number of wins you currently have on your Trials of
   * Osiris ticket. Looking in the DestinyMilestoneDefinition, you can use the string
   * identifier of this dictionary to look up more info about the value, including
   * localized string content for displaying the value. The value in the dictionary
   * is the floating point number. The definition will tell you how to format this
   * number.
   */
  Map<String, double> values;
  /**
   * A milestone may have one or more active vendors that are "related" to it (that
   * provide rewards, or that are the initiators of the Milestone). I already regret
   * this, even as I'm typing it. [I told you I'd regret this] You see, sometimes a
   * milestone may be directly correlated with a set of vendors that provide varying
   * tiers of rewards. The player may not be able to interact with one or more of
   * those vendors. This will return the hashes of the Vendors that the player *can*
   * interact with, allowing you to show their current inventory as rewards or
   * related items to the Milestone or its activities.
   *
   * Before we even use it, it's already deprecated! How much of a bummer is that? We
   * need more data.
   *
   * Mapped to DestinyVendorDefinition in the manifest.
   */
  List<int> vendorHashes;
  /**
   * Replaces vendorHashes, which I knew was going to be trouble the day it walked in
   * the door. This will return not only what Vendors are active and relevant to the
   * activity (in an implied order that you can choose to ignore), but also other
   * data - for example, if the Vendor is featuring a specific item relevant to this
   * event that you should show with them.
   */
  List<DestinyMilestoneVendor> vendors;
  /**
   * If the entity to which this component is attached has known active Rewards for
   * the player, this will detail information about those rewards, keyed by the
   * RewardEntry Hash. (See DestinyMilestoneDefinition for more information about
   * Reward Entries) Note that these rewards are not for the Quests related to the
   * Milestone. Think of these as "overview/checklist" rewards that may be provided
   * for Milestones that may provide rewards for performing a variety of tasks that
   * aren't under a specific Quest.
   */
  List<DestinyMilestoneRewardCategory> rewards;
  /**
   * If known, this is the date when the event last began or refreshed. It will only
   * be populated for events with fixed and repeating start and end dates.
   */
  String startDate;
  /**
   * If known, this is the date when the event will next end or repeat. It will only
   * be populated for events with fixed and repeating start and end dates.
   */
  String endDate;
  /**
   * Used for ordering milestones in a display to match how we order them in BNet.
   * May pull from static data, or possibly in the future from dynamic information.
   */
  int order;
}

/**
 * Milestones are an in-game concept where they're attempting to tell you what you
 * can do next in-game.
 *
 * If that sounds a lot like Advisors in Destiny 1, it is! So we threw out Advisors
 * in the Destiny 2 API and tacked all of the data we would have put on Advisors
 * onto Milestones instead.
 *
 * Each Milestone represents something going on in the game right now:
 *
 * - A "ritual activity" you can perform, like nightfall
 *
 * - A "special event" that may have activities related to it, like Taco Tuesday (
 * there's no Taco Tuesday in Destiny 2)
 *
 * - A checklist you can fulfill, like helping your Clan complete all of its weekly
 * objectives
 *
 * - A tutorial quest you can play through, like the introduction to the Crucible.
 *
 * Most of these milestones appear in game as well. Some of them are BNet only,
 * because we're so extra. You're welcome.
 *
 * There are some important caveats to understand about how we currently render
 * Milestones and their deficiencies. The game currently doesn't have any content
 * that actually tells you oughtright *what* the Milestone is: that is to say, what
 * you'll be doing. The best we get is either a description of the overall
 * Milestone, or of the Quest that the Milestone is having you partake in: which is
 * usually something that assumes you already know what it's talking about, like "
 * Complete 5 Challenges". 5 Challenges for what? What's a challenge? These are not
 * questions that the Milestone data will answer for you unfortunately.
 *
 * This isn't great, and in the future I'd like to add some custom text to give you
 * more contextual information to pass on to your users. But for now, you can do
 * what we do to render what little display info we do have:
 *
 * Start by looking at the currently active quest (ideally, you've fetched
 * DestinyMilestone or DestinyPublicMilestone data from the API, so you know the
 * currently active quest for the Milestone in question). Look up the Quests
 * property in the Milestone Definition, and check if it has display properties. If
 * it does, show that as the description of the Milestone. If it doesn't, fall back
 * on the Milestone's description.
 *
 * This approach will let you avoid, whenever possible, the even less useful (and
 * sometimes nonexistant) milestone-level names and descriptions.
 */
class DestinyMilestoneDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /** A custom image someone made just for the milestone. Isn't that special? */
  String image;
  /**
   * An enumeration listing one of the possible types of milestones. Check out the
   * DestinyMilestoneType enum for more info!
   */
  int milestoneType;
  /** If True, then the Milestone has been integrated with BNet's recruiting feature. */
  bool recruitable;
  /**
   * If the milestone has a friendly identifier for association with other features -
   * such as Recruiting - that identifier can be found here. This is "friendly" in
   * that it looks better in a URL than whatever the identifier for the Milestone
   * actually is.
   */
  String friendlyName;
  /**
   * If TRUE, this entry should be returned in the list of milestones for the "
   * Explore Destiny" (i.e. new BNet homepage) features of Bungie.net (as long as the
   * underlying event is active) Note that this is a property specifically used by
   * BNet and the companion app for the "Live Events" feature of the front page/
   * welcome view: it's not a reflection of what you see in-game.
   */
  bool showInExplorer;
  /**
   * Determines whether we'll show this Milestone in the user's personal Milestones
   * list.
   */
  bool showInMilestones;
  /**
   * If TRUE, "Explore Destiny" (the front page of BNet and the companion app)
   * prioritize using the activity image over any overriding Quest or Milestone image
   * provided. This unfortunate hack is brought to you by Trials of The Nine.
   */
  bool explorePrioritizesActivityImage;
  /**
   * A shortcut for clients - and the server - to understand whether we can predict
   * the start and end dates for this event. In practice, there are multiple ways
   * that an event could have predictable date ranges, but not all events will be
   * able to be predicted via any mechanism (for instance, events that are manually
   * triggered on and off)
   */
  bool hasPredictableDates;
  /**
   * The full set of possible Quests that give the overview of the Milestone event/
   * activity in question. Only one of these can be active at a time for a given
   * Conceptual Milestone, but many of them may be "available" for the user to choose
   * from. (for instance, with Milestones you can choose from the three available
   * Quests, but only one can be active at a time) Keyed by the quest item.
   *
   * As of Forsaken (~September 2018), Quest-style Milestones are being removed for
   * many types of activities. There will likely be further revisions to the
   * Milestone concept in the future.
   */
  Map<int, DestinyMilestoneQuestDefinition> quests;
  /**
   * If this milestone can provide rewards, this will define the categories into
   * which the individual reward entries are placed.
   *
   * This is keyed by the Category's hash, which is only guaranteed to be unique
   * within a given Milestone.
   */
  Map<int, DestinyMilestoneRewardCategoryDefinition> rewards;
  /**
   * If you're going to show Vendors for the Milestone, you can use this as a
   * localized "header" for the section where you show that vendor data. It'll
   * provide a more context-relevant clue about what the vendor's role is in the
   * Milestone.
   */
  String vendorsDisplayTitle;
  /**
   * Sometimes, milestones will have rewards provided by Vendors. This definition
   * gives the information needed to understand which vendors are relevant, the order
   * in which they should be returned if order matters, and the conditions under
   * which the Vendor is relevant to the user.
   */
  List<DestinyMilestoneVendorDefinition> vendors;
  /**
   * Sometimes, milestones will have arbitrary values associated with them that are
   * of interest to us or to third party developers. This is the collection of those
   * values' definitions, keyed by the identifier of the value and providing useful
   * definition information such as localizable names and descriptions for the value.
   */
  Map<String, DestinyMilestoneValueDefinition> values;
  /**
   * Some milestones are explicit objectives that you can see and interact with in
   * the game. Some milestones are more conceptual, built by BNet to help advise you
   * on activities and events that happen in-game but that aren't explicitly shown in
   * game as Milestones. If this is TRUE, you can see this as a milestone in the game.
   * If this is FALSE, it's an event or activity you can participate in, but you won'
   * t see it as a Milestone in the game's UI.
   */
  bool isInGameMilestone;
  /**
   * A Milestone can now be represented by one or more activities directly (without a
   * backing Quest), and that activity can have many challenges, modifiers, and
   * related to it.
   */
  List<DestinyMilestoneChallengeActivityDefinition> activities;
  int defaultOrder;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class DestinyMilestoneType {
   static const int Unknown = 0;
  /**
   * One-time milestones that are specifically oriented toward teaching players about
   * new mechanics and gameplay modes.
   */
   static const int Tutorial = 1;
  /** Milestones that, once completed a single time, can never be repeated. */
   static const int OneTime = 2;
  /**
   * Milestones that repeat/reset on a weekly basis. They need not all reset on the
   * same day or time, but do need to reset weekly to qualify for this type.
   */
   static const int Weekly = 3;
  /** Milestones that repeat or reset on a daily basis. */
   static const int Daily = 4;
  /**
   * Special indicates that the event is not on a daily/weekly cadence, but does
   * occur more than once. For instance, Iron Banner in Destiny 1 or the Dawning were
   * examples of what could be termed "Special" events.
   */
   static const int Special = 5;
}

/**
 * Any data we need to figure out whether this Quest Item is the currently active
 * one for the conceptual Milestone. Even just typing this description, I already
 * regret it.
 */
class DestinyMilestoneQuestDefinition {
  /**
   * The item representing this Milestone quest. Use this hash to look up the
   * DestinyInventoryItemDefinition for the quest to find its steps and human
   * readable data.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int questItemHash;
  /**
   * The individual quests may have different definitions from the overall milestone:
   * if there's a specific active quest, use these displayProperties instead of that
   * of the overall DestinyMilestoneDefinition.
   */
  int displayProperties;
  /**
   * If populated, this image can be shown instead of the generic milestone's image
   * when this quest is live, or it can be used to show a background image for the
   * quest itself that differs from that of the Activity or the Milestone.
   */
  String overrideImage;
  /**
   * The rewards you will get for completing this quest, as best as we could extract
   * them from our data. Sometimes, it'll be a decent amount of data. Sometimes, it's
   * going to be sucky. Sorry.
   */
  int questRewards;
  /**
   * The full set of all possible "conceptual activities" that are related to this
   * Milestone. Tiers or alternative modes of play within these conceptual activities
   * will be defined as sub-entities. Keyed by the Conceptual Activity Hash. Use the
   * key to look up DestinyActivityDefinition.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  Map<int, DestinyMilestoneActivityDefinition> activities;
  /**
   * Sometimes, a Milestone's quest is related to an entire Destination rather than a
   * specific activity. In that situation, this will be the hash of that Destination.
   * Hotspots are currently the only Milestones that expose this data, but that does
   * not preclude this data from being returned for other Milestones in the future.
   *
   * Mapped to DestinyDestinationDefinition in the manifest.
   */
  int destinationHash;
}

/**
 * If rewards are given in a quest - as opposed to overall in the entire Milestone -
 * there's way less to track. We're going to simplify this contract as a result.
 * However, this also gives us the opportunity to potentially put more than just
 * item information into the reward data if we're able to mine it out in the future.
 * Remember this if you come back and ask "why are quest reward items nested
 * inside of their own class?"
 */
class DestinyMilestoneQuestRewardsDefinition {
  /**
   * The items that represent your reward for completing the quest.
   *
   * Be warned, these could be "dummy" items: items that are only used to render a
   * good-looking in-game tooltip, but aren't the actual items themselves.
   *
   * For instance, when experience is given there's often a dummy item representing "
   * experience", with quantity being the amount of experience you got. We don't have
   * a programmatic association between those and whatever Progression is actually
   * getting that experience... yet.
   */
  List<DestinyMilestoneQuestRewardItem> items;
}

/**
 * A subclass of DestinyItemQuantity, that provides not just the item and its
 * quantity but also information that BNet can - at some point - use internally to
 * provide more robust runtime information about the item's qualities.
 *
 * If you want it, please ask! We're just out of time to wire it up right now. Or a
 * clever person just may do it with our existing endpoints.
 */
class DestinyMilestoneQuestRewardItem {
  /**
   * The quest reward item *may* be associated with a vendor. If so, this is that
   * vendor. Use this hash to look up the DestinyVendorDefinition.
   *
   * Mapped to DestinyVendorDefinition in the manifest.
   */
  int vendorHash;
  /**
   * The quest reward item *may* be associated with a vendor. If so, this is the
   * index of the item being sold, which we can use at runtime to find instanced item
   * information for the reward item.
   */
  int vendorItemIndex;
  /**
   * The hash identifier for the item in question. Use it to look up the item's
   * DestinyInventoryItemDefinition.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int itemHash;
  /**
   * If this quantity is referring to a specific instance of an item, this will have
   * the item's instance ID. Normally, this will be null.
   */
  String itemInstanceId;
  /**
   * The amount of the item needed/available depending on the context of where
   * DestinyItemQuantity is being used.
   */
  int quantity;
}

/**
 * Milestones can have associated activities which provide additional information
 * about the context, challenges, modifiers, state etc... related to this Milestone.
 *
 *
 * Information we need to be able to return that data is defined here, along with
 * Tier data to establish a relationship between a conceptual Activity and its
 * difficulty levels and variants.
 */
class DestinyMilestoneActivityDefinition {
  /**
   * The "Conceptual" activity hash. Basically, we picked the lowest level activity
   * and are treating it as the canonical definition of the activity for rendering
   * purposes.
   *
   * If you care about the specific difficulty modes and variations, use the
   * activities under "Variants".
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int conceptualActivityHash;
  /**
   * A milestone-referenced activity can have many variants, such as Tiers or
   * alternative modes of play.
   *
   * Even if there is only a single variant, the details for these are represented
   * within as a variant definition.
   *
   * It is assumed that, if this DestinyMilestoneActivityDefinition is active, then
   * all variants should be active.
   *
   * If a Milestone could ever split the variants' active status conditionally, they
   * should all have their own DestinyMilestoneActivityDefinition instead! The
   * potential duplication will be worth it for the obviousness of processing and use.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  Map<int, DestinyMilestoneActivityVariantDefinition> variants;
}

/**
 * Represents a variant on an activity for a Milestone: a specific difficulty tier,
 * or a specific activity variant for example.
 *
 * These will often have more specific details, such as an associated Guided Game,
 * progression steps, tier-specific rewards, and custom values.
 */
class DestinyMilestoneActivityVariantDefinition {
  /**
   * The hash to use for looking up the variant Activity's definition (
   * DestinyActivityDefinition), where you can find its distinguishing
   * characteristics such as difficulty level and recommended light level.
   *
   * Frequently, that will be the only distinguishing characteristics in practice,
   * which is somewhat of a bummer.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int activityHash;
  /**
   * If you care to do so, render the variants in the order prescribed by this value.
   *
   * When you combine live Milestone data with the definition, the order becomes more
   * useful because you'll be cross-referencing between the definition and live data.
   */
  int order;
}

/** The definition of a category of rewards, that contains many individual rewards. */
class DestinyMilestoneRewardCategoryDefinition {
  /**
   * Identifies the reward category. Only guaranteed unique within this specific
   * component!
   */
  int categoryHash;
  /**
   * The string identifier for the category, if you want to use it for some end.
   * Guaranteed unique within the specific component.
   */
  String categoryIdentifier;
  /** Hopefully this is obvious by now. */
  int displayProperties;
  /**
   * If this milestone can provide rewards, this will define the sets of rewards that
   * can be earned, the conditions under which they can be acquired, internal data
   * that we'll use at runtime to determine whether you've already earned or redeemed
   * this set of rewards, and the category that this reward should be placed under.
   */
  Map<int, DestinyMilestoneRewardEntryDefinition> rewardEntries;
  /**
   * If you want to use BNet's recommended order for rendering categories
   * programmatically, use this value and compare it to other categories to determine
   * the order in which they should be rendered. I don't feel great about putting
   * this here, I won't lie.
   */
  int order;
}

/**
 * The definition of a specific reward, which may be contained in a category of
 * rewards and that has optional information about how it is obtained.
 */
class DestinyMilestoneRewardEntryDefinition {
  /**
   * The identifier for this reward entry. Runtime data will refer to reward entries
   * by this hash. Only guaranteed unique within the specific Milestone.
   */
  int rewardEntryHash;
  /**
   * The string identifier, if you care about it. Only guaranteed unique within the
   * specific Milestone.
   */
  String rewardEntryIdentifier;
  /** The items you will get as rewards, and how much of it you'll get. */
  List<DestinyItemQuantity> items;
  /**
   * If this reward is redeemed at a Vendor, this is the hash of the Vendor to go to
   * in order to redeem the reward. Use this hash to look up the
   * DestinyVendorDefinition.
   *
   * Mapped to DestinyVendorDefinition in the manifest.
   */
  int vendorHash;
  /**
   * For us to bother returning this info, we should be able to return some kind of
   * information about why these rewards are grouped together. This is ideally that
   * information. Look at how confident I am that this will always remain true.
   */
  int displayProperties;
  /**
   * If you want to follow BNet's ordering of these rewards, use this number within a
   * given category to order the rewards. Yeah, I know. I feel dirty too.
   */
  int order;
}

/**
 * If the Milestone or a component has vendors whose inventories could/should be
 * displayed that are relevant to it, this will return the vendor in question.
 *
 * It also contains information we need to determine whether that vendor is
 * actually relevant at the moment, given the user's current state.
 */
class DestinyMilestoneVendorDefinition {
  /**
   * The hash of the vendor whose wares should be shown as associated with the
   * Milestone.
   *
   * Mapped to DestinyVendorDefinition in the manifest.
   */
  int vendorHash;
}

/**
 * The definition for information related to a key/value pair that is relevant for
 * a particular Milestone or component within the Milestone.
 *
 * This lets us more flexibly pass up information that's useful to someone, even if
 * it's not necessarily us.
 */
class DestinyMilestoneValueDefinition {
  String key;
  DestinyDisplayPropertiesDefinition displayProperties;
}

class DestinyMilestoneChallengeActivityDefinition {
  /** The activity for which this challenge is active. */
  int activityHash;
  List<DestinyMilestoneChallengeDefinition> challenges;
  /**
   * If the activity and its challenge is visible on any of these nodes, it will be
   * returned.
   */
  List<DestinyMilestoneChallengeActivityGraphNodeEntry> activityGraphNodes;
}

class DestinyMilestoneChallengeDefinition {
  /** The challenge related to this milestone. */
  int challengeObjectiveHash;
}

class DestinyMilestoneChallengeActivityGraphNodeEntry {
  int activityGraphHash;
  int activityGraphNodeHash;
}

/**
 * If a Milestone has one or more Quests, this will contain the live information
 * for the character's status with one of those quests.
 */
class DestinyMilestoneQuest {
  /**
   * Quests are defined as Items in content. As such, this is the hash identifier of
   * the DestinyInventoryItemDefinition that represents this quest. It will have
   * pointers to all of the steps in the quest, and display information for the quest
   * (title, description, icon etc) Individual steps will be referred to in the Quest
   * item's DestinyInventoryItemDefinition.setData property, and themselves are Items
   * with their own renderable data.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int questItemHash;
  /** The current status of the quest for the character making the request. */
  int status;
  /**
   * *IF* the Milestone has an active Activity that can give you greater details
   * about what you need to do, it will be returned here. Remember to associate this
   * with the DestinyMilestoneDefinition's activities to get details about the
   * activity, including what specific quest it is related to if you have multiple
   * quests to choose from.
   */
  int activity;
  /**
   * The activities referred to by this quest can have many associated challenges.
   * They are all contained here, with activityHashes so that you can associate them
   * with the specific activity variants in which they can be found. In retrospect, I
   * probably should have put these under the specific Activity Variants, but it's
   * too late to change it now. Theoretically, a quest without Activities can still
   * have Challenges, which is why this is on a higher level than activity/variants,
   * but it probably should have been in both places. That may come as a later
   * revision.
   */
  List<DestinyChallengeStatus> challenges;
}

/**
 * Data regarding the progress of a Quest for a specific character. Quests are
 * composed of multiple steps, each with potentially multiple objectives: this
 * QuestStatus will return Objective data for the *currently active* step in this
 * quest.
 */
class DestinyQuestStatus {
  /**
   * The hash identifier for the Quest Item. (Note: Quests are defined as Items, and
   * thus you would use this to look up the quest's DestinyInventoryItemDefinition).
   * For information on all steps in the quest, you can then examine its
   * DestinyInventoryItemDefinition.setData property for Quest Steps (which are *also*
   * items). You can use the Item Definition to display human readable data about
   * the overall quest.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int questHash;
  /**
   * The hash identifier of the current Quest Step, which is also a
   * DestinyInventoryItemDefinition. You can use this to get human readable data
   * about the current step and what to do in that step.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int stepHash;
  /**
   * A step can have multiple objectives. This will give you the progress for each
   * objective in the current step, in the order in which they are rendered in-game.
   */
  List<DestinyObjectiveProgress> stepObjectives;
  /** Whether or not the quest is tracked */
  bool tracked;
  /**
   * The current Quest Step will be an instanced item in the player's inventory. If
   * you care about that, this is the instance ID of that item.
   */
  String itemInstanceId;
  /**
   * Whether or not the whole quest has been completed, regardless of whether or not
   * you have redeemed the rewards for the quest.
   */
  bool completed;
  /** Whether or not you have redeemed rewards for this quest. */
  bool redeemed;
  /** Whether or not you have started this quest. */
  bool started;
  /**
   * If the quest has a related Vendor that you should talk to in order to initiate
   * the quest/earn rewards/continue the quest, this will be the hash identifier of
   * that Vendor. Look it up its DestinyVendorDefinition.
   */
  int vendorHash;
}

/**
 * Sometimes, we know the specific activity that the Milestone wants you to play.
 * This entity provides additional information about that Activity and all of its
 * variants. (sometimes there's only one variant, but I think you get the point)
 */
class DestinyMilestoneActivity {
  /**
   * The hash of an arbitrarily chosen variant of this activity. We'll go ahead and
   * call that the "canonical" activity, because if you're using this value you
   * should only use it for properties that are common across the variants: things
   * like the name of the activity, it's location, etc... Use this hash to look up
   * the DestinyActivityDefinition of this activity for rendering data.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int activityHash;
  /**
   * The hash identifier of the most specific Activity Mode under which this activity
   * is played. This is useful for situations where the activity in question is - for
   * instance - a PVP map, but it's not clear what mode the PVP map is being played
   * under. If it's a playlist, this will be less specific: but hopefully useful in
   * some way.
   *
   * Mapped to DestinyActivityModeDefinition in the manifest.
   */
  int activityModeHash;
  /**
   * The enumeration equivalent of the most specific Activity Mode under which this
   * activity is played.
   */
  int activityModeType;
  /**
   * If the activity has modifiers, this will be the list of modifiers that all
   * variants have in common. Perform lookups against
   * DestinyActivityModifierDefinition which defines the modifier being applied to
   * get at the modifier data. Note that, in the DestiyActivityDefinition, you will
   * see many more modifiers than this being referred to: those are all *possible*
   * modifiers for the activity, not the active ones. Use only the active ones to
   * match what's really live.
   *
   * Mapped to DestinyActivityModifierDefinition in the manifest.
   */
  List<int> modifierHashes;
  /**
   * If you want more than just name/location/etc... you're going to have to dig into
   * and show the variants of the conceptual activity. These will differ in seemingly
   * arbitrary ways, like difficulty level and modifiers applied. Show it in whatever
   * way tickles your fancy.
   */
  List<DestinyMilestoneActivityVariant> variants;
}

/** Represents custom data that we know about an individual variant of an activity. */
class DestinyMilestoneActivityVariant {
  /**
   * The hash for the specific variant of the activity related to this milestone. You
   * can pull more detailed static info from the DestinyActivityDefinition, such as
   * difficulty level.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int activityHash;
  /**
   * An OPTIONAL component: if it makes sense to talk about this activity variant in
   * terms of whether or not it has been completed or what progress you have made in
   * it, this will be returned. Otherwise, this will be NULL.
   */
  int completionStatus;
  /**
   * The hash identifier of the most specific Activity Mode under which this activity
   * is played. This is useful for situations where the activity in question is - for
   * instance - a PVP map, but it's not clear what mode the PVP map is being played
   * under. If it's a playlist, this will be less specific: but hopefully useful in
   * some way.
   *
   * Mapped to DestinyActivityModeDefinition in the manifest.
   */
  int activityModeHash;
  /**
   * The enumeration equivalent of the most specific Activity Mode under which this
   * activity is played.
   */
  int activityModeType;
}

/**
 * Represents this player's personal completion status for the Activity under a
 * Milestone, if the activity has trackable completion and progress information. (
 * most activities won't, or the concept won't apply. For instance, it makes sense
 * to talk about a tier of a raid as being Completed or having progress, but it
 * doesn't make sense to talk about a Crucible Playlist in those terms.
 */
class DestinyMilestoneActivityCompletionStatus {
  /** If the activity has been "completed", that information will be returned here. */
  bool completed;
  /**
   * If the Activity has discrete "phases" that we can track, that info will be here.
   * Otherwise, this value will be NULL. Note that this is a list and not a
   * dictionary: the order implies the ascending order of phases or progression in
   * this activity.
   */
  List<DestinyMilestoneActivityPhase> phases;
}

/**
 * Represents whatever information we can return about an explicit phase in an
 * activity. In the future, I hope we'll have more than just "guh, you done gone
 * and did something," but for the forseeable future that's all we've got. I'm
 * making it more than just a list of booleans out of that overly-optimistic hope.
 */
class DestinyMilestoneActivityPhase {
  /** Indicates if the phase has been completed. */
  bool complete;
  /**
   * In DestinyActivityDefinition, if the activity has phases, there will be a set of
   * phases defined in the "insertionPoints" property. This is the hash that maps to
   * that phase.
   */
  int phaseHash;
}

/**
 * Represents the status and other related information for a challenge that is - or
 * was - available to a player.
 *
 * A challenge is a bonus objective, generally tacked onto Quests or Activities,
 * that provide additional variations on play.
 */
class DestinyChallengeStatus {
  /** The progress - including completion status - of the active challenge. */
  int objective;
}

class DestinyMilestoneChallengeActivity {
  /** Mapped to DestinyActivityDefinition in the manifest. */
  int activityHash;
  List<DestinyChallengeStatus> challenges;
  /**
   * If the activity has modifiers, this will be the list of modifiers that all
   * variants have in common. Perform lookups against
   * DestinyActivityModifierDefinition which defines the modifier being applied to
   * get at the modifier data.
   *
   * Note that, in the DestiyActivityDefinition, you will see many more modifiers
   * than this being referred to: those are all *possible* modifiers for the activity,
   * not the active ones. Use only the active ones to match what's really live.
   *
   * Mapped to DestinyActivityModifierDefinition in the manifest.
   */
  List<int> modifierHashes;
  /**
   * If returned, this is the index into the DestinyActivityDefinition's "loadouts"
   * property, indicating the currently active loadout requirements.
   */
  int loadoutRequirementIndex;
  /**
   * If the Activity has discrete "phases" that we can track, that info will be here.
   * Otherwise, this value will be NULL. Note that this is a list and not a
   * dictionary: the order implies the ascending order of phases or progression in
   * this activity.
   */
  List<DestinyMilestoneActivityPhase> phases;
}

/**
 * If a Milestone has one or more Vendors that are relevant to it, this will
 * contain information about that vendor that you can choose to show.
 */
class DestinyMilestoneVendor {
  /**
   * The hash identifier of the Vendor related to this Milestone. You can show useful
   * things from this, such as thier Faction icon or whatever you might care about.
   *
   * Mapped to DestinyVendorDefinition in the manifest.
   */
  int vendorHash;
  /**
   * If this vendor is featuring a specific item for this event, this will be the
   * hash identifier of that item. I'm taking bets now on how long we go before this
   * needs to be a list or some other, more complex representation instead and I
   * deprecate this too. I'm going to go with 5 months. Calling it now, 2017-09-14 at
   * 9:46pm PST.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int previewItemHash;
}

/**
 * Represents a category of "summary" rewards that can be earned for the Milestone
 * regardless of specific quest rewards that can be earned.
 */
class DestinyMilestoneRewardCategory {
  /**
   * Look up the relevant DestinyMilestoneDefinition, and then use rewardCategoryHash
   * to look up the category info in DestinyMilestoneDefinition.rewards.
   */
  int rewardCategoryHash;
  /** The individual reward entries for this category, and their status. */
  List<DestinyMilestoneRewardEntry> entries;
}

/**
 * The character-specific data for a milestone's reward entry. See
 * DestinyMilestoneDefinition for more information about Reward Entries.
 */
class DestinyMilestoneRewardEntry {
  /**
   * The identifier for the reward entry in question. It is important to look up the
   * related DestinyMilestoneRewardEntryDefinition to get the static details about
   * the reward, which you can do by looking up the milestone's
   * DestinyMilestoneDefinition and examining the DestinyMilestoneDefinition.rewards[
   * rewardCategoryHash].rewardEntries[rewardEntryHash] data.
   */
  int rewardEntryHash;
  /** If TRUE, the player has earned this reward. */
  bool earned;
  /**
   * If TRUE, the player has redeemed/picked up/obtained this reward. Feel free to
   * alias this to "gotTheShinyBauble" in your own codebase.
   */
  bool redeemed;
}

/**
 * Only really useful if you're attempting to render the character's current
 * appearance in 3D, this returns a bare minimum of information, pre-aggregated,
 * that you'll need to perform that rendering. Note that you need to combine this
 * with other 3D assets and data from our servers.
 *
 * Examine the Javascript returned by https://bungie.net/sharedbundle/spasm to see
 * how we use this data, but be warned: the rabbit hole goes pretty deep.
 */
class DestinyCharacterRenderComponent {
  /**
   * Custom dyes, calculated by iterating over the character's equipped items. Useful
   * for pre-fetching all of the dye data needed from our server.
   */
  List<DyeReference> customDyes;
  /**
   * This is actually something that Spasm.js *doesn't* do right now, and that we don'
   * t return assets for yet. This is the data about what character customization
   * options you picked. You can combine this with
   * DestinyCharacterCustomizationOptionDefinition to show some cool info, and
   * hopefully someday to actually render a user's face in 3D. We'll see if we ever
   * end up with time for that.
   */
  int customization;
  /**
   * A minimal view of:
   *
   * - Equipped items
   *
   * - The rendering-related custom options on those equipped items
   *
   * Combined, that should be enough to render all of the items on the equipped
   * character.
   */
  int peerView;
}

/**
 * Raw data about the customization options chosen for a character's face and
 * appearance.
 *
 * You can look up the relevant class/race/gender combo in
 * DestinyCharacterCustomizationOptionDefinition for the character, and then look
 * up these values within the CustomizationOptions found to pull some data about
 * their choices. Warning: not all of that data is meaningful. Some data has useful
 * icons. Others have nothing, and are only meant for 3D rendering purposes (which
 * we sadly do not expose yet)
 */
class DestinyCharacterCustomization {
  int personality;
  int face;
  int skinColor;
  int lipColor;
  int eyeColor;
  List<int> hairColors;
  List<int> featureColors;
  int decalColor;
  bool wearHelmet;
  int hairIndex;
  int featureIndex;
  int decalIndex;
}

/**
 * A minimal view of a character's equipped items, for the purpose of rendering a
 * summary screen or showing the character in 3D.
 */
class DestinyCharacterPeerView {
  List<DestinyItemPeerView> equipment;
}

/**
 * Bare minimum summary information for an item, for the sake of 3D rendering the
 * item.
 */
class DestinyItemPeerView {
  /**
   * The hash identifier of the item in question. Use it to look up the
   * DestinyInventoryItemDefinition of the item for static rendering data.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int itemHash;
  /** The list of dyes that have been applied to this item. */
  List<DyeReference> dyes;
}

/**
 * This component holds activity data for a character. It will tell you about the
 * character's current activity status, as well as activities that are available to
 * the user.
 */
class DestinyCharacterActivitiesComponent {
  /** The last date that the user started playing an activity. */
  String dateActivityStarted;
  /** The list of activities that the user can play. */
  List<DestinyActivity> availableActivities;
  /**
   * If the user is in an activity, this will be the hash of the Activity being
   * played. Note that you must combine this info with currentActivityModeHash to get
   * a real picture of what the user is doing right now. For instance, PVP "
   * Activities" are just maps: it's the ActivityMode that determines what type of
   * PVP game they're playing.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int currentActivityHash;
  /**
   * If the user is in an activity, this will be the hash of the activity mode being
   * played. Combine with currentActivityHash to give a person a full picture of what
   * they're doing right now.
   *
   * Mapped to DestinyActivityModeDefinition in the manifest.
   */
  int currentActivityModeHash;
  /**
   * And the current activity's most specific mode type, if it can be found.
   *
   * Mapped to DestinyActivityModeDefinition in the manifest.
   */
  int currentActivityModeType;
  /**
   * If the user is in an activity, this will be the hashes of the
   * DestinyActivityModeDefinition being played. Combine with currentActivityHash to
   * give a person a full picture of what they're doing right now.
   *
   * Mapped to DestinyActivityModeDefinition in the manifest.
   */
  List<int> currentActivityModeHashes;
  /** All Activity Modes that apply to the current activity being played, in enum form. */
  List<DestinyActivityModeType> currentActivityModeTypes;
  /**
   * If the user is in a playlist, this is the hash identifier for the playlist that
   * they chose.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int currentPlaylistActivityHash;
  /**
   * This will have the activity hash of the last completed story/campaign mission,
   * in case you care about that.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int lastCompletedStoryHash;
}

/**
 * Represents the "Live" data that we can obtain about a Character's status with a
 * specific Activity. This will tell you whether the character can participate in
 * the activity, as well as some other basic mutable information.
 *
 * Meant to be combined with static DestinyActivityDefinition data for a full
 * picture of the Activity.
 */
class DestinyActivity {
  /**
   * The hash identifier of the Activity. Use this to look up the
   * DestinyActivityDefinition of the activity.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int activityHash;
  /** If true, then the activity should have a "new" indicator in the Director UI. */
  bool isNew;
  /** If true, the user is allowed to lead a Fireteam into this activity. */
  bool canLead;
  /** If true, the user is allowed to join with another Fireteam in this activity. */
  bool canJoin;
  /**
   * If true, we both have the ability to know that the user has completed this
   * activity and they have completed it. Unfortunately, we can't necessarily know
   * this for all activities. As such, this should probably only be used if you
   * already know in advance which specific activities you wish to check.
   */
  bool isCompleted;
  /** If true, the user should be able to see this activity. */
  bool isVisible;
  /** The difficulty level of the activity, if applicable. */
  int displayLevel;
  /** The recommended light level for the activity, if applicable. */
  int recommendedLight;
  /**
   * A DestinyActivityDifficultyTier enum value indicating the difficulty of the
   * activity.
   */
  int difficultyTier;
}

class DestinyActivityDifficultyTier {
   static const int Trivial = 0;
   static const int Easy = 1;
   static const int Normal = 2;
   static const int Challenging = 3;
   static const int Hard = 4;
   static const int Brave = 5;
   static const int AlmostImpossible = 6;
   static const int Impossible = 7;
}

class DestinyBaseItemComponentSetOfuint32 {
  DictionaryComponentResponse<DestinyItemObjectivesComponent> objectives;
}

/**
 * Items can have objectives and progression. When you request this block, you will
 * obtain information about any Objectives and progression tied to this item.
 */
class DestinyItemObjectivesComponent {
  /**
   * If the item has a hard association with objectives, your progress on them will
   * be defined here.
   *
   * Objectives are our standard way to describe a series of tasks that have to be
   * completed for a reward.
   */
  List<DestinyObjectiveProgress> objectives;
  /**
   * I may regret naming it this way - but this represents when an item has an
   * objective that doesn't serve a beneficial purpose, but rather is used for "
   * flavor" or additional information. For instance, when Emblems track specific
   * stats, those stats are represented as Objectives on the item.
   */
  int flavorObjective;
  /**
   * If we have any information on when these objectives were completed, this will be
   * the date of that completion. This won't be on many items, but could be
   * interesting for some items that do store this information.
   */
  String dateCompleted;
}

class DestinyCharacterRecordsComponent {
  /** Mapped to DestinyRecordDefinition in the manifest. */
  List<int> featuredRecordHashes;
  Map<int, DestinyRecordComponent> records;
}

class DestinyCollectiblesComponent {
  Map<int, DestinyCollectibleComponent> collectibles;
}

class DestinyItemComponentSetOfint64 {
  DictionaryComponentResponse<DestinyItemInstanceComponent> instances;
  DictionaryComponentResponse<DestinyItemPerksComponent> perks;
  DictionaryComponentResponse<DestinyItemRenderComponent> renderData;
  DictionaryComponentResponse<DestinyItemStatsComponent> stats;
  DictionaryComponentResponse<DestinyItemSocketsComponent> sockets;
  DictionaryComponentResponse<DestinyItemTalentGridComponent> talentGrids;
  DictionaryComponentResponse<DestinyItemPlugComponent> plugStates;
  DictionaryComponentResponse<DestinyItemObjectivesComponent> objectives;
}

/**
 * If an item is "instanced", this will contain information about the item's
 * instance that doesn't fit easily into other components. One might say this is
 * the "essential" instance data for the item.
 *
 * Items are instanced if they require information or state that can vary. For
 * instance, weapons are Instanced: they are given a unique identifier, uniquely
 * generated stats, and can have their properties altered. Non-instanced items have
 * none of these things: for instance, Glimmer has no unique properties aside from
 * how much of it you own.
 *
 * You can tell from an item's definition whether it will be instanced or not by
 * looking at the DestinyInventoryItemDefinition's definition.inventory.
 * isInstanceItem property.
 */
class DestinyItemInstanceComponent {
  /** If the item has a damage type, this is the item's current damage type. */
  int damageType;
  /**
   * The current damage type's hash, so you can look up localized info and icons for
   * it.
   *
   * Mapped to DestinyDamageTypeDefinition in the manifest.
   */
  int damageTypeHash;
  /**
   * The item stat that we consider to be "primary" for the item. For instance, this
   * would be "Attack" for Weapons or "Defense" for armor.
   */
  int primaryStat;
  /**
   * The Item's "Level" has the most significant bearing on its stats, such as Light
   * and Power.
   */
  int itemLevel;
  /**
   * The "Quality" of the item has a lesser - but still impactful - bearing on stats
   * like Light and Power.
   */
  int quality;
  /** Is the item currently equipped on the given character? */
  bool isEquipped;
  /**
   * If this is an equippable item, you can check it here. There are permanent as
   * well as transitory reasons why an item might not be able to be equipped: check
   * cannotEquipReason for details.
   */
  bool canEquip;
  /**
   * If the item cannot be equipped until you reach a certain level, that level will
   * be reflected here.
   */
  int equipRequiredLevel;
  /**
   * Sometimes, there are limitations to equipping that are represented by character-
   * level flags called "unlocks".
   *
   * This is a list of flags that they need in order to equip the item that the
   * character has not met. Use these to look up the descriptions to show in your UI
   * by looking up the relevant DestinyUnlockDefinitions for the hashes.
   *
   * Mapped to DestinyUnlockDefinition in the manifest.
   */
  List<int> unlockHashesRequiredToEquip;
  /**
   * If you cannot equip the item, this is a flags enum that enumerates all of the
   * reasons why you couldn't equip the item. You may need to refine your UI further
   * by using unlockHashesRequiredToEquip and equipRequiredLevel.
   */
  int cannotEquipReason;
}

/**
 * Represents a stat on an item *or* Character (NOT a Historical Stat, but a
 * physical attribute stat like Attack, Defense etc...)
 */
class DestinyStat {
  /**
   * The hash identifier for the Stat. Use it to look up the DestinyStatDefinition
   * for static data about the stat.
   *
   * Mapped to DestinyStatDefinition in the manifest.
   */
  int statHash;
  /** The current value of the Stat. */
  int value;
  /**
   * The highest possible value for the stat, if we were able to compute it. (I
   * wouldn't necessarily trust this value right now. I would like to improve its
   * calculation in later iterations of the API. Consider this a placeholder for
   * desired future functionality)
   */
  int maximumValue;
}

/**
 * Unlock Flags are small bits (literally, a bit, as in a boolean value) that the
 * game server uses for an extremely wide range of state checks, progress storage,
 * and other interesting tidbits of information.
 */
class DestinyUnlockDefinition {
  /**
   * Sometimes, but not frequently, these unlock flags also have human readable
   * information: usually when they are being directly tested for some requirement,
   * in which case the string is a localized description of why the requirement check
   * failed.
   */
  int displayProperties;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

class EquipFailureReason {
  /** The item is/was able to be equipped. */
   static const int None = 0;
  /**
   * This is not the kind of item that can be equipped. Did you try equipping Glimmer
   * or something?
   */
   static const int ItemUnequippable = 1;
  /**
   * This item is part of a "unique set", and you can't have more than one item of
   * that same set type equipped at once. For instance, if you already have an Exotic
   * Weapon equipped, you can't equip a second one in another weapon slot.
   */
   static const int ItemUniqueEquipRestricted = 2;
  /**
   * This item has state-based gating that prevents it from being equipped in certain
   * circumstances. For instance, an item might be for Warlocks only and you're a
   * Titan, or it might require you to have beaten some special quest that you haven'
   * t beaten yet. Use the additional failure data passed on the item itself to get
   * more information about what the specific failure case was (See
   * DestinyInventoryItemDefinition and DestinyItemInstanceComponent)
   */
   static const int ItemFailedUnlockCheck = 4;
  /**
   * This item requires you to have reached a specific character level in order to
   * equip it, and you haven't reached that level yet.
   */
   static const int ItemFailedLevelCheck = 8;
  /**
   * This item can't be equipped on the character requested, because it must be in
   * that character's inventory first. Transfer the item to the character you want to
   * equip it before you attempt to equip it.
   */
   static const int ItemNotOnCharacter = 16;
}

/**
 * Instanced items can have perks: benefits that the item bestows.
 *
 * These are related to DestinySandboxPerkDefinition, and sometimes - but not
 * always - have human readable info. When they do, they are the icons and text
 * that you see in an item's tooltip.
 *
 * Talent Grids, Sockets, and the item itself can apply Perks, which are then
 * summarized here for your convenience.
 */
class DestinyItemPerksComponent {
  /**
   * The list of perks to display in an item tooltip - and whether or not they have
   * been activated.
   */
  List<DestinyPerkReference> perks;
}

/**
 * The list of perks to display in an item tooltip - and whether or not they have
 * been activated.
 *
 * Perks apply a variety of effects to a character, and are generally either
 * intrinsic to the item or provided in activated talent nodes or sockets.
 */
class DestinyPerkReference {
  /**
   * The hash identifier for the perk, which can be used to look up
   * DestinySandboxPerkDefinition if it exists. Be warned, perks frequently do not
   * have user-viewable information. You should examine whether you actually found a
   * name/description in the perk's definition before you show it to the user.
   *
   * Mapped to DestinySandboxPerkDefinition in the manifest.
   */
  int perkHash;
  /** The icon for the perk. */
  String iconPath;
  /**
   * Whether this perk is currently active. (We may return perks that you have not
   * actually activated yet: these represent perks that you should show in the item's
   * tooltip, but that the user has not yet activated.)
   */
  bool isActive;
  /**
   * Some perks provide benefits, but aren't visible in the UI. This value will let
   * you know if this is perk should be shown in your UI.
   */
  bool visible;
}

/**
 * Many items can be rendered in 3D. When you request this block, you will obtain
 * the custom data needed to render this specific instance of the item.
 */
class DestinyItemRenderComponent {
  /** If you should use custom dyes on this item, it will be indicated here. */
  bool useCustomDyes;
  /**
   * A dictionary for rendering gear components, with:
   *
   * key = Art Arrangement Region Index
   *
   * value = The chosen Arrangement Index for the Region, based on the value of a
   * stat on the item used for making the choice.
   */
  Map<int, int> artRegions;
}

/**
 * If you want the stats on an item's instanced data, get this component.
 *
 * These are stats like Attack, Defense etc... and *not* historical stats.
 *
 * Note that some stats have additional computation in-game at runtime - for
 * instance, Magazine Size - and thus these stats might not be 100% accurate
 * compared to what you see in-game for some stats. I know, it sucks. I hate it too.
 */
class DestinyItemStatsComponent {
  /**
   * If the item has stats that it provides (damage, defense, etc...), it will be
   * given here.
   *
   * Mapped to DestinyStatDefinition in the manifest.
   */
  Map<int, DestinyStat> stats;
}

/**
 * Instanced items can have sockets, which are slots on the item where plugs can be
 * inserted.
 *
 * Sockets are a bit complex: be sure to examine the documentation on the
 * DestinyInventoryItemDefinition's "socket" block and elsewhere on these objects
 * for more details.
 */
class DestinyItemSocketsComponent {
  /** The list of all sockets on the item, and their status information. */
  List<DestinyItemSocketState> sockets;
}

/**
 * The status of a given item's socket. (which plug is inserted, if any: whether it
 * is enabled, what "reusable" plugs can be inserted, etc...)
 *
 * If I had it to do over, this would probably have a DestinyItemPlug representing
 * the inserted item instead of most of these properties. :shrug:
 */
class DestinyItemSocketState {
  /**
   * The currently active plug, if any.
   *
   * Note that, because all plugs are statically defined, its effect on stats and
   * perks can be statically determined using the plug item's definition. The stats
   * and perks can be taken at face value on the plug item as the stats and perks it
   * will provide to the user/item.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int plugHash;
  /**
   * Even if a plug is inserted, it doesn't mean it's enabled.
   *
   * This flag indicates whether the plug is active and providing its benefits.
   */
  bool isEnabled;
  /**
   * A plug may theoretically provide benefits but not be visible - for instance,
   * some older items use a plug's damage type perk to modify their own damage type.
   * These, though they are not visible, still affect the item. This field indicates
   * that state.
   *
   * An invisible plug, while it provides benefits if it is Enabled, cannot be
   * directly modified by the user.
   */
  bool isVisible;
  /**
   * If a plug is inserted but not enabled, this will be populated with indexes into
   * the plug item definition's plug.enabledRules property, so that you can show the
   * reasons why it is not enabled.
   */
  List<int> enableFailIndexes;
  /**
   * If the item supports reusable plugs, this is the list of plug item hashes that
   * are currently allowed to be used for this socket. See the "reusablePlugs"
   * property, which has rendered this obsolete, for more information.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  List<int> reusablePlugHashes;
  /**
   * Sometimes, Plugs may have objectives: generally, these are used for flavor and
   * display purposes. For instance, a Plug might be tracking the number of PVP kills
   * you have made. It will use the parent item's data about that tracking status to
   * determine what to show, and will generally show it using the
   * DestinyObjectiveDefinition's progressDescription property. Refer to the plug's
   * itemHash and objective property for more information if you would like to
   * display even more data.
   */
  List<DestinyObjectiveProgress> plugObjectives;
  /**
   * If the item supports reusable plugs, this is the list of plugs that are allowed
   * to be used for the socket, and any relevant information about whether they are "
   * enabled", whether they are allowed to be inserted, and any other information
   * such as objectives.
   *
   * A Reusable Plug is a plug that you can always insert into this socket as long as
   * its insertion rules are passed, regardless of whether or not you have the plug
   * in your inventory. An example of it failing an insertion rule would be if it has
   * an Objective that needs to be completed before it can be inserted, and that
   * objective hasn't been completed yet.
   *
   * In practice, a socket will *either* have reusable plugs *or* it will allow for
   * plugs in your inventory to be inserted. See DestinyInventoryItemDefinition.
   * socket for more info.
   */
  List<DestinyItemPlug> reusablePlugs;
}

/**
 * Well, we're here in Destiny 2, and Talent Grids are unfortunately still around.
 *
 * The good news is that they're pretty much only being used for certain base
 * information on items and for Builds/Subclasses. The bad news is that they still
 * suck. If you really want this information, grab this component.
 *
 * An important note is that talent grids are defined as such:
 *
 * A Grid has 1:M Nodes, which has 1:M Steps.
 *
 * Any given node can only have a single step active at one time, which represents
 * the actual visual contents and effects of the Node (for instance, if you see a "
 * Super Cool Bonus" node, the actual icon and text for the node is coming from the
 * current Step of that node).
 *
 * Nodes can be grouped into exclusivity sets *and* as of D2, exclusivity groups (
 * which are collections of exclusivity sets that affect each other).
 *
 * See DestinyTalentGridDefinition for more information. Brace yourself, the water'
 * s cold out there in the deep end.
 */
class DestinyItemTalentGridComponent {
  /**
   * Most items don't have useful talent grids anymore, but Builds in particular
   * still do.
   *
   * You can use this hash to lookup the DestinyTalentGridDefinition attached to this
   * item, which will be crucial for understanding the node values on the item.
   *
   * Mapped to DestinyTalentGridDefinition in the manifest.
   */
  int talentGridHash;
  /**
   * Detailed information about the individual nodes in the talent grid.
   *
   * A node represents a single visual "pip" in the talent grid or Build detail view,
   * though each node may have multiple "steps" which indicate the actual bonuses and
   * visual representation of that node.
   */
  List<DestinyTalentNode> nodes;
  /**
   * Indicates whether the talent grid on this item is completed, and thus whether it
   * should have a gold border around it.
   *
   * Only will be true if the item actually *has* a talent grid, and only then if it
   * is completed (i.e. every exclusive set has an activated node, and every non-
   * exclusive set node has been activated)
   */
  bool isGridComplete;
  /**
   * If the item has a progression, it will be detailed here. A progression means
   * that the item can gain experience. Thresholds of experience are what determines
   * whether and when a talent node can be activated.
   */
  int gridProgression;
}

/**
 * I see you've come to find out more about Talent Nodes. I'm so sorry. Talent
 * Nodes are the conceptual, visual nodes that appear on Talent Grids. Talent Grids,
 * in Destiny 1, were found on almost every instanced item: they had Nodes that
 * could be activated to change the properties of the item. In Destiny 2, Talent
 * Grids only exist for Builds/Subclasses, and while the basic concept is the same (
 * Nodes can be activated once you've gained sufficient Experience on the Item, and
 * provide effects), there are some new concepts from Destiny 1. Examine
 * DestinyTalentGridDefinition and its subordinates for more information. This is
 * the "Live" information for the current status of a Talent Node on a specific
 * item. Talent Nodes have many Steps, but only one can be active at any one time:
 * and it is the Step that determines both the visual and the game state-changing
 * properties that the Node provides. Examine this and
 * DestinyTalentNodeStepDefinition carefully. *IMPORTANT NOTE* Talent Nodes are,
 * unfortunately, Content Version DEPENDENT. Though they refer to hashes for Nodes
 * and Steps, those hashes are not guaranteed to be immutable across content
 * versions. This is a source of great exasperation for me, but as a result anyone
 * using Talent Grid data must ensure that the content version of their static
 * content matches that of the server responses before showing or making decisions
 * based on talent grid data.
 */
class DestinyTalentNode {
  /**
   * The index of the Talent Node being referred to (an index into
   * DestinyTalentGridDefinition.nodes[]). CONTENT VERSION DEPENDENT.
   */
  int nodeIndex;
  /**
   * The hash of the Talent Node being referred to (in DestinyTalentGridDefinition.
   * nodes). Deceptively CONTENT VERSION DEPENDENT. We have no guarantee of the hash'
   * s immutability between content versions.
   */
  int nodeHash;
  /**
   * An DestinyTalentNodeState enum value indicating the node's state: whether it can
   * be activated or swapped, and why not if neither can be performed.
   */
  int state;
  /** If true, the node is activated: it's current step then provides its benefits. */
  bool isActivated;
  /**
   * The currently relevant Step for the node. It is this step that has rendering
   * data for the node and the benefits that are provided if the node is activated. (
   * the actual rules for benefits provided are extremely complicated in theory, but
   * with how Talent Grids are being used in Destiny 2 you don't have to worry about
   * a lot of those old Destiny 1 rules.) This is an index into:
   * DestinyTalentGridDefinition.nodes[nodeIndex].steps[stepIndex]
   */
  int stepIndex;
  /**
   * If the node has material requirements to be activated, this is the list of those
   * requirements.
   */
  List<DestinyMaterialRequirement> materialsToUpgrade;
  /**
   * The progression level required on the Talent Grid in order to be able to
   * activate this talent node. Talent Grids have their own Progression - similar to
   * Character Level, but in this case it is experience related to the item itself.
   */
  int activationGridLevel;
  /**
   * If you want to show a progress bar or circle for how close this talent node is
   * to being activate-able, this is the percentage to show. It follows the node's
   * underlying rules about when the progress bar should first show up, and when it
   * should be filled.
   */
  double progressPercent;
  /**
   * Whether or not the talent node is actually visible in the game's UI. Whether you
   * want to show it in your own UI is up to you! I'm not gonna tell you who to sock
   * it to.
   */
  bool hidden;
  /**
   * This property has some history. A talent grid can provide stats on both the item
   * it's related to and the character equipping the item. This returns data about
   * those stat bonuses.
   */
  int nodeStatsBlock;
}

class DestinyTalentNodeState {
   static const int Invalid = 0;
   static const int CanUpgrade = 1;
   static const int NoPoints = 2;
   static const int NoPrerequisites = 3;
   static const int NoSteps = 4;
   static const int NoUnlock = 5;
   static const int NoMaterial = 6;
   static const int NoGridLevel = 7;
   static const int SwappingLocked = 8;
   static const int MustSwap = 9;
   static const int Complete = 10;
   static const int Unknown = 11;
   static const int CreationOnly = 12;
   static const int Hidden = 13;
}

/**
 * This property has some history. A talent grid can provide stats on both the item
 * it's related to and the character equipping the item. This returns data about
 * those stat bonuses.
 */
class DestinyTalentNodeStatBlock {
  /**
   * The stat benefits conferred when this talent node is activated for the current
   * Step that is active on the node.
   */
  List<DestinyStat> currentStepStats;
  /**
   * This is a holdover from the old days of Destiny 1, when a node could be
   * activated multiple times, conferring multiple steps worth of benefits: you would
   * use this property to show what activating the "next" step on the node would
   * provide vs. what the current step is providing. While Nodes are currently not
   * being used this way, the underlying system for this functionality still exists.
   * I hesitate to remove this property while the ability for designers to make such
   * a talent grid still exists. Whether you want to show it is up to you.
   */
  List<DestinyStat> nextStepStats;
}

/**
 * Plugs are non-instanced items that can provide Stat and Perk benefits when
 * socketed into an instanced item. Items have Sockets, and Plugs are inserted into
 * Sockets.
 *
 * This component finds all items that are considered "Plugs" in your inventory,
 * and return information about the plug aside from any specific Socket into which
 * it could be inserted.
 */
class DestinyItemPlugComponent {
  /**
   * The hash identifier of the DestinyInventoryItemDefinition that represents this
   * plug.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int plugItemHash;
  /**
   * Sometimes, Plugs may have objectives: these are often used for flavor and
   * display purposes, but they can be used for any arbitrary purpose (both
   * fortunately and unfortunately). Recently (with Season 2) they were expanded in
   * use to be used as the "gating" for whether the plug can be inserted at all. For
   * instance, a Plug might be tracking the number of PVP kills you have made. It
   * will use the parent item's data about that tracking status to determine what to
   * show, and will generally show it using the DestinyObjectiveDefinition's
   * progressDescription property. Refer to the plug's itemHash and objective
   * property for more information if you would like to display even more data.
   */
  List<DestinyObjectiveProgress> plugObjectives;
  /** If true, this plug has met all of its insertion requirements. Big if true. */
  bool canInsert;
  /** If true, this plug will provide its benefits while inserted. */
  bool enabled;
  /**
   * If the plug cannot be inserted for some reason, this will have the indexes into
   * the plug item definition's plug.insertionRules property, so you can show the
   * reasons why it can't be inserted.
   *
   * This list will be empty if the plug can be inserted.
   */
  List<int> insertFailIndexes;
  /**
   * If a plug is not enabled, this will be populated with indexes into the plug item
   * definition's plug.enabledRules property, so that you can show the reasons why it
   * is not enabled.
   *
   * This list will be empty if the plug is enabled.
   */
  List<int> enableFailIndexes;
}

/**
 * This component provides a quick lookup of every item the requested character has
 * and how much of that item they have.
 *
 * Requesting this component will allow you to circumvent manually putting together
 * the list of which currencies you have for the purpose of testing currency
 * requirements on an item being purchased, or operations that have costs.
 *
 * You *could* figure this out yourself by doing a GetCharacter or GetProfile
 * request and forming your own lookup table, but that is inconvenient enough that
 * this feels like a worthwhile (and optional) redundency. Don't bother requesting
 * it if you have already created your own lookup from prior GetCharacter/
 * GetProfile calls.
 */
class DestinyCurrenciesComponent {
  /**
   * A dictionary - keyed by the item's hash identifier (
   * DestinyInventoryItemDefinition), and whose value is the amount of that item you
   * have across all available inventory buckets for purchasing.
   *
   * This allows you to see whether the requesting character can afford any given
   * purchase/action without having to re-create this list itself.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  Map<int, int> itemQuantities;
}

/**
 * The response contract for GetDestinyCharacter, with components that can be
 * returned for character and item-level data.
 */
class DestinyCharacterResponse {
  /**
   * The character-level non-equipped inventory items.
   *
   * COMPONENT TYPE: CharacterInventories
   */
  int inventory;
  /**
   * Base information about the character in question.
   *
   * COMPONENT TYPE: Characters
   */
  int character;
  /**
   * Character progression data, including Milestones.
   *
   * COMPONENT TYPE: CharacterProgressions
   */
  int progressions;
  /**
   * Character rendering data - a minimal set of information about equipment and dyes
   * used for rendering.
   *
   * COMPONENT TYPE: CharacterRenderData
   */
  int renderData;
  /**
   * Activity data - info about current activities available to the player.
   *
   * COMPONENT TYPE: CharacterActivities
   */
  int activities;
  /**
   * Equipped items on the character.
   *
   * COMPONENT TYPE: CharacterEquipment
   */
  int equipment;
  /**
   * Items available from Kiosks that are available to this specific character.
   *
   * COMPONENT TYPE: Kiosks
   */
  int kiosks;
  /**
   * When sockets refer to reusable Plug Sets (see DestinyPlugSetDefinition for more
   * info), this is the set of plugs and their states that are scoped to this
   * character.
   *
   * This comes back with ItemSockets, as it is needed for a complete picture of the
   * sockets on requested items.
   *
   * COMPONENT TYPE: ItemSockets
   */
  int plugSets;
  /** COMPONENT TYPE: PresentationNodes */
  int presentationNodes;
  /** COMPONENT TYPE: Records */
  int records;
  /** COMPONENT TYPE: Collectibles */
  int collectibles;
  /**
   * The set of components belonging to the player's instanced items.
   *
   * COMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component
   * types.]
   */
  int itemComponents;
  /**
   * The set of components belonging to the player's UNinstanced items. Because
   * apparently now those too can have information relevant to the character's state.
   *
   * COMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component
   * types.]
   */
  int uninstancedItemComponents;
  /**
   * A "lookup" convenience component that can be used to quickly check if the
   * character has access to items that can be used for purchasing.
   *
   * COMPONENT TYPE: CurrencyLookups
   */
  int currencyLookups;
}

/**
 * The response object for retrieving an individual instanced item. None of these
 * components are relevant for an item that doesn't have an "itemInstanceId": for
 * those, get your information from the DestinyInventoryDefinition.
 */
class DestinyItemResponse {
  /**
   * If the item is on a character, this will return the ID of the character that is
   * holding the item.
   */
  String characterId;
  /**
   * Common data for the item relevant to its non-instanced properties.
   *
   * COMPONENT TYPE: ItemCommonData
   */
  int item;
  /**
   * Basic instance data for the item.
   *
   * COMPONENT TYPE: ItemInstances
   */
  int instance;
  /**
   * Information specifically about the item's objectives.
   *
   * COMPONENT TYPE: ItemObjectives
   */
  int objectives;
  /**
   * Information specifically about the perks currently active on the item.
   *
   * COMPONENT TYPE: ItemPerks
   */
  int perks;
  /**
   * Information about how to render the item in 3D.
   *
   * COMPONENT TYPE: ItemRenderData
   */
  int renderData;
  /**
   * Information about the computed stats of the item: power, defense, etc...
   *
   * COMPONENT TYPE: ItemStats
   */
  int stats;
  /**
   * Information about the talent grid attached to the item. Talent nodes can provide
   * a variety of benefits and abilities, and in Destiny 2 are used almost
   * exclusively for the character's "Builds".
   *
   * COMPONENT TYPE: ItemTalentGrids
   */
  int talentGrid;
  /**
   * Information about the sockets of the item: which are currently active, what
   * potential sockets you could have and the stats/abilities/perks you can gain from
   * them.
   *
   * COMPONENT TYPE: ItemSockets
   */
  int sockets;
}

/** A response containing all of the components for all requested vendors. */
class DestinyVendorsResponse {
  /**
   * For Vendors being returned, this will give you the information you need to group
   * them and order them in the same way that the Bungie Companion app performs
   * grouping. It will automatically be returned if you request the Vendors component.
   *
   * COMPONENT TYPE: Vendors
   */
  int vendorGroups;
  /**
   * The base properties of the vendor. These are keyed by the Vendor Hash, so you
   * will get one Vendor Component per vendor returned.
   *
   * COMPONENT TYPE: Vendors
   */
  int vendors;
  /**
   * Categories that the vendor has available, and references to the sales therein.
   * These are keyed by the Vendor Hash, so you will get one Categories Component per
   * vendor returned.
   *
   * COMPONENT TYPE: VendorCategories
   */
  int categories;
  /**
   * Sales, keyed by the vendorItemIndex of the item being sold. These are keyed by
   * the Vendor Hash, so you will get one Sale Item Set Component per vendor returned.
   *
   * Note that within the Sale Item Set component, the sales are themselves keyed by
   * the vendorSaleIndex, so you can relate it to the corrent sale item definition
   * within the Vendor's definition.
   *
   * COMPONENT TYPE: VendorSales
   */
  int sales;
  /**
   * The set of item detail components, one set of item components per Vendor. These
   * are keyed by the Vendor Hash, so you will get one Item Component Set per vendor
   * returned.
   *
   * The components contained inside are themselves keyed by the vendorSaleIndex, and
   * will have whatever item-level components you requested (Sockets, Stats, Instance
   * data etc...) per item being sold by the vendor.
   */
  Map<int, DestinyItemComponentSetOfint32> itemComponents;
  /**
   * A "lookup" convenience component that can be used to quickly check if the
   * character has access to items that can be used for purchasing.
   *
   * COMPONENT TYPE: CurrencyLookups
   */
  int currencyLookups;
}

/**
 * This component returns references to all of the Vendors in the response, grouped
 * by categorizations that Bungie has deemed to be interesting, in the order in
 * which both the groups and the vendors within that group should be rendered.
 */
class DestinyVendorGroupComponent {
  /** The ordered list of groups being returned. */
  List<DestinyVendorGroup> groups;
}

/**
 * Represents a specific group of vendors that can be rendered in the recommended
 * order.
 *
 * How do we figure out this order? It's a long story, and will likely get more
 * complicated over time.
 */
class DestinyVendorGroup {
  /** Mapped to DestinyVendorGroupDefinition in the manifest. */
  int vendorGroupHash;
  /**
   * The ordered list of vendors within a particular group.
   *
   * Mapped to DestinyVendorDefinition in the manifest.
   */
  List<int> vendorHashes;
}

/** This component contains essential/summary information about the vendor. */
class DestinyVendorComponent {
  /**
   * The unique identifier for the vendor. Use it to look up their
   * DestinyVendorDefinition.
   *
   * Mapped to DestinyVendorDefinition in the manifest.
   */
  int vendorHash;
  /**
   * The date when this vendor's inventory will next rotate/refresh.
   *
   * Note that this is distinct from the date ranges that the vendor is visible/
   * available in-game: this field indicates the specific time when the vendor's
   * available items refresh and rotate, regardless of whether the vendor is actually
   * available at that time. Unfortunately, these two values may be (and are, for the
   * case of important vendors like Xur) different.
   *
   * Issue https://github.com/Bungie-net/api/issues/353 is tracking a fix to start
   * providing visibility date ranges where possible in addition to this refresh date,
   * so that all important dates for vendors are available for use.
   */
  String nextRefreshDate;
  /**
   * If True, the Vendor is currently accessible.
   *
   * If False, they may not actually be visible in the world at the moment.
   */
  bool enabled;
  /**
   * If True, you can purchase from the Vendor.
   *
   * Theoretically, Vendors can be restricted from selling items. In practice, none
   * do that (yet?).
   */
  bool canPurchase;
  /**
   * If the Vendor has a related Reputation, this is the Progression data that
   * represents the character's Reputation level with this Vendor.
   */
  int progression;
  /**
   * An index into the vendor definition's "locations" property array, indicating
   * which location they are at currently. If -1, then the vendor has no known
   * location (and you may choose not to show them in your UI as a result. I mean, it'
   * s your bag honey)
   */
  int vendorLocationIndex;
  /**
   * If this vendor has a seasonal rank, this will be the calculated value of that
   * rank. How nice is that? I mean, that's pretty sweeet. It's a whole 32 bit
   * integer.
   */
  int seasonalRank;
}

/**
 * A vendor can have many categories of items that they sell. This component will
 * return the category information for available items, as well as the index into
 * those items in the user's sale item list.
 *
 * Note that, since both the category and items are indexes, this data is Content
 * Version dependent. Be sure to check that your content is up to date before using
 * this data. This is an unfortunate, but permanent, limitation of Vendor data.
 */
class DestinyVendorCategoriesComponent {
  /**
   * The list of categories for items that the vendor sells, in rendering order.
   *
   * These categories each point to a "display category" in the displayCategories
   * property of the DestinyVendorDefinition, as opposed to the other categories.
   */
  List<DestinyVendorCategory> categories;
}

/** Information about the category and items currently sold in that category. */
class DestinyVendorCategory {
  /**
   * An index into the DestinyVendorDefinition.displayCategories property, so you can
   * grab the display data for this category.
   */
  int displayCategoryIndex;
  /**
   * An ordered list of indexes into items being sold in this category (
   * DestinyVendorDefinition.itemList) which will contain more information about the
   * items being sold themselves. Can also be used to index into
   * DestinyVendorSaleItemComponent data, if you asked for that data to be returned.
   */
  List<int> itemIndexes;
}

/**
 * The collection of all items currently being sold by a specific Vendor and
 * visible to the given character for which the request was made.
 */
class DestinyVendorSaleItemSetComponent {
  /**
   * The items being sold by this vendor, keyed by the vendorItemIndex of the item
   * being sold. (because showing sale items depends on the ordering dictated by the
   * categories being shown - see DestinyVendorCategoryComponent - this is a
   * dictionary for quick lookup capability.)
   */
  Map<int, DestinyVendorSaleItemComponent> saleItems;
}

/**
 * Request this component if you want the details about an item being sold in
 * relation to the character making the request: whether the character can buy it,
 * whether they can afford it, and other data related to purchasing the item.
 *
 * Note that if you want instance, stats, etc... data for the item, you'll have to
 * request additional components such as ItemInstances, ItemPerks etc... and
 * acquire them from the DestinyVendorResponse's "items" property.
 */
class DestinyVendorSaleItemComponent {
  /**
   * The index into the DestinyVendorDefinition.itemList property. Note that this
   * means Vendor data *is* Content Version dependent: make sure you have the latest
   * content before you use Vendor data, or these indexes may mismatch.
   *
   * Most systems avoid this problem, but Vendors is one area where we are unable to
   * reasonably avoid content dependency at the moment.
   */
  int vendorItemIndex;
  /**
   * The hash of the item being sold, as a quick shortcut for looking up the
   * DestinyInventoryItemDefinition of the sale item.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int itemHash;
  /**
   * If populated, this is the hash of the item whose icon (and other secondary
   * styles, but *not* the human readable strings) should override whatever icons/
   * styles are on the item being sold.
   *
   * If you don't do this, certain items whose styles are being overridden by
   * socketed items - such as the "Recycle Shader" item - would show whatever their
   * default icon/style is, and it wouldn't be pretty or look accurate.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int overrideStyleItemHash;
  /** How much of the item you'll be getting. */
  int quantity;
  /**
   * A flag indicating whether the requesting character can buy the item, and if not
   * the reasons why the character can't buy it.
   */
  int saleStatus;
  /** A summary of the current costs of the item. */
  List<DestinyItemQuantity> costs;
  /**
   * If you can't buy the item due to a complex character state, these will be hashes
   * for DestinyUnlockDefinitions that you can check to see messages regarding the
   * failure (if the unlocks have human readable information: it is not guaranteed
   * that Unlocks will have human readable strings, and your application will have to
   * handle that)
   *
   * Prefer using failureIndexes instead. These are provided for informational
   * purposes, but have largely been supplanted by failureIndexes.
   *
   * Mapped to DestinyUnlockDefinition in the manifest.
   */
  List<int> requiredUnlocks;
  /**
   * If any complex unlock states are checked in determining purchasability, these
   * will be returned here along with the status of the unlock check.
   *
   * Prefer using failureIndexes instead. These are provided for informational
   * purposes, but have largely been supplanted by failureIndexes.
   */
  List<DestinyUnlockStatus> unlockStatuses;
  /**
   * Indexes in to the "failureStrings" lookup table in DestinyVendorDefinition for
   * the given Vendor. Gives some more reliable failure information for why you can't
   * purchase an item.
   *
   * It is preferred to use these over requiredUnlocks and unlockStatuses: the latter
   * are provided mostly in case someone can do something interesting with it that I
   * didn't anticipate.
   */
  List<int> failureIndexes;
  /**
   * A flags enumeration value representing the current state of any "state modifiers"
   * on the item being sold. These are meant to correspond with some sort of visual
   * indicator as to the augmentation: for instance, if an item is on sale or if you
   * already own the item in question.
   *
   * Determining how you want to represent these in your own app (or if you even want
   * to) is an exercise left for the reader.
   */
  int augments;
  /**
   * If this item has its own custom date where it may be removed from the Vendor's
   * rotation, this is that date.
   *
   * Note that there's not actually any guarantee that it will go away: it could be
   * chosen again and end up still being in the Vendor's sale items! But this is the
   * next date where that test will occur, and is also the date that the game shows
   * for availability on things like Bounties being sold. So it's the best we can
   * give.
   */
  String overrideNextRefreshDate;
}

class VendorItemStatus {
   static const int Success = 0;
   static const int NoInventorySpace = 1;
   static const int NoFunds = 2;
   static const int NoProgression = 4;
   static const int NoUnlock = 8;
   static const int NoQuantity = 16;
   static const int OutsidePurchaseWindow = 32;
   static const int NotAvailable = 64;
   static const int UniquenessViolation = 128;
   static const int UnknownError = 256;
   static const int AlreadySelling = 512;
   static const int Unsellable = 1024;
   static const int SellingInhibited = 2048;
   static const int AlreadyOwned = 4096;
   static const int DisplayOnly = 8192;
}

/**
 * Indicates the status of an "Unlock Flag" on a Character or Profile.
 *
 * These are individual bits of state that can be either set or not set, and
 * sometimes provide interesting human-readable information in their related
 * DestinyUnlockDefinition.
 */
class DestinyUnlockStatus {
  /**
   * The hash identifier for the Unlock Flag. Use to lookup DestinyUnlockDefinition
   * for static data. Not all unlocks have human readable data - in fact, most don't.
   * But when they do, it can be very useful to show. Even if they don't have human
   * readable data, you might be able to infer the meaning of an unlock flag with a
   * bit of experimentation...
   *
   * Mapped to DestinyUnlockDefinition in the manifest.
   */
  int unlockHash;
  /** Whether the unlock flag is set. */
  bool isSet;
}

class DestinyVendorItemState {
  /** There are no augments on the item. */
   static const int None = 0;
  /**
   * Deprecated forever (probably). There was a time when Records were going to be
   * implemented through Vendors, and this field was relevant. Now they're
   * implemented through Presentation Nodes, and this field doesn't matter anymore.
   */
   static const int Incomplete = 1;
  /**
   * Deprecated forever (probably). See the description of the "Incomplete" value for
   * the juicy scoop.
   */
   static const int RewardAvailable = 2;
  /**
   * Deprecated forever (probably). See the description of the "Incomplete" value for
   * the juicy scoop.
   */
   static const int Complete = 4;
  /**
   * This item is considered to be "newly available", and should have some UI showing
   * how shiny it is.
   */
   static const int New = 8;
  /**
   * This item is being "featured", and should be shiny in a different way from items
   * that are merely new.
   */
   static const int Featured = 16;
  /** This item is only available for a limited time, and that time is approaching. */
   static const int Ending = 32;
  /** This item is "on sale". Get it while it's hot. */
   static const int OnSale = 64;
  /** This item is already owned. */
   static const int Owned = 128;
  /** This item should be shown with a "wide view" instead of normal icon view. */
   static const int WideView = 256;
  /**
   * This indicates that you should show some kind of attention-requesting indicator
   * on the item, in a similar manner to items in the nexus that have such
   * notifications.
   */
   static const int NexusAttention = 512;
}

class DestinyItemComponentSetOfint32 {
  DictionaryComponentResponse<DestinyItemInstanceComponent> instances;
  DictionaryComponentResponse<DestinyItemPerksComponent> perks;
  DictionaryComponentResponse<DestinyItemRenderComponent> renderData;
  DictionaryComponentResponse<DestinyItemStatsComponent> stats;
  DictionaryComponentResponse<DestinyItemSocketsComponent> sockets;
  DictionaryComponentResponse<DestinyItemTalentGridComponent> talentGrids;
  DictionaryComponentResponse<DestinyItemPlugComponent> plugStates;
  DictionaryComponentResponse<DestinyItemObjectivesComponent> objectives;
}

/** A response containing all of the components for a vendor. */
class DestinyVendorResponse {
  /**
   * The base properties of the vendor.
   *
   * COMPONENT TYPE: Vendors
   */
  int vendor;
  /**
   * Categories that the vendor has available, and references to the sales therein.
   *
   * COMPONENT TYPE: VendorCategories
   */
  int categories;
  /**
   * Sales, keyed by the vendorItemIndex of the item being sold.
   *
   * COMPONENT TYPE: VendorSales
   */
  int sales;
  /**
   * Item components, keyed by the vendorItemIndex of the active sale items.
   *
   * COMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component
   * types.]
   */
  int itemComponents;
  /**
   * A "lookup" convenience component that can be used to quickly check if the
   * character has access to items that can be used for purchasing.
   *
   * COMPONENT TYPE: CurrencyLookups
   */
  int currencyLookups;
}

/**
 * Returns the detailed information about a Collectible Presentation Node and any
 * Collectibles that are direct descendants.
 */
class DestinyCollectibleNodeDetailResponse {
  /** COMPONENT TYPE: Collectibles */
  int collectibles;
  /**
   * Item components, keyed by the item hash of the items pointed at collectibles
   * found under the requested Presentation Node.
   *
   * NOTE: I had a lot of hemming and hawing about whether these should be keyed by
   * collectible hash or item hash... but ultimately having it be keyed by item hash
   * meant that UI that already uses DestinyItemComponentSet data wouldn't have to
   * have a special override to do the collectible -> item lookup once you delve into
   * an item's details, and it also meant that you didn't have to remember that the
   * Hash being used as the key for plugSets was different from the Hash being used
   * for the other Dictionaries. As a result, using the Item Hash felt like the least
   * crappy solution.
   *
   * We may all come to regret this decision. We will see.
   *
   * COMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component
   * types.]
   */
  int collectibleItemComponents;
}

class DestinyItemComponentSetOfuint32 {
  DictionaryComponentResponse<DestinyItemInstanceComponent> instances;
  DictionaryComponentResponse<DestinyItemPerksComponent> perks;
  DictionaryComponentResponse<DestinyItemRenderComponent> renderData;
  DictionaryComponentResponse<DestinyItemStatsComponent> stats;
  DictionaryComponentResponse<DestinyItemSocketsComponent> sockets;
  DictionaryComponentResponse<DestinyItemTalentGridComponent> talentGrids;
  DictionaryComponentResponse<DestinyItemPlugComponent> plugStates;
  DictionaryComponentResponse<DestinyItemObjectivesComponent> objectives;
}

/** The results of a bulk Equipping operation performed through the Destiny API. */
class DestinyEquipItemResults {
  List<DestinyEquipItemResult> equipResults;
}

/** The results of an Equipping operation performed through the Destiny API. */
class DestinyEquipItemResult {
  /**
   * The instance ID of the item in question (all items that can be equipped must,
   * but definition, be Instanced and thus have an Instance ID that you can use to
   * refer to them)
   */
  String itemInstanceId;
  /** A PlatformErrorCodes enum indicating whether it succeeded, and if it failed why. */
  int equipStatus;
}

/**
 * Represents all of the data related to a single plug to be inserted.
 *
 * Note that, while you *can* point to a socket that represents infusion, you will
 * receive an error if you attempt to do so. Come on guys, let's play nice.
 */
class DestinyInsertPlugsRequestEntry {
  /**
   * The index into the socket array, which identifies the specific socket being
   * operated on. We also need to know the socketArrayType in order to uniquely
   * identify the socket.
   *
   * Don't point to or try to insert a plug into an infusion socket. It won't work.
   */
  int socketIndex;
  /**
   * This property, combined with the socketIndex, tells us which socket we are
   * referring to (since operations can be performed on both Intrinsic and "default"
   * sockets, and they occupy different arrays in the Inventory Item Definition). I
   * know, I know. Don't give me that look.
   */
  int socketArrayType;
  /**
   * Plugs are never instanced (except in infusion). So with the hash alone, we
   * should be able to: 1) Infer whether the player actually needs to have the item,
   * or if it's a reusable plug 2) Perform any operation needed to use the Plug,
   * including removing the plug item and running reward sheets.
   */
  int plugItemHash;
}

class DestinySocketArrayType {
   static const int Default = 0;
   static const int Intrinsic = 1;
}

class DestinyItemChangeResponse {
  DestinyItemResponse item;
  /** Items that appeared in the inventory possibly as a result of an action. */
  List<DestinyItemComponent> addedInventoryItems;
  /** Items that disappeared from the inventory possibly as a result of an action. */
  List<DestinyItemComponent> removedInventoryItems;
}

class DestinyPostGameCarnageReportData {
  /** Date and time for the activity. */
  String period;
  /**
   * If this activity has "phases", this is the phase at which the activity was
   * started.
   */
  int startingPhaseIndex;
  /** Details about the activity. */
  int activityDetails;
  /** Collection of players and their data for this activity. */
  List<DestinyPostGameCarnageReportEntry> entries;
  /** Collection of stats for the player in this activity. */
  List<DestinyPostGameCarnageReportTeamEntry> teams;
}

/** Summary information about the activity that was played. */
class DestinyHistoricalStatsActivity {
  /**
   * The unique hash identifier of the DestinyActivityDefinition that was played. If
   * I had this to do over, it'd be named activityHash. Too late now.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int referenceId;
  /**
   * The unique hash identifier of the DestinyActivityDefinition that was played.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int directorActivityHash;
  /**
   * The unique identifier for this *specific* match that was played.
   *
   * This value can be used to get additional data about this activity such as who
   * else was playing via the GetPostGameCarnageReport endpoint.
   */
  String instanceId;
  /** Indicates the most specific game mode of the activity that we could find. */
  int mode;
  /**
   * The list of all Activity Modes to which this activity applies, including
   * aggregates. This will let you see, for example, whether the activity was both
   * Clash and part of the Trials of the Nine event.
   */
  List<DestinyActivityModeType> modes;
  /**
   * Whether or not the match was a private match. There's no private matches in
   * Destiny 2... yet... DUN DUN DUNNNN
   */
  bool isPrivate;
}

class DestinyPostGameCarnageReportEntry {
  /** Standing of the player */
  int standing;
  /** Score of the player if available */
  int score;
  /** Identity details of the player */
  int player;
  /** ID of the player's character used in the activity. */
  String characterId;
  /** Collection of stats for the player in this activity. */
  Map<String, DestinyHistoricalStatsValue> values;
  /** Extended data extracted from the activity blob. */
  int extended;
}

class DestinyHistoricalStatsValue {
  /** Unique ID for this stat */
  String statId;
  /** Basic stat value. */
  int basic;
  /** Per game average for the statistic, if applicable */
  int pga;
  /** Weighted value of the stat if a weight greater than 1 has been assigned. */
  int weighted;
  /**
   * When a stat represents the best, most, longest, fastest or some other personal
   * best, the actual activity ID where that personal best was established is
   * available on this property.
   */
  String activityId;
}

class DestinyHistoricalStatsValuePair {
  /** Raw value of the statistic */
  double value;
  /** Localized formated version of the value. */
  String displayValue;
}

class DestinyPlayer {
  /**
   * Details about the player as they are known in game (platform display name,
   * Destiny emblem)
   */
  int destinyUserInfo;
  /** Class of the character if applicable and available. */
  String characterClass;
  int classHash;
  int raceHash;
  int genderHash;
  /** Level of the character if available. Zero if it is not available. */
  int characterLevel;
  /** Light Level of the character if available. Zero if it is not available. */
  int lightLevel;
  /**
   * Details about the player as they are known on BungieNet. This will be undefined
   * if the player has marked their credential private, or does not have a BungieNet
   * account.
   */
  int bungieNetUserInfo;
  /**
   * Current clan name for the player. This value may be null or an empty string if
   * the user does not have a clan.
   */
  String clanName;
  /**
   * Current clan tag for the player. This value may be null or an empty string if
   * the user does not have a clan.
   */
  String clanTag;
  /**
   * If we know the emblem's hash, this can be used to look up the player's emblem at
   * the time of a match when receiving PGCR data, or otherwise their currently
   * equipped emblem (if we are able to obtain it).
   */
  int emblemHash;
}

class DestinyPostGameCarnageReportExtendedData {
  /** List of weapons and their perspective values. */
  List<DestinyHistoricalWeaponStats> weapons;
  /** Collection of stats for the player in this activity. */
  Map<String, DestinyHistoricalStatsValue> values;
}

class DestinyHistoricalWeaponStats {
  /**
   * The hash ID of the item definition that describes the weapon.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int referenceId;
  /** Collection of stats for the period. */
  Map<String, DestinyHistoricalStatsValue> values;
}

class DestinyPostGameCarnageReportTeamEntry {
  /** Integer ID for the team. */
  int teamId;
  /** Team's standing relative to other teams. */
  int standing;
  /** Score earned by the team */
  int score;
  /** Alpha or Bravo */
  String teamName;
}

/**
 * If you're going to report someone for a Terms of Service violation, you need to
 * choose a category and reason for the report. This definition holds both the
 * categories and the reasons within those categories, for simplicity and my own
 * laziness' sake.
 *
 * Note tha this means that, to refer to a Reason by reasonHash, you need a
 * combination of the reasonHash *and* the associated ReasonCategory's hash: there
 * are some reasons defined under multiple categories.
 */
class DestinyReportReasonCategoryDefinition {
  DestinyDisplayPropertiesDefinition displayProperties;
  /** The specific reasons for the report under this category. */
  Map<int, DestinyReportReasonDefinition> reasons;
  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of
   * entity, but not globally.
   *
   * When entities refer to each other in Destiny content, it is this hash that they
   * are referring to.
   */
  int hash;
  /** The index of the entity as it was found in the investment tables. */
  int index;
  /**
   * If this is true, then there is an entity with this identifier/type combination,
   * but BNet is not yet allowed to show it. Sorry!
   */
  bool redacted;
}

/**
 * A specific reason for being banned. Only accessible under the related category (
 * DestinyReportReasonCategoryDefinition) under which it is shown. Note that this
 * means that report reasons' reasonHash are not globally unique: and indeed,
 * entries like "Other" are defined under most categories for example.
 */
class DestinyReportReasonDefinition {
  /**
   * The identifier for the reason: they are only guaranteed unique under the
   * Category in which they are found.
   */
  int reasonHash;
  DestinyDisplayPropertiesDefinition displayProperties;
}

class DestinyHistoricalStatsDefinition {
  /** Unique programmer friendly ID for this stat */
  String statId;
  /** Statistic group */
  int group;
  /** Time periods the statistic covers */
  List<PeriodType> periodTypes;
  /** Game modes where this statistic can be reported. */
  List<DestinyActivityModeType> modes;
  /** Category for the stat. */
  int category;
  /** Display name */
  String statName;
  /** Display name abbreviated */
  String statNameAbbr;
  /** Description of a stat if applicable. */
  String statDescription;
  /** Unit, if any, for the statistic */
  int unitType;
  /** Optional URI to an icon for the statistic */
  String iconImage;
  /** Optional icon for the statistic */
  int mergeMethod;
  /** Localized Unit Name for the stat. */
  String unitLabel;
  /** Weight assigned to this stat indicating its relative impressiveness. */
  int weight;
  /** The tier associated with this medal - be it implicitly or explicitly. */
  int medalTierHash;
}

class DestinyStatsCategoryType {
   static const int None = 0;
   static const int Kills = 1;
   static const int Assists = 2;
   static const int Deaths = 3;
   static const int Criticals = 4;
   static const int KDa = 5;
   static const int KD = 6;
   static const int Score = 7;
   static const int Entered = 8;
   static const int TimePlayed = 9;
   static const int MedalWins = 10;
   static const int MedalGame = 11;
   static const int MedalSpecialKills = 12;
   static const int MedalSprees = 13;
   static const int MedalMultiKills = 14;
   static const int MedalAbilities = 15;
}

class UnitType {
   static const int None = 0;
  /** Indicates the statistic is a simple count of something. */
   static const int Count = 1;
  /** Indicates the statistic is a per game average. */
   static const int PerGame = 2;
  /** Indicates the number of seconds */
   static const int Seconds = 3;
  /** Indicates the number of points earned */
   static const int Points = 4;
  /** Values represents a team ID */
   static const int Team = 5;
  /** Values represents a distance (units to-be-determined) */
   static const int Distance = 6;
  /** Ratio represented as a whole value from 0 to 100. */
   static const int Percent = 7;
  /** Ratio of something, shown with decimal places */
   static const int Ratio = 8;
  /** True or false */
   static const int Boolean = 9;
  /** The stat is actually a weapon type. */
   static const int WeaponType = 10;
  /** Indicates victory, defeat, or something in between. */
   static const int Standing = 11;
  /** Number of milliseconds some event spanned. For example, race time, or lap time. */
   static const int Milliseconds = 12;
  /** The value is a enumeration of the Completion Reason type. */
   static const int CompletionReason = 13;
}

class DestinyLeaderboard {
  String statId;
  List<DestinyLeaderboardEntry> entries;
}

class DestinyLeaderboardEntry {
  /** Where this player ranks on the leaderboard. A value of 1 is the top rank. */
  int rank;
  /** Identity details of the player */
  int player;
  /** ID of the player's best character for the reported stat. */
  String characterId;
  /** Value of the stat for this player */
  int value;
}

class DestinyClanAggregateStat {
  /** The id of the mode of stats (allPvp, allPvE, etc) */
  int mode;
  /** The id of the stat */
  String statId;
  /** Value of the stat for this player */
  int value;
}

/**
 * The results of a search for Destiny content. This will be improved on over time,
 * I've been doing some experimenting to see what might be useful.
 */
class DestinyEntitySearchResult {
  /**
   * A list of suggested words that might make for better search results, based on
   * the text searched for.
   */
  List<String> suggestedWords;
  /**
   * The items found that are matches/near matches for the searched-for term, sorted
   * by something vaguely resembling "relevance". Hopefully this will get better in
   * the future.
   */
  int results;
}

class SearchResultOfDestinyEntitySearchResultItem {
  List<DestinyEntitySearchResultItem> results;
  int totalResults;
  bool hasMore;
  PagedQuery query;
  String replacementContinuationToken;
  /**
   * If useTotalResults is true, then totalResults represents an accurate count.
   *
   * If False, it does not, and may be estimated/only the size of the current page.
   *
   * Either way, you should probably always only trust hasMore.
   *
   * This is a long-held historical throwback to when we used to do paging with known
   * total results. Those queries toasted our database, and we were left to hastily
   * alter our endpoints and create backward- compatible shims, of which
   * useTotalResults is one.
   */
  bool useTotalResults;
}

/** An individual Destiny Entity returned from the entity search. */
class DestinyEntitySearchResultItem {
  /**
   * The hash identifier of the entity. You will use this to look up the
   * DestinyDefinition relevant for the entity found.
   */
  int hash;
  /**
   * The type of entity, returned as a string matching the DestinyDefinition's
   * contract class name. You'll have to have your own mapping from class names to
   * actually looking up those definitions in the manifest databases.
   */
  String entityType;
  /**
   * Basic display properties on the entity, so you don't have to look up the
   * definition to show basic results for the item.
   */
  int displayProperties;
  /**
   * The ranking value for sorting that we calculated using our relevance formula.
   * This will hopefully get better with time and iteration.
   */
  double weight;
}

class DestinyHistoricalStatsByPeriod {
  Map<String, DestinyHistoricalStatsValue> allTime;
  Map<String, DestinyHistoricalStatsValue> allTimeTier1;
  Map<String, DestinyHistoricalStatsValue> allTimeTier2;
  Map<String, DestinyHistoricalStatsValue> allTimeTier3;
  List<DestinyHistoricalStatsPeriodGroup> daily;
  List<DestinyHistoricalStatsPeriodGroup> monthly;
}

class DestinyHistoricalStatsPeriodGroup {
  /**
   * Period for the group. If the stat periodType is day, then this will have a
   * specific day. If the type is monthly, then this value will be the first day of
   * the applicable month. This value is not set when the periodType is 'all time'.
   */
  String period;
  /** If the period group is for a specific activity, this property will be set. */
  int activityDetails;
  /** Collection of stats for the period. */
  Map<String, DestinyHistoricalStatsValue> values;
}

class DestinyHistoricalStatsAccountResult {
  DestinyHistoricalStatsWithMerged mergedDeletedCharacters;
  DestinyHistoricalStatsWithMerged mergedAllCharacters;
  List<DestinyHistoricalStatsPerCharacter> characters;
}

class DestinyHistoricalStatsWithMerged {
  Map<String, DestinyHistoricalStatsByPeriod> results;
  DestinyHistoricalStatsByPeriod merged;
}

class DestinyHistoricalStatsPerCharacter {
  String characterId;
  bool deleted;
  Map<String, DestinyHistoricalStatsByPeriod> results;
  DestinyHistoricalStatsByPeriod merged;
}

class DestinyActivityHistoryResults {
  /** List of activities, the most recent activity first. */
  List<DestinyHistoricalStatsPeriodGroup> activities;
}

class DestinyHistoricalWeaponStatsData {
  /** List of weapons and their perspective values. */
  List<DestinyHistoricalWeaponStats> weapons;
}

class DestinyAggregateActivityResults {
  /** List of all activities the player has participated in. */
  List<DestinyAggregateActivityStats> activities;
}

class DestinyAggregateActivityStats {
  /**
   * Hash ID that can be looked up in the DestinyActivityTable.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int activityHash;
  /** Collection of stats for the player in this activity. */
  Map<String, DestinyHistoricalStatsValue> values;
}

/**
 * Represents localized, extended content related to Milestones. This is
 * intentionally returned by a separate endpoint and not with Character-level
 * Milestone data because we do not put localized data into standard Destiny
 * responses, both for brevity of response and for caching purposes. If you really
 * need this data, hit the Milestone Content endpoint.
 */
class DestinyMilestoneContent {
  /** The "About this Milestone" text from the Firehose. */
  String about;
  /** The Current Status of the Milestone, as driven by the Firehose. */
  String status;
  /** A list of tips, provided by the Firehose. */
  List<String> tips;
  /**
   * If DPS has defined items related to this Milestone, they can categorize those
   * items in the Firehose. That data will then be returned as item categories here.
   */
  List<DestinyMilestoneContentItemCategory> itemCategories;
}

/**
 * Part of our dynamic, localized Milestone content is arbitrary categories of
 * items. These are built in our content management system, and thus aren't the
 * same as programmatically generated rewards.
 */
class DestinyMilestoneContentItemCategory {
  String title;
  /** Mapped to DestinyInventoryItemDefinition in the manifest. */
  List<int> itemHashes;
}

/**
 * Information about milestones, presented in a character state-agnostic manner.
 * Combine this data with DestinyMilestoneDefinition to get a full picture of the
 * milestone, which is basically a checklist of things to do in the game. Think of
 * this as GetPublicAdvisors 3.0, for those who used the Destiny 1 API.
 */
class DestinyPublicMilestone {
  /**
   * The hash identifier for the milestone. Use it to look up the
   * DestinyMilestoneDefinition for static data about the Milestone.
   *
   * Mapped to DestinyMilestoneDefinition in the manifest.
   */
  int milestoneHash;
  /**
   * A milestone not need have even a single quest, but if there are active quests
   * they will be returned here.
   */
  List<DestinyPublicMilestoneQuest> availableQuests;
  List<DestinyPublicMilestoneChallengeActivity> activities;
  /**
   * Sometimes milestones - or activities active in milestones - will have relevant
   * vendors. These are the vendors that are currently relevant.
   *
   * Deprecated, already, for the sake of the new "vendors" property that has more
   * data. What was I thinking.
   */
  List<int> vendorHashes;
  /**
   * This is why we can't have nice things. This is the ordered list of vendors to be
   * shown that relate to this milestone, potentially along with other interesting
   * data.
   */
  List<DestinyPublicMilestoneVendor> vendors;
  /** If known, this is the date when the Milestone started/became active. */
  String startDate;
  /** If known, this is the date when the Milestone will expire/recycle/end. */
  String endDate;
  /**
   * Used for ordering milestones in a display to match how we order them in BNet.
   * May pull from static data, or possibly in the future from dynamic information.
   */
  int order;
}

class DestinyPublicMilestoneQuest {
  /**
   * Quests are defined as Items in content. As such, this is the hash identifier of
   * the DestinyInventoryItemDefinition that represents this quest. It will have
   * pointers to all of the steps in the quest, and display information for the quest
   * (title, description, icon etc) Individual steps will be referred to in the Quest
   * item's DestinyInventoryItemDefinition.setData property, and themselves are Items
   * with their own renderable data.
   *
   * Mapped to DestinyMilestoneDefinition in the manifest.
   */
  int questItemHash;
  /**
   * A milestone need not have an active activity, but if there is one it will be
   * returned here, along with any variant and additional information.
   */
  int activity;
  /**
   * For the given quest there could be 0-to-Many challenges: mini quests that you
   * can perform in the course of doing this quest, that may grant you rewards and
   * benefits.
   */
  List<DestinyPublicMilestoneChallenge> challenges;
}

/**
 * A milestone may have one or more conceptual Activities associated with it, and
 * each of those conceptual activities could have a variety of variants, modes,
 * tiers, what-have-you. Our attempts to determine what qualifies as a conceptual
 * activity are, unfortunately, janky. So if you see missing modes or modes that
 * don't seem appropriate to you, let us know and I'll buy you a beer if we ever
 * meet up in person.
 */
class DestinyPublicMilestoneActivity {
  /**
   * The hash identifier of the activity that's been chosen to be considered the
   * canonical "conceptual" activity definition. This may have many variants, defined
   * herein.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int activityHash;
  /**
   * The activity may have 0-to-many modifiers: if it does, this will contain the
   * hashes to the DestinyActivityModifierDefinition that defines the modifier being
   * applied.
   *
   * Mapped to DestinyActivityModifierDefinition in the manifest.
   */
  List<int> modifierHashes;
  /**
   * Every relevant variation of this conceptual activity, including the conceptual
   * activity itself, have variants defined here.
   */
  List<DestinyPublicMilestoneActivityVariant> variants;
  /**
   * The hash identifier of the most specific Activity Mode under which this activity
   * is played. This is useful for situations where the activity in question is - for
   * instance - a PVP map, but it's not clear what mode the PVP map is being played
   * under. If it's a playlist, this will be less specific: but hopefully useful in
   * some way.
   *
   * Mapped to DestinyActivityModeDefinition in the manifest.
   */
  int activityModeHash;
  /**
   * The enumeration equivalent of the most specific Activity Mode under which this
   * activity is played.
   */
  int activityModeType;
}

/** Represents a variant of an activity that's relevant to a milestone. */
class DestinyPublicMilestoneActivityVariant {
  /**
   * The hash identifier of this activity variant. Examine the activity's definition
   * in the Manifest database to determine what makes it a distinct variant. Usually
   * it will be difficulty level or whether or not it is a guided game variant of the
   * activity, but theoretically it could be distinguished in any arbitrary way.
   */
  int activityHash;
  /**
   * The hash identifier of the most specific Activity Mode under which this activity
   * is played. This is useful for situations where the activity in question is - for
   * instance - a PVP map, but it's not clear what mode the PVP map is being played
   * under. If it's a playlist, this will be less specific: but hopefully useful in
   * some way.
   *
   * Mapped to DestinyActivityModeDefinition in the manifest.
   */
  int activityModeHash;
  /**
   * The enumeration equivalent of the most specific Activity Mode under which this
   * activity is played.
   */
  int activityModeType;
}

/**
 * A Milestone can have many Challenges. Challenges are just extra Objectives that
 * provide a fun way to mix-up play and provide extra rewards.
 */
class DestinyPublicMilestoneChallenge {
  /**
   * The objective for the Challenge, which should have human-readable data about
   * what needs to be done to accomplish the objective. Use this hash to look up the
   * DestinyObjectiveDefinition.
   *
   * Mapped to DestinyObjectiveDefinition in the manifest.
   */
  int objectiveHash;
  /**
   * IF the Objective is related to a specific Activity, this will be that activity's
   * hash. Use it to look up the DestinyActivityDefinition for additional data to
   * show.
   *
   * Mapped to DestinyActivityDefinition in the manifest.
   */
  int activityHash;
}

class DestinyPublicMilestoneChallengeActivity {
  /** Mapped to DestinyActivityDefinition in the manifest. */
  int activityHash;
  List<int> challengeObjectiveHashes;
  /**
   * If the activity has modifiers, this will be the list of modifiers that all
   * variants have in common. Perform lookups against
   * DestinyActivityModifierDefinition which defines the modifier being applied to
   * get at the modifier data.
   *
   * Note that, in the DestiyActivityDefinition, you will see many more modifiers
   * than this being referred to: those are all *possible* modifiers for the activity,
   * not the active ones. Use only the active ones to match what's really live.
   *
   * Mapped to DestinyActivityModifierDefinition in the manifest.
   */
  List<int> modifierHashes;
  /**
   * If returned, this is the index into the DestinyActivityDefinition's "loadouts"
   * property, indicating the currently active loadout requirements.
   */
  int loadoutRequirementIndex;
}

class DestinyPublicMilestoneVendor {
  /**
   * The hash identifier of the Vendor related to this Milestone. You can show useful
   * things from this, such as thier Faction icon or whatever you might care about.
   *
   * Mapped to DestinyVendorDefinition in the manifest.
   */
  int vendorHash;
  /**
   * If this vendor is featuring a specific item for this event, this will be the
   * hash identifier of that item. I'm taking bets now on how long we go before this
   * needs to be a list or some other, more complex representation instead and I
   * deprecate this too. I'm going to go with 5 months. Calling it now, 2017-09-14 at
   * 9:46pm PST.
   *
   * Mapped to DestinyInventoryItemDefinition in the manifest.
   */
  int previewItemHash;
}

class AwaType {
   static const int None = 0;
  /** Insert plugs into sockets. */
   static const int InsertPlugs = 1;
}

class AwaInitializeResponse {
  /**
   * ID used to get the token. Present this ID to the user as it will identify this
   * specific request on their device.
   */
  String correlationId;
  /** True if the PUSH message will only be sent to the device that made this request. */
  bool sentToSelf;
}

class AwaUserSelection {
   static const int None = 0;
   static const int Rejected = 1;
   static const int Approved = 2;
}

class AwaAuthorizationResult {
  /**
   * Indication of how the user responded to the request. If the value is "Approved"
   * the actionToken will contain the token that can be presented when performing the
   * advanced write action.
   */
  int userSelection;
  AwaResponseReason responseReason;
  /** Message to the app developer to help understand the response. */
  String developerNote;
  /** Credential used to prove the user authorized an advanced write action. */
  String actionToken;
  /**
   * This token may be used to perform the requested action this number of times, at
   * a maximum. If this value is 0, then there is no limit.
   */
  int maximumNumberOfUses;
  /** Time, UTC, when token expires. */
  String validUntil;
  /** Advanced Write Action Type from the permission request. */
  int type;
  /** MembershipType from the permission request. */
  int membershipType;
}

class AwaResponseReason {
   static const int None = 0;
  /** User provided an answer */
   static const int Answered = 1;
  /**
   * The HTTP request timed out, a new request may be made and an answer may still be
   * provided.
   */
   static const int TimedOut = 2;
  /** This request was replaced by another request. */
   static const int Replaced = 3;
}

/**
 * Represents the public-facing status of an activity: any data about what is
 * currently active in the Activity, regardless of an individual character's
 * progress in it.
 */
class DestinyPublicActivityStatus {
  /**
   * Active Challenges for the activity, if any - represented as hashes for
   * DestinyObjectiveDefinitions.
   *
   * Mapped to DestinyObjectiveDefinition in the manifest.
   */
  List<int> challengeObjectiveHashes;
  /**
   * The active modifiers on this activity, if any - represented as hashes for
   * DestinyActivityModifierDefinitions.
   *
   * Mapped to DestinyActivityModifierDefinition in the manifest.
   */
  List<int> modifierHashes;
  /**
   * If the activity itself provides any specific "mock" rewards, this will be the
   * items and their quantity.
   *
   * Why "mock", you ask? Because these are the rewards as they are represented in
   * the tooltip of the Activity.
   *
   * These are often pointers to fake items that look good in a tooltip, but
   * represent an abstract concept of what you will get for a reward rather than the
   * specific items you may obtain.
   */
  List<DestinyItemQuantity> rewardTooltipItems;
}
