/**
 * Bungie.Net API
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.3.2
 * Contact: support@bungie.com
 *
 * NOTE: This class is auto generated by the bungie-api-ts code generator program.
 * https://github.com/DestinyItemManager/bugie-api-ts
 * Do not edit these files manually.
 */

import '../common.dart';
import '../user/interfaces.dart';

class ContentTypeDescription {
  String cType;
  String name;
  String contentDescription;
  String previewImage;
  int priority;
  String reminder;
  List<ContentTypeProperty> properties;
  List<TagMetadataDefinition> tagMetadata;
  Map<String, TagMetadataItem> tagMetadataItems;
  List<String> usageExamples;
  bool showInContentEditor;
  String typeOf;
  String bindIdentifierToProperty;
  String boundRegex;
  bool forceIdentifierBinding;
  bool allowComments;
  bool autoEnglishPropertyFallback;
  bool bulkUploadable;
  List<ContentPreview> previews;
  bool suppressCmsPath;
  List<ContentTypePropertySection> propertySections;
}

class ContentTypeProperty {
  String name;
  String readableName;
  String value;
  String propertyDescription;
  bool localizable;
  bool fallback;
  bool enabled;
  int order;
  bool visible;
  bool isTitle;
  bool required;
  int maxLength;
  int maxByteLength;
  int maxFileSize;
  String regexp;
  String validateAs;
  String rssAttribute;
  String visibleDependency;
  String visibleOn;
  ContentPropertyDataTypeEnum datatype;
  Map<String, String> attributes;
  List<ContentTypeProperty> childProperties;
  String contentTypeAllowed;
  String bindToProperty;
  String boundRegex;
  Map<String, String> representationSelection;
  List<ContentTypeDefaultValue> defaultValues;
  bool isExternalAllowed;
  String propertySection;
  int weight;
  String entitytype;
  bool isCombo;
  bool suppressProperty;
  List<String> legalContentTypes;
  String representationValidationString;
  int minWidth;
  int maxWidth;
  int minHeight;
  int maxHeight;
  bool isVideo;
  bool isImage;
}

class ContentPropertyDataTypeEnum {
   static const int None = 0;
   static const int Plaintext = 1;
   static const int Html = 2;
   static const int Dropdown = 3;
   static const int List = 4;
   static const int Json = 5;
   static const int Content = 6;
   static const int Representation = 7;
   static const int Set = 8;
   static const int File = 9;
   static const int FolderSet = 10;
   static const int Date = 11;
   static const int MultilinePlaintext = 12;
   static const int DestinyContent = 13;
   static const int Color = 14;
}

class ContentTypeDefaultValue {
  String whenClause;
  String whenValue;
  String defaultValue;
}

class TagMetadataDefinition {
  String description;
  int order;
  List<TagMetadataItem> items;
  String datatype;
  String name;
  bool isRequired;
}

class TagMetadataItem {
  String description;
  String tagText;
  List<String> groups;
  bool isDefault;
  String name;
}

class ContentPreview {
  String name;
  String path;
  bool itemInSet;
  String setTag;
  int setNesting;
  int useSetId;
}

class ContentTypePropertySection {
  String name;
  String readableName;
  bool collapsed;
}

class ContentItemPublicContract {
  String contentId;
  String cType;
  String cmsPath;
  String creationDate;
  String modifyDate;
  bool allowComments;
  bool hasAgeGate;
  int minimumAge;
  String ratingImagePath;
  GeneralUser author;
  bool autoEnglishPropertyFallback;
  /**
   * Firehose content is really a collection of metadata and "properties", which are
   * the potentially-but-not-strictly localizable data that comprises the meat of
   * whatever content is being shown.
   *
   * As Cole Porter would have crooned, "Anything Goes" with Firehose properties.
   * They are most often strings, but they can theoretically be anything. They are
   * JSON encoded, and could be JSON structures, simple strings, numbers etc... The
   * Content Type of the item (cType) will describe the properties, and thus how they
   * ought to be deserialized.
   */
  Map<String, Object> properties;
  List<ContentRepresentation> representations;
  List<String> tags;
  CommentSummary commentSummary;
}

class ContentRepresentation {
  String name;
  String path;
  String validationString;
}

class CommentSummary {
  String topicId;
  int commentCount;
}

class SearchResultOfContentItemPublicContract {
  List<ContentItemPublicContract> results;
  int totalResults;
  bool hasMore;
  PagedQuery query;
  String replacementContinuationToken;
  /**
   * If useTotalResults is true, then totalResults represents an accurate count.
   *
   * If False, it does not, and may be estimated/only the size of the current page.
   *
   * Either way, you should probably always only trust hasMore.
   *
   * This is a long-held historical throwback to when we used to do paging with known
   * total results. Those queries toasted our database, and we were left to hastily
   * alter our endpoints and create backward- compatible shims, of which
   * useTotalResults is one.
   */
  bool useTotalResults;
}
